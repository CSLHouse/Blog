{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/snippet/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/snippet/source/favicon1.ico","path":"favicon1.ico","modified":0,"renderable":1},{"_id":"themes/snippet/source/favicon2.ico","path":"favicon2.ico","modified":0,"renderable":1},{"_id":"themes/snippet/source/assets/highlight.pack.js","path":"assets/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/snippet/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/snippet/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/avatar1.jpg","path":"img/avatar1.jpg","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/branding.png","path":"img/branding.png","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/head-img.jpg","path":"img/head-img.jpg","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/timeline-clock.gif","path":"img/timeline-clock.gif","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/timeline-dot.gif","path":"img/timeline-dot.gif","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/timeline.gif","path":"img/timeline.gif","modified":0,"renderable":1},{"_id":"themes/snippet/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/snippet/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/snippet/source/assets/valine.min.js","path":"assets/valine.min.js","modified":0,"renderable":1},{"_id":"themes/snippet/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/snippet/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/snippet/.DS_Store","hash":"7d55a53fed0c7c113ae250e494f8180f7a49c3fb","modified":1545068659000},{"_id":"themes/snippet/.travis.yml","hash":"8b868cf1653a88ff06ebb776d7441c7a0e0f194b","modified":1545068662000},{"_id":"themes/snippet/LICENSE","hash":"c720db99e36a717d9808bf97b736612462e883dd","modified":1545068659000},{"_id":"themes/snippet/_config.yml","hash":"75f0b3d0e48616c727546797e8aad8d5ddba5e31","modified":1545068662000},{"_id":"themes/snippet/README.md","hash":"c4daa997c42363f2ef8a37d1be11c883545c84a9","modified":1545068662000},{"_id":"themes/snippet/_travis.sh","hash":"6f28564a4a83aed0e5cbe2969a07fa28ada6e1f4","modified":1545068661000},{"_id":"themes/snippet/gulpfile.js","hash":"876e7ff1359e589ec99ad29a7182d076831a6655","modified":1545068662000},{"_id":"themes/snippet/package.json","hash":"2ac1a7806f43b75a7e0111e4f6b89008528a5407","modified":1545068662000},{"_id":"source/_posts/Alfred.md","hash":"ec80473d9b4fa40496bfa8efda595458665c4125","modified":1547027441368},{"_id":"source/_posts/CentOS下编译安装shadowsocks-libev.md","hash":"069e22888d0aec5e865ea334148d41a4d6c3ca9e","modified":1547027441368},{"_id":"source/_posts/Dash.md","hash":"bc2beca7ed2904208093ff781648123ab81488f0","modified":1547027441368},{"_id":"source/_posts/Git-常用命令.md","hash":"67fc218906f4b88f41ef9bbd0ff017e309a6c27f","modified":1547027441368},{"_id":"source/_posts/Hexo-Blog.md","hash":"7a4da6fe3067e72d3ab3e5f2ab09057a635ac684","modified":1547027441368},{"_id":"source/_posts/Hexo新建页面显示多个文章.md","hash":"2bfbe5a66e0e886e50d445ef8d8aac1adfcdead4","modified":1547027441368},{"_id":"source/_posts/IOS马甲包混淆必过4-3审核上线方法整理.md","hash":"375dd4a8e34f4c5636e978cf533ccda42023c413","modified":1547027441368},{"_id":"source/_posts/Markdown.md","hash":"7993512530f3ad49cf1feefdd99571a74df372a6","modified":1547027441368},{"_id":"source/_posts/Python-读取文件.md","hash":"2081933a0ad8b3f2bdb51110b2c8c2f9dfade72a","modified":1547027441368},{"_id":"source/_posts/Python-配置虚拟环境.md","hash":"866f3c4e7ce949fb5dc356dce1d27a23dffa50f3","modified":1547027441368},{"_id":"source/_posts/ansible应用.md","hash":"29d16700c65cb4af2fea1ea476771f05d4bdcfa2","modified":1547027441368},{"_id":"source/_posts/centos7安装mysql.md","hash":"4e8f7588a851456e95570f26511a0cf2693d743f","modified":1547027441368},{"_id":"source/_posts/centos7配置网关.md","hash":"d4bbca218d52b221f996b8cbacfe00e02d8dba3f","modified":1547027441368},{"_id":"source/_posts/charles-android监听websocket.md","hash":"ee52a9109c8853fc6e4543a54f5deff9ddda358b","modified":1547027441368},{"_id":"source/_posts/django.md","hash":"c5232bb0bcd52275663cdf674a1bf628379c1435","modified":1547027441384},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1547027441384},{"_id":"source/_posts/linux常用命令.md","hash":"4c67866f34be4f11dcf8148d1018f6fe396d5db4","modified":1547027441384},{"_id":"source/_posts/mac使用ssh连接远程服务器并实现文件上传下砸.md","hash":"dcc1a580335a1031bd20e4ded4ad8014c518f21a","modified":1547027441384},{"_id":"source/_posts/usr-bin-pip-No-such-file-or-directory.md","hash":"694266c1829bd0f9f988b6162c45d8d5c6bd7542","modified":1547027441384},{"_id":"source/_posts/前端UI框架.md","hash":"b25257f3cf6d9d1b740ffc672b5ef20667091022","modified":1547027441384},{"_id":"source/_posts/彻底关闭windows-Defender.md","hash":"40be018568c952f260e3dc1b6f405e9adc9e7b3a","modified":1547027441384},{"_id":"source/_posts/搭建自己的翻墙服务器.md","hash":"7de254692fa9ae79d01a7eb459916dcfecbba830","modified":1547027441384},{"_id":"source/_posts/浏览器翻墙工具.md","hash":"15a60cb444199b6dafdb5d7ae258f2bcdfe69900","modified":1547027441384},{"_id":"themes/snippet/languages/default.yml","hash":"15a8c1544ce1358e90e54c19dcd3b2481c923a99","modified":1545068662000},{"_id":"themes/snippet/languages/zh-CN.yml","hash":"b38b3437f1bb36d1c21db1e19646da7feaff5195","modified":1545068662000},{"_id":"themes/snippet/languages/ja.yml","hash":"61c01467dfc43b6a9456b90fdd00c47701c95a35","modified":1545068662000},{"_id":"themes/snippet/languages/zh-TW.yml","hash":"c40aff781232225b6760f6fb1b6381f9c127b023","modified":1545068662000},{"_id":"themes/snippet/layout/archive.ejs","hash":"bbd99d08132f9ca87e5b17cf642384dc1673f579","modified":1545068659000},{"_id":"themes/snippet/layout/category.ejs","hash":"ebd05ceb75be73e84ddf085ccfdb24c07162d0fa","modified":1545068659000},{"_id":"themes/snippet/layout/index.ejs","hash":"306c55f441452d9ecfcf36cc63ba213b74393ef7","modified":1545068659000},{"_id":"themes/snippet/layout/layout.ejs","hash":"52fed256207419e105a504d825ed1b5b3b3c74fb","modified":1545068659000},{"_id":"themes/snippet/layout/page.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1545068661000},{"_id":"themes/snippet/layout/post.ejs","hash":"ccb56f5baac04ae8141e00141639cf068cb3d700","modified":1545068659000},{"_id":"themes/snippet/layout/tag.ejs","hash":"9b42656e75c58e7145e52408b51f017f6b6d9464","modified":1545068659000},{"_id":"themes/snippet/scripts/helper.js","hash":"836d369cf95ac51de957e09d396e6a8be1e84cf6","modified":1545068662000},{"_id":"themes/snippet/scripts/process.js","hash":"c2f0571899a6dd38bd944aaf47e21fc650f7d52e","modified":1545068662000},{"_id":"themes/snippet/source/.DS_Store","hash":"8983992a301632f377142eb0de9b7125c7a7c97a","modified":1545068661000},{"_id":"themes/snippet/source/favicon.ico","hash":"322f434396e8d2fbb9f540b5af16cd17e400e7f8","modified":1545068661000},{"_id":"themes/snippet/source/favicon1.ico","hash":"65f26147ea3433ffd64d3f18bf281af48dc5d06e","modified":1545068662000},{"_id":"themes/snippet/source/favicon2.ico","hash":"3ff8f701a0c74b9f3ef7f3eb4c839df678f54917","modified":1545068662000},{"_id":"source/_posts/Hexo新建页面显示多个文章/image_found.png","hash":"505ca80eab568059f19cd088420a9611082ad734","modified":1547027441368},{"_id":"source/_posts/Hexo新建页面显示多个文章/images_font.png","hash":"a8cc2a514a5445e36fb360c96a34cfda6d19253b","modified":1547027441368},{"_id":"source/_posts/搭建自己的翻墙服务器/PublicKey.png","hash":"0eb9b8e6ac7539dc4d29641c034e6c049fd2bd6d","modified":1547027441384},{"_id":"source/_posts/搭建自己的翻墙服务器/socksport.png","hash":"aa454de7a09f41fd9b034e66b306c43102f81b1d","modified":1547027441384},{"_id":"themes/snippet/layout/_partial/archive.ejs","hash":"17f5e3d17bc6bd9def8203ce1cb695b25603c12b","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/article-meta.ejs","hash":"378b70332d64fa0ae2ead1295d1d949ccb8ec18b","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/article.ejs","hash":"ecc6775b64c4b87a62fae4f8a2545105e40e7dfe","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/copyright.ejs","hash":"647c7d07a43414a92ba7a8b10a44d1284e2398a3","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/footer.ejs","hash":"4a5b6fa1520442ac4edc2ec3d575a676b6717854","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/gallery.ejs","hash":"1b6b7859f395e10a3ecaa900de2d1312dc140def","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/head.ejs","hash":"1aea0e44f11d9f6f3e78f0da7dba0f35b910e6c3","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/header.ejs","hash":"e16af580c2698a3035724535a51cc6a6fbf3b4fe","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/nav.ejs","hash":"7fa65a2162a748f049fb910b5b0e46a5bcf57b3b","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/pagination.ejs","hash":"2ec88a22fd29e7cc97ca2a508eee7d168e338969","modified":1545068660000},{"_id":"themes/snippet/layout/_partial/script.ejs","hash":"0ca1b747458208b4e34ad881c5c3361c3762a88c","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/sidebar.ejs","hash":"381b7af719c1ab3a94280309926c1205ce7b93a5","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/toc.ejs","hash":"7d86def87d0e7b7ab15400a23b0796f0da430e60","modified":1545068661000},{"_id":"themes/snippet/layout/_vendor/baidu_sitemap.ejs","hash":"f17db411dc1607e7d1eb133b7b7dfe5b575cabad","modified":1545068659000},{"_id":"themes/snippet/layout/_widget/archive.ejs","hash":"28b6e5f0e9cd9d4d316c7deb0f594eed52f0a4b4","modified":1545068661000},{"_id":"themes/snippet/layout/_widget/category.ejs","hash":"1c6881cd5b6b034ddecda6c85a3337d17a03e9ff","modified":1545068661000},{"_id":"themes/snippet/layout/_widget/friends.ejs","hash":"43b0404d608db1a237b3cf17ec8df7b2d24f9533","modified":1545068661000},{"_id":"themes/snippet/layout/_widget/notification.ejs","hash":"be5ee41c9287de606e6d286442f88604a8d478e4","modified":1545068661000},{"_id":"themes/snippet/layout/_widget/search.ejs","hash":"dfbf723051f71099502c58a237bc484cebd5157d","modified":1545068661000},{"_id":"themes/snippet/layout/_widget/social.ejs","hash":"f97313cdc1b495f7602e023b2ade5630acc4b667","modified":1545068661000},{"_id":"themes/snippet/layout/_widget/stick.ejs","hash":"6f8a1c0d8dd11a5e27243cd3d27a347c477b6d54","modified":1545068661000},{"_id":"themes/snippet/layout/_widget/tagcloud.ejs","hash":"457b6081e2f24afd5c4c3a2d566c1f5940f3f21a","modified":1545068661000},{"_id":"themes/snippet/source/assets/highlight.pack.js","hash":"f39840759ec9afe56ec1ca30579d1f1c9d1f6026","modified":1545068662000},{"_id":"themes/snippet/source/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1545068661000},{"_id":"themes/snippet/source/css/style.css","hash":"d5c8ad0fbf7634f66cbb945a6b1206e07ff54bf3","modified":1545068661000},{"_id":"themes/snippet/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1545068662000},{"_id":"themes/snippet/source/img/avatar.jpg","hash":"0ac7fd55965516636360e33372c870f386a50682","modified":1545068662000},{"_id":"themes/snippet/source/img/avatar1.jpg","hash":"512025710a8c6c938ab636fcb3c9da1c8df0eec0","modified":1545068662000},{"_id":"themes/snippet/source/img/branding.png","hash":"18bee49d6a4c521ad230047c0b416245e009c2c9","modified":1545068662000},{"_id":"themes/snippet/source/img/head-img.jpg","hash":"a318d304665c2f410f79e6d2eb1b98119f675b4b","modified":1545068662000},{"_id":"themes/snippet/source/img/timeline-clock.gif","hash":"e1f3e1061a38e9dcaa26963ab809ba0a70bb8221","modified":1545068662000},{"_id":"themes/snippet/source/img/timeline-dot.gif","hash":"c85ef87be5b631c009e7c5737d33b61dfe580a4d","modified":1545068662000},{"_id":"themes/snippet/source/img/timeline.gif","hash":"b7c7aac44e618df19626d882dc46db48a4aa3673","modified":1545068662000},{"_id":"themes/snippet/source/js/app.js","hash":"eca509fc5b45dcd1a0007c62f740529ca31a122f","modified":1545068662000},{"_id":"themes/snippet/source/js/search.js","hash":"a6c7ac73821e5c7db7d4ae6de2d00f44367a858e","modified":1545068661000},{"_id":"source/_posts/Hexo新建页面显示多个文章/categories.png","hash":"d14d0dbabf9351ce7468e409c711da70c76df4c6","modified":1547027441368},{"_id":"source/_posts/charles-android监听websocket/homewifi.png","hash":"3c207b924eaf102f99c84d4f3b17277f291b532c","modified":1547027441368},{"_id":"source/_posts/charles-android监听websocket/wlan.png","hash":"e60e5c4123308f867755d1a168577c04b5cbd29c","modified":1547027441384},{"_id":"source/_posts/搭建自己的翻墙服务器/auto.png","hash":"18585208521601336784aec220e4b43432b5b44d","modified":1547027441384},{"_id":"source/_posts/搭建自己的翻墙服务器/shadowsocks.png","hash":"e491c0baa050fa34a71fbb0121d6fcf2125a5620","modified":1547027441384},{"_id":"themes/snippet/source/assets/valine.min.js","hash":"bf7099fa607a93068dd01f109eaa2cd18663b946","modified":1545068662000},{"_id":"themes/snippet/source/css/bootstrap.min.css","hash":"6527d8bf3e1e9368bab8c7b60f56bc01fa3afd68","modified":1545068661000},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1545068662000},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1545068662000},{"_id":"themes/snippet/source/img/loading.gif","hash":"6cea4dc953ac09fb744c7fedc12a1f4736faf8ec","modified":1545068662000},{"_id":"source/_posts/charles-android监听websocket/wifi.png","hash":"b5df8d8860edbacca9e3abe00160fb94545e1daf","modified":1547027441384},{"_id":"themes/snippet/layout/_partial/_head-sections/seo.ejs","hash":"f80ec948f4f23763a1bf9b71efef6d6ebc6fc5d5","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/_head-sections/IE.ejs","hash":"567494a97ba2db7bb452294a9980b4d63b399ef0","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/_head-sections/style.ejs","hash":"ece8b1bb0f550ddb0e7ac179de54a8e5f06f49aa","modified":1545068661000},{"_id":"themes/snippet/layout/_partial/_head-sections/title.ejs","hash":"1482f56c44221cbc0d28ba06e377f4b55cdaacc2","modified":1545068661000},{"_id":"themes/snippet/layout/_vendor/analytics/baidu.ejs","hash":"eb4a75fb5ba9237d93430e727165d98ccda75a02","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/analytics/cnzz.ejs","hash":"8bfc514b178fafd81cc8181880afc5c9cbee02dc","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/analytics/google.ejs","hash":"91844d4521f97517ea9f169ee85b18c9d0d8cf17","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/analytics/index.ejs","hash":"6315abe9c31f4c4de719fa3cbfa2b1c6f294b0de","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/analytics/tencent.ejs","hash":"10b91084cda9067d037a5f31e48d4edcbaa0c751","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/comments/changyan.ejs","hash":"202c94162ac2eeb0c93c8d2667c82b8705de6390","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/comments/disqus.ejs","hash":"7b5e05154be0408be110893439bfa33e262245de","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/comments/gitment.ejs","hash":"be5c261ae8a769747704a228aa35758120b814e1","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/comments/index.ejs","hash":"26b2e774f427efce66253d284d26718c8e555bc0","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/comments/livere.ejs","hash":"6333308ba24ae6f2a3e73f4cdc1b42e024d19910","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/comments/uyan.ejs","hash":"2c2abe17f4f5c5ba1a9aaa948ef0a88d99f653f8","modified":1545068659000},{"_id":"themes/snippet/layout/_vendor/comments/valine.ejs","hash":"d339116cf24e76e7bc9f28e8a0a7c844ede2e506","modified":1545068659000},{"_id":"themes/snippet/source/css/less/_highlight.less","hash":"c799cfa32c323c33a09569d326786874026fd1ef","modified":1545068661000},{"_id":"themes/snippet/source/css/less/_scrollbar.less","hash":"596ee6ada077f94a05d7c0168dddb20be16b85da","modified":1545068661000},{"_id":"themes/snippet/source/css/less/_mixins.less","hash":"e89dc55772b5ae6bfd4cac3b5c32bf9ce73ac805","modified":1545068661000},{"_id":"themes/snippet/source/css/less/_style.less","hash":"4d6a22be67f4087d73dfce46268e5bf7d41ab3bf","modified":1545068661000},{"_id":"themes/snippet/source/css/less/_timeline.less","hash":"a04b7c50886faa41d3835b487c8d333e855c83de","modified":1545068661000},{"_id":"themes/snippet/source/css/less/_variable.less","hash":"b06c46ac56dbb8cd75ac13310479c643d5087d9b","modified":1545068661000},{"_id":"themes/snippet/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1545068662000},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1545068662000},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1545068662000},{"_id":"source/_posts/charles-android监听websocket/networkdetails.png","hash":"2b072cd11ed4d098a55b459ebe2c5d5ffa07a90b","modified":1547027441368},{"_id":"themes/snippet/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1545068662000},{"_id":"public/content.json","hash":"53171b13e936ddb001cbc76b1f3a85d24f07c470","modified":1547027603893},{"_id":"public/2019/01/09/hello-world/index.html","hash":"82b9978ee0cb0eb862cae72a7c306d9544d16f75","modified":1547027604305},{"_id":"public/2018/11/06/CentOS下编译安装shadowsocks-libev/index.html","hash":"b9e7d82cd9fb359aa6ec98b0cf67f07bf4f5d973","modified":1547027604305},{"_id":"public/2018/08/20/mac使用ssh连接远程服务器并实现文件上传下砸/index.html","hash":"e9765e7acd8f03c4ad7b304e8386b9d341086135","modified":1547027604305},{"_id":"public/2018/08/10/centos7安装mysql/index.html","hash":"81deb491518d6b49ea6138d83f477606b8fbdb36","modified":1547027604305},{"_id":"public/2018/08/07/搭建自己的翻墙服务器/index.html","hash":"e9def351e1c8c004accf5125027640b0ab6a4f05","modified":1547027604305},{"_id":"public/2018/08/02/centos7配置网关/index.html","hash":"c1b262a6454c497c85b2b92e8391065a0f6acca2","modified":1547027604305},{"_id":"public/2018/07/24/前端UI框架/index.html","hash":"7228b9ffa7cc512a938aa9cd98731050b052675e","modified":1547027604305},{"_id":"public/2018/07/24/Python-读取文件/index.html","hash":"b5e4d221c789e3e0c863bbd766f77d29c10f1a9c","modified":1547027604305},{"_id":"public/2018/07/24/charles-android监听websocket/index.html","hash":"30fd576cf82930d14c60d4b47ad152b5066e6bd4","modified":1547027604305},{"_id":"public/2018/07/24/Git-常用命令/index.html","hash":"20852bf41d20a64da0d2360e6f2eb3084e54933e","modified":1547027604305},{"_id":"public/2018/07/24/usr-bin-pip-No-such-file-or-directory/index.html","hash":"76367ef04b411343f8680c3a1c32b5654e61decb","modified":1547027604305},{"_id":"public/2018/07/24/彻底关闭windows-Defender/index.html","hash":"7d4155c8196c1bf300f979b0f7547e130a362d9d","modified":1547027604306},{"_id":"public/2018/07/24/IOS马甲包混淆必过4-3审核上线方法整理/index.html","hash":"9cb9d0f53783f07c8aef74a01ed94b53bc594df3","modified":1547027604306},{"_id":"public/2018/07/24/Dash/index.html","hash":"df8dddf4ab0598b1c0816388425f399d11ac91d5","modified":1547027604306},{"_id":"public/2018/07/24/Alfred/index.html","hash":"f9c8bca0ce2d53159fb13dc888af3dea7dbbe8dc","modified":1547027604306},{"_id":"public/2018/07/23/浏览器翻墙工具/index.html","hash":"3ab1394d5632b8f7e3df4103b367265aa4743f1e","modified":1547027604306},{"_id":"public/2018/07/23/Hexo新建页面显示多个文章/index.html","hash":"3cdac284ab16f593e609bc4ca4ab4fe3f381329f","modified":1547027604306},{"_id":"public/2018/07/20/Markdown/index.html","hash":"fb1a68460147a70a67690908c64b40aba85cc1ba","modified":1547027604306},{"_id":"public/2018/07/20/Python-配置虚拟环境/index.html","hash":"217c0920fc9166e0e5301577d7dc534c688734c3","modified":1547027604306},{"_id":"public/archives/2019/index.html","hash":"9de115b300e8aaad370c6e816fcde08781b800c0","modified":1547027604306},{"_id":"public/archives/2019/01/index.html","hash":"5980a01b26b8b7ca4275fd865cb828a00795436b","modified":1547027604306},{"_id":"public/categories/Git/index.html","hash":"63e1d58b3f5590412d6edd7786efcf83e7172ee7","modified":1547027604306},{"_id":"public/categories/Python/index.html","hash":"edf62b1e263dba3acc048c7ab24145a74f750e71","modified":1547027604306},{"_id":"public/tags/centos/index.html","hash":"1c44c6f6d0fdcd79d7af487f569801525ce049b6","modified":1547027604306},{"_id":"public/tags/shadowsocks-libev/index.html","hash":"47c25dfbe8f925e43f366fb156be172ba68713cf","modified":1547027604306},{"_id":"public/tags/Alfred/index.html","hash":"e7a5b82ace4dc4b027f4126a1e8fb5688fab29b6","modified":1547027604306},{"_id":"public/tags/Dash/index.html","hash":"d6c45940b2ea15e92471f67f6ecdb77da5c736c7","modified":1547027604306},{"_id":"public/tags/Mac/index.html","hash":"a37aa624e3b7b6fa057b19e971ff4b42efc4c57b","modified":1547027604306},{"_id":"public/tags/Hexo/index.html","hash":"b3394f6c84e442b844dbbe0a32736dd46bbbbc6e","modified":1547027604306},{"_id":"public/tags/IOS/index.html","hash":"a718c9032c734a585466fcbc49d2ee5b7db9b0e8","modified":1547027604306},{"_id":"public/tags/审核/index.html","hash":"47b34f9df3e252727c795246f26631cf17172a87","modified":1547027604306},{"_id":"public/tags/Git/index.html","hash":"5973b06ee3cc41d10889c43f063499134d01350a","modified":1547027604307},{"_id":"public/tags/工具/index.html","hash":"074a6c6f7c307a001b2cd9ae2c730f7ad9d44a40","modified":1547027604307},{"_id":"public/tags/443/index.html","hash":"a5dd5d9c847093c7d613f7550e73e6ee65eebe46","modified":1547027604307},{"_id":"public/tags/charles/index.html","hash":"7495ce72f5cd96f02fc83c1d2e9732f483e59e0d","modified":1547027604307},{"_id":"public/tags/后端/index.html","hash":"90d953bb8cd92249e21ab677b3080a6197eea70a","modified":1547027604307},{"_id":"public/tags/android/index.html","hash":"2201870a7fa34464e71bcc5d9409b37357e2bd6b","modified":1547027604307},{"_id":"public/tags/django/index.html","hash":"f3b5029505706beb39a0467328e94d11a4e32f1e","modified":1547027604307},{"_id":"public/tags/windows10/index.html","hash":"3577b3ce588deec6574e660959e42680009b8686","modified":1547027604307},{"_id":"public/tags/windows-defender/index.html","hash":"c311ab6512fac161ab07d646c08fe90f292b0329","modified":1547027604307},{"_id":"public/tags/翻墙/index.html","hash":"13b42ac55e7caa902d98155567250a495a20f9b5","modified":1547027604307},{"_id":"public/tags/securecrt/index.html","hash":"d678bdeeadd665a65cacdcdba0d4419298563e40","modified":1547027604307},{"_id":"public/tags/Chrome/index.html","hash":"e7baf7cbe3f530c69ce40fe6eb9badc9bda07781","modified":1547027604307},{"_id":"public/tags/命令/index.html","hash":"4cac71a50a1f44d36a2a58e2fbd1773f0937a094","modified":1547027604307},{"_id":"public/tags/ansible/index.html","hash":"ddff25b3cfa24ae98d5c13f28d7ddde559e1ee46","modified":1547027604307},{"_id":"public/tags/运维/index.html","hash":"58ff86faac1f73c6c41296afeb1ab35cdc0397e3","modified":1547027604307},{"_id":"public/2018/08/17/django/index.html","hash":"9718a82a0f7f1424fda0b27861891926da757e3e","modified":1547027604307},{"_id":"public/2018/08/03/linux常用命令/index.html","hash":"f7a42bca39683b10d0fd50ab4d8648f318c6dd02","modified":1547027604307},{"_id":"public/2018/07/31/ansible应用/index.html","hash":"7f97d1fd92adf2416fed728a4654fcafc06b1766","modified":1547027604307},{"_id":"public/2018/07/20/Hexo-Blog/index.html","hash":"fb2e829feae8889a2317bf4e7b03e01b78bec84e","modified":1547027604307},{"_id":"public/archives/index.html","hash":"55e0623dffb1459eb1e797b7bff5a04a8f233c61","modified":1547027604307},{"_id":"public/archives/page/2/index.html","hash":"55e0623dffb1459eb1e797b7bff5a04a8f233c61","modified":1547027604307},{"_id":"public/archives/page/3/index.html","hash":"55e0623dffb1459eb1e797b7bff5a04a8f233c61","modified":1547027604308},{"_id":"public/archives/2018/index.html","hash":"62ad2f0577ff549a61e4dd312b7e71f0d51bda76","modified":1547027604308},{"_id":"public/archives/2018/page/2/index.html","hash":"62ad2f0577ff549a61e4dd312b7e71f0d51bda76","modified":1547027604308},{"_id":"public/archives/2018/page/3/index.html","hash":"62ad2f0577ff549a61e4dd312b7e71f0d51bda76","modified":1547027604308},{"_id":"public/archives/2018/07/index.html","hash":"b0bd2835914e098d3285e1c8a5c9e3d063fc5563","modified":1547027604308},{"_id":"public/archives/2018/07/page/2/index.html","hash":"b0bd2835914e098d3285e1c8a5c9e3d063fc5563","modified":1547027604308},{"_id":"public/archives/2018/08/index.html","hash":"1bef40cac1a6bc4c7ce3c019c569aea9754cc3f9","modified":1547027604308},{"_id":"public/archives/2018/11/index.html","hash":"5febcfd70398870b9cddf1eec0d9c15b29d291f5","modified":1547027604308},{"_id":"public/categories/后端/index.html","hash":"0766df038766fd4f112775c00a6352187aa3b750","modified":1547027604308},{"_id":"public/categories/工具/index.html","hash":"d0faa4ccabf391afa45f8ef64807d2506fbe2fcd","modified":1547027604308},{"_id":"public/categories/前端/index.html","hash":"35515b33c72241e4fd3d0579c234387661440b55","modified":1547027604308},{"_id":"public/index.html","hash":"92753aa9a74f0355bc834b2669e5741526b0ce9c","modified":1547027604308},{"_id":"public/page/2/index.html","hash":"def79699bfa8f126224c23879afd3bb431f1f34b","modified":1547027604308},{"_id":"public/page/3/index.html","hash":"6b8a95c08dd20e95bdf6b304704bd47c88752be1","modified":1547027604308},{"_id":"public/tags/前端/index.html","hash":"05f66d2e311097ad841585025753dd56b417e807","modified":1547027604308},{"_id":"public/tags/Python/index.html","hash":"0e3079031878b3b6f2b17c015eb29f78feaf6c27","modified":1547027604308},{"_id":"public/tags/linux/index.html","hash":"042bad790c0731eb6ca34c4cf75e794356983ccc","modified":1547027604308},{"_id":"public/favicon.ico","hash":"322f434396e8d2fbb9f540b5af16cd17e400e7f8","modified":1547027604330},{"_id":"public/favicon1.ico","hash":"65f26147ea3433ffd64d3f18bf281af48dc5d06e","modified":1547027604330},{"_id":"public/favicon2.ico","hash":"3ff8f701a0c74b9f3ef7f3eb4c839df678f54917","modified":1547027604330},{"_id":"public/img/avatar1.jpg","hash":"512025710a8c6c938ab636fcb3c9da1c8df0eec0","modified":1547027604330},{"_id":"public/img/branding.png","hash":"18bee49d6a4c521ad230047c0b416245e009c2c9","modified":1547027604330},{"_id":"public/img/head-img.jpg","hash":"a318d304665c2f410f79e6d2eb1b98119f675b4b","modified":1547027604330},{"_id":"public/img/timeline-clock.gif","hash":"e1f3e1061a38e9dcaa26963ab809ba0a70bb8221","modified":1547027604330},{"_id":"public/img/timeline-dot.gif","hash":"c85ef87be5b631c009e7c5737d33b61dfe580a4d","modified":1547027604330},{"_id":"public/img/avatar.jpg","hash":"0ac7fd55965516636360e33372c870f386a50682","modified":1547027604330},{"_id":"public/img/timeline.gif","hash":"b7c7aac44e618df19626d882dc46db48a4aa3673","modified":1547027604330},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1547027604336},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1547027604336},{"_id":"public/img/loading.gif","hash":"6cea4dc953ac09fb744c7fedc12a1f4736faf8ec","modified":1547027604337},{"_id":"public/js/app.js","hash":"eca509fc5b45dcd1a0007c62f740529ca31a122f","modified":1547027604339},{"_id":"public/js/search.js","hash":"a6c7ac73821e5c7db7d4ae6de2d00f44367a858e","modified":1547027604339},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1547027604339},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1547027604339},{"_id":"public/assets/highlight.pack.js","hash":"f39840759ec9afe56ec1ca30579d1f1c9d1f6026","modified":1547027604340},{"_id":"public/css/font-awesome.min.css","hash":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1547027604344},{"_id":"public/css/style.css","hash":"d5c8ad0fbf7634f66cbb945a6b1206e07ff54bf3","modified":1547027604344},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1547027604344},{"_id":"public/assets/valine.min.js","hash":"bf7099fa607a93068dd01f109eaa2cd18663b946","modified":1547027604359},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1547027604365},{"_id":"public/css/bootstrap.min.css","hash":"6527d8bf3e1e9368bab8c7b60f56bc01fa3afd68","modified":1547027604367}],"Category":[{"name":"后端","_id":"cjqp0aii80002y0w0ob1gzb6x"},{"name":"工具","_id":"cjqp0aiic0007y0w0z2jps1tb"},{"name":"前端","_id":"cjqp0aiii000iy0w0puv7rvhb"},{"name":"Git","_id":"cjqp0aiis0010y0w09mkegiel"},{"name":"Python","_id":"cjqp0aiiu0019y0w0auccpey0"}],"Data":[],"Page":[],"Post":[{"title":"CentOS下编译安装shadowsocks-libev","comments":1,"date":"2018-11-06T09:25:45.000Z","_content":"####  安装\n\n- 编译环境准备&安装依赖包\n\n> yum install -y gcc automake autoconf libtool make build-essential autoconf libtool  asciidoc xmlto libsodium libev-devel  udns-devel\n  yum install -y curl curl-devel unzip zlib-devel openssl-devel perl perl-devel cpio expat-devel gettext-devel\n- 下载源码\n\n> git clone https://github.com/shadowsocks/shadowsocks-libev.git\n\n- 开始编译\n\n> cd shadowsocks-libev\n  ./autogen.sh\n  ./configure --prefix=/usr && make\n  make install\n  \n- 准备必须的文件\n\n> mkdir -p /etc/shadowsocks-libev\n  cp ./debian/shadowsocks-libev.init /etc/init.d/shadowsocks-libev\n  cp ./debian/shadowsocks-libev.default /etc/default/shadowsocks-libev\n  cp ./debian/shadowsocks-libev.service /lib/systemd/system/\n  cp ./debian/config.json /etc/shadowsocks-libev/config.json\n  chmod +x /etc/init.d/shadowsocks-libev\n  \n- 编辑配置文件\n    \n> vim /etc/shadowsocks-libev/config.json\n\n- 启动服务\n\n> service shadowsocks-libev start\n\n#### FAQ\n\n- 如果执行./autogen.sh时出现下列错误：\n\n> configure.ac:309: error: required file 'libcork/Makefile.in' not found\n  configure.ac:309: error: required file 'libipset/Makefile.in' not found\n\n请初始化git库\n\n> git submodule init && git submodule update\n\n- 如果执行./configure –prefix=/usr出现下列错误\n\n> configure: error: mbed TLS libraries not found.\n\n请安装TLS开发包\n\n> yum install -y mbedtls-devel\n\n若提示：没有可用软件包 mbedtls-devel。\n请执行以下命令再重新安装：\n\n> yum install epel-release\n  yum update\n  yum install mbedtls-devel\n\n","source":"_posts/CentOS下编译安装shadowsocks-libev.md","raw":"---\ntitle: CentOS下编译安装shadowsocks-libev\ntags:\n  - centos\n  - shadowsocks-libev\ncategories:\n  - 后端\ncomments: false    // 是否开启评论\ndate: 2018-11-06 17:25:45\n---\n####  安装\n\n- 编译环境准备&安装依赖包\n\n> yum install -y gcc automake autoconf libtool make build-essential autoconf libtool  asciidoc xmlto libsodium libev-devel  udns-devel\n  yum install -y curl curl-devel unzip zlib-devel openssl-devel perl perl-devel cpio expat-devel gettext-devel\n- 下载源码\n\n> git clone https://github.com/shadowsocks/shadowsocks-libev.git\n\n- 开始编译\n\n> cd shadowsocks-libev\n  ./autogen.sh\n  ./configure --prefix=/usr && make\n  make install\n  \n- 准备必须的文件\n\n> mkdir -p /etc/shadowsocks-libev\n  cp ./debian/shadowsocks-libev.init /etc/init.d/shadowsocks-libev\n  cp ./debian/shadowsocks-libev.default /etc/default/shadowsocks-libev\n  cp ./debian/shadowsocks-libev.service /lib/systemd/system/\n  cp ./debian/config.json /etc/shadowsocks-libev/config.json\n  chmod +x /etc/init.d/shadowsocks-libev\n  \n- 编辑配置文件\n    \n> vim /etc/shadowsocks-libev/config.json\n\n- 启动服务\n\n> service shadowsocks-libev start\n\n#### FAQ\n\n- 如果执行./autogen.sh时出现下列错误：\n\n> configure.ac:309: error: required file 'libcork/Makefile.in' not found\n  configure.ac:309: error: required file 'libipset/Makefile.in' not found\n\n请初始化git库\n\n> git submodule init && git submodule update\n\n- 如果执行./configure –prefix=/usr出现下列错误\n\n> configure: error: mbed TLS libraries not found.\n\n请安装TLS开发包\n\n> yum install -y mbedtls-devel\n\n若提示：没有可用软件包 mbedtls-devel。\n请执行以下命令再重新安装：\n\n> yum install epel-release\n  yum update\n  yum install mbedtls-devel\n\n","slug":"CentOS下编译安装shadowsocks-libev","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aihx0000y0w0fpqkdaqh","content":"<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ul>\n<li>编译环境准备&amp;安装依赖包</li>\n</ul>\n<blockquote>\n<p>yum install -y gcc automake autoconf libtool make build-essential autoconf libtool  asciidoc xmlto libsodium libev-devel  udns-devel<br>  yum install -y curl curl-devel unzip zlib-devel openssl-devel perl perl-devel cpio expat-devel gettext-devel</p>\n<ul>\n<li>下载源码</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>git clone <a href=\"https://github.com/shadowsocks/shadowsocks-libev.git\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks-libev.git</a></p>\n</blockquote>\n<ul>\n<li>开始编译</li>\n</ul>\n<blockquote>\n<p>cd shadowsocks-libev<br>  ./autogen.sh<br>  ./configure –prefix=/usr &amp;&amp; make<br>  make install</p>\n</blockquote>\n<ul>\n<li>准备必须的文件</li>\n</ul>\n<blockquote>\n<p>mkdir -p /etc/shadowsocks-libev<br>  cp ./debian/shadowsocks-libev.init /etc/init.d/shadowsocks-libev<br>  cp ./debian/shadowsocks-libev.default /etc/default/shadowsocks-libev<br>  cp ./debian/shadowsocks-libev.service /lib/systemd/system/<br>  cp ./debian/config.json /etc/shadowsocks-libev/config.json<br>  chmod +x /etc/init.d/shadowsocks-libev</p>\n</blockquote>\n<ul>\n<li>编辑配置文件</li>\n</ul>\n<blockquote>\n<p>vim /etc/shadowsocks-libev/config.json</p>\n</blockquote>\n<ul>\n<li>启动服务</li>\n</ul>\n<blockquote>\n<p>service shadowsocks-libev start</p>\n</blockquote>\n<h4 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h4><ul>\n<li>如果执行./autogen.sh时出现下列错误：</li>\n</ul>\n<blockquote>\n<p>configure.ac:309: error: required file ‘libcork/Makefile.in’ not found<br>  configure.ac:309: error: required file ‘libipset/Makefile.in’ not found</p>\n</blockquote>\n<p>请初始化git库</p>\n<blockquote>\n<p>git submodule init &amp;&amp; git submodule update</p>\n</blockquote>\n<ul>\n<li>如果执行./configure –prefix=/usr出现下列错误</li>\n</ul>\n<blockquote>\n<p>configure: error: mbed TLS libraries not found.</p>\n</blockquote>\n<p>请安装TLS开发包</p>\n<blockquote>\n<p>yum install -y mbedtls-devel</p>\n</blockquote>\n<p>若提示：没有可用软件包 mbedtls-devel。<br>请执行以下命令再重新安装：</p>\n<blockquote>\n<p>yum install epel-release<br>  yum update<br>  yum install mbedtls-devel</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><ul>\n<li>编译环境准备&amp;安装依赖包</li>\n</ul>\n<blockquote>\n<p>yum install -y gcc automake autoconf libtool make build-essential autoconf libtool  asciidoc xmlto libsodium libev-devel  udns-devel<br>  yum install -y curl curl-devel unzip zlib-devel openssl-devel perl perl-devel cpio expat-devel gettext-devel</p>\n<ul>\n<li>下载源码</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>git clone <a href=\"https://github.com/shadowsocks/shadowsocks-libev.git\" target=\"_blank\" rel=\"noopener\">https://github.com/shadowsocks/shadowsocks-libev.git</a></p>\n</blockquote>\n<ul>\n<li>开始编译</li>\n</ul>\n<blockquote>\n<p>cd shadowsocks-libev<br>  ./autogen.sh<br>  ./configure –prefix=/usr &amp;&amp; make<br>  make install</p>\n</blockquote>\n<ul>\n<li>准备必须的文件</li>\n</ul>\n<blockquote>\n<p>mkdir -p /etc/shadowsocks-libev<br>  cp ./debian/shadowsocks-libev.init /etc/init.d/shadowsocks-libev<br>  cp ./debian/shadowsocks-libev.default /etc/default/shadowsocks-libev<br>  cp ./debian/shadowsocks-libev.service /lib/systemd/system/<br>  cp ./debian/config.json /etc/shadowsocks-libev/config.json<br>  chmod +x /etc/init.d/shadowsocks-libev</p>\n</blockquote>\n<ul>\n<li>编辑配置文件</li>\n</ul>\n<blockquote>\n<p>vim /etc/shadowsocks-libev/config.json</p>\n</blockquote>\n<ul>\n<li>启动服务</li>\n</ul>\n<blockquote>\n<p>service shadowsocks-libev start</p>\n</blockquote>\n<h4 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h4><ul>\n<li>如果执行./autogen.sh时出现下列错误：</li>\n</ul>\n<blockquote>\n<p>configure.ac:309: error: required file ‘libcork/Makefile.in’ not found<br>  configure.ac:309: error: required file ‘libipset/Makefile.in’ not found</p>\n</blockquote>\n<p>请初始化git库</p>\n<blockquote>\n<p>git submodule init &amp;&amp; git submodule update</p>\n</blockquote>\n<ul>\n<li>如果执行./configure –prefix=/usr出现下列错误</li>\n</ul>\n<blockquote>\n<p>configure: error: mbed TLS libraries not found.</p>\n</blockquote>\n<p>请安装TLS开发包</p>\n<blockquote>\n<p>yum install -y mbedtls-devel</p>\n</blockquote>\n<p>若提示：没有可用软件包 mbedtls-devel。<br>请执行以下命令再重新安装：</p>\n<blockquote>\n<p>yum install epel-release<br>  yum update<br>  yum install mbedtls-devel</p>\n</blockquote>\n"},{"title":"Alfred","comments":1,"date":"2018-07-24T07:11:48.000Z","_content":"\n### 简介\nMac下高效率启动工具\n\n### 下载地址\n\n[Alfred+3+for+Mac+3.3.2.dmg](https://pan.baidu.com/s/1gjiLPatZrXEiZOF7NLsG4g)\n解压密码为www.ifunmac.com\n","source":"_posts/Alfred.md","raw":"---\ntitle: Alfred\ntags:\n  - Alfred\ncategories:\n  - 工具\ncomments: false    // 是否开启评论\ndate: 2018-07-24 15:11:48\n---\n\n### 简介\nMac下高效率启动工具\n\n### 下载地址\n\n[Alfred+3+for+Mac+3.3.2.dmg](https://pan.baidu.com/s/1gjiLPatZrXEiZOF7NLsG4g)\n解压密码为www.ifunmac.com\n","slug":"Alfred","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aii60001y0w01l8lx81z","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Mac下高效率启动工具</p>\n<h3 id=\"下载地址\"><a href=\"#下载地址\" class=\"headerlink\" title=\"下载地址\"></a>下载地址</h3><p><a href=\"https://pan.baidu.com/s/1gjiLPatZrXEiZOF7NLsG4g\" target=\"_blank\" rel=\"noopener\">Alfred+3+for+Mac+3.3.2.dmg</a><br>解压密码为<a href=\"http://www.ifunmac.com\" target=\"_blank\" rel=\"noopener\">www.ifunmac.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Mac下高效率启动工具</p>\n<h3 id=\"下载地址\"><a href=\"#下载地址\" class=\"headerlink\" title=\"下载地址\"></a>下载地址</h3><p><a href=\"https://pan.baidu.com/s/1gjiLPatZrXEiZOF7NLsG4g\" target=\"_blank\" rel=\"noopener\">Alfred+3+for+Mac+3.3.2.dmg</a><br>解压密码为<a href=\"http://www.ifunmac.com\" target=\"_blank\" rel=\"noopener\">www.ifunmac.com</a></p>\n"},{"title":"Dash","comments":1,"date":"2018-07-24T07:19:36.000Z","_content":"\nMac下文档搜索工具\n\n下载地址：\n\n[Dash+4+for+Mac+4.0.3.dmg](https://pan.baidu.com/s/1J5h_HJXtSkqgQnIjstkvyA)\n\n提取密码：\n\nsndc\n\n解压密码:\n\nwww.ifunmac.com\n","source":"_posts/Dash.md","raw":"---\ntitle: Dash\ntags:\n  - Dash\n  - Mac\ncategories:\n  - 工具\ncomments: false    // 是否开启评论\ndate: 2018-07-24 15:19:36\n---\n\nMac下文档搜索工具\n\n下载地址：\n\n[Dash+4+for+Mac+4.0.3.dmg](https://pan.baidu.com/s/1J5h_HJXtSkqgQnIjstkvyA)\n\n提取密码：\n\nsndc\n\n解压密码:\n\nwww.ifunmac.com\n","slug":"Dash","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiia0004y0w0c6amnm80","content":"<p>Mac下文档搜索工具</p>\n<p>下载地址：</p>\n<p><a href=\"https://pan.baidu.com/s/1J5h_HJXtSkqgQnIjstkvyA\" target=\"_blank\" rel=\"noopener\">Dash+4+for+Mac+4.0.3.dmg</a></p>\n<p>提取密码：</p>\n<p>sndc</p>\n<p>解压密码:</p>\n<p><a href=\"http://www.ifunmac.com\" target=\"_blank\" rel=\"noopener\">www.ifunmac.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Mac下文档搜索工具</p>\n<p>下载地址：</p>\n<p><a href=\"https://pan.baidu.com/s/1J5h_HJXtSkqgQnIjstkvyA\" target=\"_blank\" rel=\"noopener\">Dash+4+for+Mac+4.0.3.dmg</a></p>\n<p>提取密码：</p>\n<p>sndc</p>\n<p>解压密码:</p>\n<p><a href=\"http://www.ifunmac.com\" target=\"_blank\" rel=\"noopener\">www.ifunmac.com</a></p>\n"},{"layout":"fore-end","title":"利用Hexo搭建自己的博客","comments":1,"date":"2018-07-20T12:47:03.000Z","_content":"\n## 原理\n        GitHub会为每一个注册用户分配一个300M的个人空间，所以和hexo结合起来，利用github给我们的免费空间，\n        将我们的静态网页托管到上面，就实现了一个免费的搭建个人博客的方案。\n## 主要设计名词\n\n- Git\n- Hexo\n- Node.js\n- npm\n- Markdown\n- VS Code  \n## 主要步骤\n### 注册GitHub帐号，新建代码仓库\n1. 登录GitHub网站，注册一个帐号\n2. 新建一个代码仓库\n3. 填写仓库信息，其中仓库名称必须和用户名一样\n\n### 环境配置\n1. 安装git。由于我使用的是MAC OS系统，自带了git功能，如果是其他系统，安装一个git客户端软件即可\n2. 安装Node环境，Hexo就是基于Node的，访问速度特别快。进入node.js官网，选对操作系统，安装即可\n\n### 安装Hexo，初始化博客\n\ngit和node环境安装好了以后。接下来就可以安装hexo了，直接在命令行中敲入如下代码：\n\n    npm install -g hexo-cli\n    \n接下来建站\n\n    hexo init <folder>  # 初始化博客，<文件夹名称>，表示文件会下载到当前目录下的这个文件夹内\n    cd <folder>         # 进入到这个文件夹目录\n    npm install         # 安装npm\n使用相关编辑器打开这个文件夹<folder>中的文件夹，我是用的是[VS Code](https://code.visualstudio.com/)\n### 本地预览\n\n    hexo server # 开启本地服务器\n然后在浏览器里面输入网址http://localhost:4000，就能看到默认主题的界面\n\n*这是因为初始化hexo的时候就已经把一个能够起小型的网路服务器功能的依赖装好了，所以启动一下这个本地服务，就能看到hexo的默认主题*\n\n### 上传到远程代码仓库\n接下来就要将本地的代码上传到远程github仓库。首先建立和之前新建的代码仓库之间的关联，利用ssh key，具体是先用命令行在本地生成一个ssh key，\n然后复制到github上去。\n\n一. 先检查本地有没存在ssh key\n\n    ls -al ~/.ssh  # 列出在.ssh文件夹下所有的文件，如果存在这个文件夹或者这些文件的话\n二. 生成新的ssh key\n\n    ssh-keygen -t rsa -C \"your_email@example.com\" # 注意将`your_email`替换成之前注册github帐号时的邮箱\n\n生成成功或已经存在的，进入到~/.ssh/路径下，用文件编辑器打开文件，里面的内容就是ssk key，将内容复制到剪切板\n1. 登录GitHub网站,依次点击Settings –> SSH and GPG keys –> New SSH key，进入新建SSK key页面，随便填写一下Title,然后将剪切板中复制好的ssh key复制到key中去，最后点击Add SSH key按钮，就OK了\n2. 用VSCode打开博客主目录，找到主目录在的_config.yml文件，编辑这个文件，找到最下方deployment模块（顺便找到Site模块，修改一下博客的titile，subtitle，author，\n改成你自己个性化的\n   ），将deployment模块里面的代码替换为如下：\n   \n        deploy:\n          type: git\n            repository: https://github.com/用户名/用户名.github.io.git # 将用户名替换为你自己的github用户名\n            branch: master\n\n特别提醒：每个分号:后都要有一个空格，不然接下来生成和部署博客到github上时会报下面这种错误：\n\n        JS-YAML: bad indentation of a mapping entry at line , column\n三. 进到博客根目录下，先执行\n\n    hexo generate       # 或者：hexo g  生成静态页面至public目录\n    \n如出现报错\n\n    ERROR Local hexo not found in ~/blog\n    ERROR Try runing: 'npm install hexo --save'\n则执行：    \n    \n    npm install hexo --save\n再执行：\n\n    hexo deploy  # 或者：hexo -g   将.deploy目录部署到GitHub\n如果无法连接到git,则执行：\n\n    npm install hexo-deployer-git --save  # 安装hexo-deployer-git\n最后再执行：\n\n    hexo g\n    hexo d\n\n四. 进到浏览器，打开http://用户名.github.io网址，就可以看到和之前本地看到的hexo默认主题的首页，\n看到你修改好的博客title，subtitle，author，等。至此，和github的关联已经建立好，接下来就可以写博客了\n\n### 写博客\n写博客主要使用到几个命令：\n\n    hexo new \"postName\" # 新建文章 默认在\\source\\_posts\\postName.md文件夹下\n    hexo new page \"pageName\" #新建页面，如关于我界面\n新建后，在source文件目录下生成一个以postName命名的.md文件，直接用markdown语法编辑，写文章就是这么简单。\nhexo可以将markdown语法的文件渲染成静态的HTML。关于markdown语法，非常简单，上手很快，可以上网去搜一下语法\n[Markdown 语法说明 (简体中文版)](http://wowubuntu.com/markdown/)\n\n    hexo clean # 删除之前生成的public文件夹和缓存数据\n    hexo g     # 重新生成博客文件\n    hexo d     # 将修改同步到github远程仓库\n    \n### 换主题，个性化配置\n1. 更换主题\n进入hexo相关主题展示的theme网站,选取一款你喜欢的主题。将你喜欢的主题clone到themes文件夹下，我选的是jacman主题，\n直接编辑主目录下的_config.yml配置文件，找到theme,将默认的主题换成你喜欢的主题名即可\n2. 配置主题样式\n换完主题后，就可以修改主题样式了，主要修改主配置文件_config.yml以及主题文件下的配置文件_config.yml。\n3. 添加第三方评论系统\n\n使用[disqus](https://disqus.com/),直接注册，然后获取到duoshuo_shortname，填到jacman主题下面配置文件_config.yml对应的地方，第三方评论系统就安装好了\n\n\n### 参考文章\n\n[利用 GitHub Pages 快速搭建个人博客](https://www.jianshu.com/p/e68fba58f75c)\n[我的个人技术博客搭建之旅](http://chenliangjing.me/2016/05/01/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/)\n","source":"_posts/Hexo-Blog.md","raw":"---\nlayout: fore-end\ntitle: 利用Hexo搭建自己的博客\ntags:\n  - 前端\ncategories: 前端\ncomments: false    // 是否开启评论\ndate: 2018-07-20 20:47:03\n---\n\n## 原理\n        GitHub会为每一个注册用户分配一个300M的个人空间，所以和hexo结合起来，利用github给我们的免费空间，\n        将我们的静态网页托管到上面，就实现了一个免费的搭建个人博客的方案。\n## 主要设计名词\n\n- Git\n- Hexo\n- Node.js\n- npm\n- Markdown\n- VS Code  \n## 主要步骤\n### 注册GitHub帐号，新建代码仓库\n1. 登录GitHub网站，注册一个帐号\n2. 新建一个代码仓库\n3. 填写仓库信息，其中仓库名称必须和用户名一样\n\n### 环境配置\n1. 安装git。由于我使用的是MAC OS系统，自带了git功能，如果是其他系统，安装一个git客户端软件即可\n2. 安装Node环境，Hexo就是基于Node的，访问速度特别快。进入node.js官网，选对操作系统，安装即可\n\n### 安装Hexo，初始化博客\n\ngit和node环境安装好了以后。接下来就可以安装hexo了，直接在命令行中敲入如下代码：\n\n    npm install -g hexo-cli\n    \n接下来建站\n\n    hexo init <folder>  # 初始化博客，<文件夹名称>，表示文件会下载到当前目录下的这个文件夹内\n    cd <folder>         # 进入到这个文件夹目录\n    npm install         # 安装npm\n使用相关编辑器打开这个文件夹<folder>中的文件夹，我是用的是[VS Code](https://code.visualstudio.com/)\n### 本地预览\n\n    hexo server # 开启本地服务器\n然后在浏览器里面输入网址http://localhost:4000，就能看到默认主题的界面\n\n*这是因为初始化hexo的时候就已经把一个能够起小型的网路服务器功能的依赖装好了，所以启动一下这个本地服务，就能看到hexo的默认主题*\n\n### 上传到远程代码仓库\n接下来就要将本地的代码上传到远程github仓库。首先建立和之前新建的代码仓库之间的关联，利用ssh key，具体是先用命令行在本地生成一个ssh key，\n然后复制到github上去。\n\n一. 先检查本地有没存在ssh key\n\n    ls -al ~/.ssh  # 列出在.ssh文件夹下所有的文件，如果存在这个文件夹或者这些文件的话\n二. 生成新的ssh key\n\n    ssh-keygen -t rsa -C \"your_email@example.com\" # 注意将`your_email`替换成之前注册github帐号时的邮箱\n\n生成成功或已经存在的，进入到~/.ssh/路径下，用文件编辑器打开文件，里面的内容就是ssk key，将内容复制到剪切板\n1. 登录GitHub网站,依次点击Settings –> SSH and GPG keys –> New SSH key，进入新建SSK key页面，随便填写一下Title,然后将剪切板中复制好的ssh key复制到key中去，最后点击Add SSH key按钮，就OK了\n2. 用VSCode打开博客主目录，找到主目录在的_config.yml文件，编辑这个文件，找到最下方deployment模块（顺便找到Site模块，修改一下博客的titile，subtitle，author，\n改成你自己个性化的\n   ），将deployment模块里面的代码替换为如下：\n   \n        deploy:\n          type: git\n            repository: https://github.com/用户名/用户名.github.io.git # 将用户名替换为你自己的github用户名\n            branch: master\n\n特别提醒：每个分号:后都要有一个空格，不然接下来生成和部署博客到github上时会报下面这种错误：\n\n        JS-YAML: bad indentation of a mapping entry at line , column\n三. 进到博客根目录下，先执行\n\n    hexo generate       # 或者：hexo g  生成静态页面至public目录\n    \n如出现报错\n\n    ERROR Local hexo not found in ~/blog\n    ERROR Try runing: 'npm install hexo --save'\n则执行：    \n    \n    npm install hexo --save\n再执行：\n\n    hexo deploy  # 或者：hexo -g   将.deploy目录部署到GitHub\n如果无法连接到git,则执行：\n\n    npm install hexo-deployer-git --save  # 安装hexo-deployer-git\n最后再执行：\n\n    hexo g\n    hexo d\n\n四. 进到浏览器，打开http://用户名.github.io网址，就可以看到和之前本地看到的hexo默认主题的首页，\n看到你修改好的博客title，subtitle，author，等。至此，和github的关联已经建立好，接下来就可以写博客了\n\n### 写博客\n写博客主要使用到几个命令：\n\n    hexo new \"postName\" # 新建文章 默认在\\source\\_posts\\postName.md文件夹下\n    hexo new page \"pageName\" #新建页面，如关于我界面\n新建后，在source文件目录下生成一个以postName命名的.md文件，直接用markdown语法编辑，写文章就是这么简单。\nhexo可以将markdown语法的文件渲染成静态的HTML。关于markdown语法，非常简单，上手很快，可以上网去搜一下语法\n[Markdown 语法说明 (简体中文版)](http://wowubuntu.com/markdown/)\n\n    hexo clean # 删除之前生成的public文件夹和缓存数据\n    hexo g     # 重新生成博客文件\n    hexo d     # 将修改同步到github远程仓库\n    \n### 换主题，个性化配置\n1. 更换主题\n进入hexo相关主题展示的theme网站,选取一款你喜欢的主题。将你喜欢的主题clone到themes文件夹下，我选的是jacman主题，\n直接编辑主目录下的_config.yml配置文件，找到theme,将默认的主题换成你喜欢的主题名即可\n2. 配置主题样式\n换完主题后，就可以修改主题样式了，主要修改主配置文件_config.yml以及主题文件下的配置文件_config.yml。\n3. 添加第三方评论系统\n\n使用[disqus](https://disqus.com/),直接注册，然后获取到duoshuo_shortname，填到jacman主题下面配置文件_config.yml对应的地方，第三方评论系统就安装好了\n\n\n### 参考文章\n\n[利用 GitHub Pages 快速搭建个人博客](https://www.jianshu.com/p/e68fba58f75c)\n[我的个人技术博客搭建之旅](http://chenliangjing.me/2016/05/01/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/)\n","slug":"Hexo-Blog","published":1,"updated":"2019-01-09T09:50:41.368Z","photos":[],"link":"","_id":"cjqp0aiib0005y0w0wof7ma8m","content":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><pre><code>GitHub会为每一个注册用户分配一个300M的个人空间，所以和hexo结合起来，利用github给我们的免费空间，\n将我们的静态网页托管到上面，就实现了一个免费的搭建个人博客的方案。\n</code></pre><h2 id=\"主要设计名词\"><a href=\"#主要设计名词\" class=\"headerlink\" title=\"主要设计名词\"></a>主要设计名词</h2><ul>\n<li>Git</li>\n<li>Hexo</li>\n<li>Node.js</li>\n<li>npm</li>\n<li>Markdown</li>\n<li>VS Code  <h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><h3 id=\"注册GitHub帐号，新建代码仓库\"><a href=\"#注册GitHub帐号，新建代码仓库\" class=\"headerlink\" title=\"注册GitHub帐号，新建代码仓库\"></a>注册GitHub帐号，新建代码仓库</h3></li>\n</ul>\n<ol>\n<li>登录GitHub网站，注册一个帐号</li>\n<li>新建一个代码仓库</li>\n<li>填写仓库信息，其中仓库名称必须和用户名一样</li>\n</ol>\n<h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><ol>\n<li>安装git。由于我使用的是MAC OS系统，自带了git功能，如果是其他系统，安装一个git客户端软件即可</li>\n<li>安装Node环境，Hexo就是基于Node的，访问速度特别快。进入node.js官网，选对操作系统，安装即可</li>\n</ol>\n<h3 id=\"安装Hexo，初始化博客\"><a href=\"#安装Hexo，初始化博客\" class=\"headerlink\" title=\"安装Hexo，初始化博客\"></a>安装Hexo，初始化博客</h3><p>git和node环境安装好了以后。接下来就可以安装hexo了，直接在命令行中敲入如下代码：</p>\n<pre><code>npm install -g hexo-cli\n</code></pre><p>接下来建站</p>\n<pre><code>hexo init &lt;folder&gt;  # 初始化博客，&lt;文件夹名称&gt;，表示文件会下载到当前目录下的这个文件夹内\ncd &lt;folder&gt;         # 进入到这个文件夹目录\nnpm install         # 安装npm\n</code></pre><p>使用相关编辑器打开这个文件夹<folder>中的文件夹，我是用的是<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">VS Code</a></folder></p>\n<h3 id=\"本地预览\"><a href=\"#本地预览\" class=\"headerlink\" title=\"本地预览\"></a>本地预览</h3><pre><code>hexo server # 开启本地服务器\n</code></pre><p>然后在浏览器里面输入网址<a href=\"http://localhost:4000，就能看到默认主题的界面\" target=\"_blank\" rel=\"noopener\">http://localhost:4000，就能看到默认主题的界面</a></p>\n<p><em>这是因为初始化hexo的时候就已经把一个能够起小型的网路服务器功能的依赖装好了，所以启动一下这个本地服务，就能看到hexo的默认主题</em></p>\n<h3 id=\"上传到远程代码仓库\"><a href=\"#上传到远程代码仓库\" class=\"headerlink\" title=\"上传到远程代码仓库\"></a>上传到远程代码仓库</h3><p>接下来就要将本地的代码上传到远程github仓库。首先建立和之前新建的代码仓库之间的关联，利用ssh key，具体是先用命令行在本地生成一个ssh key，<br>然后复制到github上去。</p>\n<p>一. 先检查本地有没存在ssh key</p>\n<pre><code>ls -al ~/.ssh  # 列出在.ssh文件夹下所有的文件，如果存在这个文件夹或者这些文件的话\n</code></pre><p>二. 生成新的ssh key</p>\n<pre><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot; # 注意将`your_email`替换成之前注册github帐号时的邮箱\n</code></pre><p>生成成功或已经存在的，进入到~/.ssh/路径下，用文件编辑器打开文件，里面的内容就是ssk key，将内容复制到剪切板</p>\n<ol>\n<li>登录GitHub网站,依次点击Settings –&gt; SSH and GPG keys –&gt; New SSH key，进入新建SSK key页面，随便填写一下Title,然后将剪切板中复制好的ssh key复制到key中去，最后点击Add SSH key按钮，就OK了</li>\n<li><p>用VSCode打开博客主目录，找到主目录在的_config.yml文件，编辑这个文件，找到最下方deployment模块（顺便找到Site模块，修改一下博客的titile，subtitle，author，<br>改成你自己个性化的<br>），将deployment模块里面的代码替换为如下：</p>\n<pre><code>deploy:\n  type: git\n    repository: https://github.com/用户名/用户名.github.io.git # 将用户名替换为你自己的github用户名\n    branch: master\n</code></pre></li>\n</ol>\n<p>特别提醒：每个分号:后都要有一个空格，不然接下来生成和部署博客到github上时会报下面这种错误：</p>\n<pre><code>JS-YAML: bad indentation of a mapping entry at line , column\n</code></pre><p>三. 进到博客根目录下，先执行</p>\n<pre><code>hexo generate       # 或者：hexo g  生成静态页面至public目录\n</code></pre><p>如出现报错</p>\n<pre><code>ERROR Local hexo not found in ~/blog\nERROR Try runing: &apos;npm install hexo --save&apos;\n</code></pre><p>则执行：    </p>\n<pre><code>npm install hexo --save\n</code></pre><p>再执行：</p>\n<pre><code>hexo deploy  # 或者：hexo -g   将.deploy目录部署到GitHub\n</code></pre><p>如果无法连接到git,则执行：</p>\n<pre><code>npm install hexo-deployer-git --save  # 安装hexo-deployer-git\n</code></pre><p>最后再执行：</p>\n<pre><code>hexo g\nhexo d\n</code></pre><p>四. 进到浏览器，打开http://用户名.github.io网址，就可以看到和之前本地看到的hexo默认主题的首页，<br>看到你修改好的博客title，subtitle，author，等。至此，和github的关联已经建立好，接下来就可以写博客了</p>\n<h3 id=\"写博客\"><a href=\"#写博客\" class=\"headerlink\" title=\"写博客\"></a>写博客</h3><p>写博客主要使用到几个命令：</p>\n<pre><code>hexo new &quot;postName&quot; # 新建文章 默认在\\source\\_posts\\postName.md文件夹下\nhexo new page &quot;pageName&quot; #新建页面，如关于我界面\n</code></pre><p>新建后，在source文件目录下生成一个以postName命名的.md文件，直接用markdown语法编辑，写文章就是这么简单。<br>hexo可以将markdown语法的文件渲染成静态的HTML。关于markdown语法，非常简单，上手很快，可以上网去搜一下语法<br><a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown 语法说明 (简体中文版)</a></p>\n<pre><code>hexo clean # 删除之前生成的public文件夹和缓存数据\nhexo g     # 重新生成博客文件\nhexo d     # 将修改同步到github远程仓库\n</code></pre><h3 id=\"换主题，个性化配置\"><a href=\"#换主题，个性化配置\" class=\"headerlink\" title=\"换主题，个性化配置\"></a>换主题，个性化配置</h3><ol>\n<li>更换主题<br>进入hexo相关主题展示的theme网站,选取一款你喜欢的主题。将你喜欢的主题clone到themes文件夹下，我选的是jacman主题，<br>直接编辑主目录下的_config.yml配置文件，找到theme,将默认的主题换成你喜欢的主题名即可</li>\n<li>配置主题样式<br>换完主题后，就可以修改主题样式了，主要修改主配置文件_config.yml以及主题文件下的配置文件_config.yml。</li>\n<li>添加第三方评论系统</li>\n</ol>\n<p>使用<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">disqus</a>,直接注册，然后获取到duoshuo_shortname，填到jacman主题下面配置文件_config.yml对应的地方，第三方评论系统就安装好了</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://www.jianshu.com/p/e68fba58f75c\" target=\"_blank\" rel=\"noopener\">利用 GitHub Pages 快速搭建个人博客</a><br><a href=\"http://chenliangjing.me/2016/05/01/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/\" target=\"_blank\" rel=\"noopener\">我的个人技术博客搭建之旅</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><pre><code>GitHub会为每一个注册用户分配一个300M的个人空间，所以和hexo结合起来，利用github给我们的免费空间，\n将我们的静态网页托管到上面，就实现了一个免费的搭建个人博客的方案。\n</code></pre><h2 id=\"主要设计名词\"><a href=\"#主要设计名词\" class=\"headerlink\" title=\"主要设计名词\"></a>主要设计名词</h2><ul>\n<li>Git</li>\n<li>Hexo</li>\n<li>Node.js</li>\n<li>npm</li>\n<li>Markdown</li>\n<li>VS Code  <h2 id=\"主要步骤\"><a href=\"#主要步骤\" class=\"headerlink\" title=\"主要步骤\"></a>主要步骤</h2><h3 id=\"注册GitHub帐号，新建代码仓库\"><a href=\"#注册GitHub帐号，新建代码仓库\" class=\"headerlink\" title=\"注册GitHub帐号，新建代码仓库\"></a>注册GitHub帐号，新建代码仓库</h3></li>\n</ul>\n<ol>\n<li>登录GitHub网站，注册一个帐号</li>\n<li>新建一个代码仓库</li>\n<li>填写仓库信息，其中仓库名称必须和用户名一样</li>\n</ol>\n<h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><ol>\n<li>安装git。由于我使用的是MAC OS系统，自带了git功能，如果是其他系统，安装一个git客户端软件即可</li>\n<li>安装Node环境，Hexo就是基于Node的，访问速度特别快。进入node.js官网，选对操作系统，安装即可</li>\n</ol>\n<h3 id=\"安装Hexo，初始化博客\"><a href=\"#安装Hexo，初始化博客\" class=\"headerlink\" title=\"安装Hexo，初始化博客\"></a>安装Hexo，初始化博客</h3><p>git和node环境安装好了以后。接下来就可以安装hexo了，直接在命令行中敲入如下代码：</p>\n<pre><code>npm install -g hexo-cli\n</code></pre><p>接下来建站</p>\n<pre><code>hexo init &lt;folder&gt;  # 初始化博客，&lt;文件夹名称&gt;，表示文件会下载到当前目录下的这个文件夹内\ncd &lt;folder&gt;         # 进入到这个文件夹目录\nnpm install         # 安装npm\n</code></pre><p>使用相关编辑器打开这个文件夹<folder>中的文件夹，我是用的是<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">VS Code</a></folder></p>\n<h3 id=\"本地预览\"><a href=\"#本地预览\" class=\"headerlink\" title=\"本地预览\"></a>本地预览</h3><pre><code>hexo server # 开启本地服务器\n</code></pre><p>然后在浏览器里面输入网址<a href=\"http://localhost:4000，就能看到默认主题的界面\" target=\"_blank\" rel=\"noopener\">http://localhost:4000，就能看到默认主题的界面</a></p>\n<p><em>这是因为初始化hexo的时候就已经把一个能够起小型的网路服务器功能的依赖装好了，所以启动一下这个本地服务，就能看到hexo的默认主题</em></p>\n<h3 id=\"上传到远程代码仓库\"><a href=\"#上传到远程代码仓库\" class=\"headerlink\" title=\"上传到远程代码仓库\"></a>上传到远程代码仓库</h3><p>接下来就要将本地的代码上传到远程github仓库。首先建立和之前新建的代码仓库之间的关联，利用ssh key，具体是先用命令行在本地生成一个ssh key，<br>然后复制到github上去。</p>\n<p>一. 先检查本地有没存在ssh key</p>\n<pre><code>ls -al ~/.ssh  # 列出在.ssh文件夹下所有的文件，如果存在这个文件夹或者这些文件的话\n</code></pre><p>二. 生成新的ssh key</p>\n<pre><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot; # 注意将`your_email`替换成之前注册github帐号时的邮箱\n</code></pre><p>生成成功或已经存在的，进入到~/.ssh/路径下，用文件编辑器打开文件，里面的内容就是ssk key，将内容复制到剪切板</p>\n<ol>\n<li>登录GitHub网站,依次点击Settings –&gt; SSH and GPG keys –&gt; New SSH key，进入新建SSK key页面，随便填写一下Title,然后将剪切板中复制好的ssh key复制到key中去，最后点击Add SSH key按钮，就OK了</li>\n<li><p>用VSCode打开博客主目录，找到主目录在的_config.yml文件，编辑这个文件，找到最下方deployment模块（顺便找到Site模块，修改一下博客的titile，subtitle，author，<br>改成你自己个性化的<br>），将deployment模块里面的代码替换为如下：</p>\n<pre><code>deploy:\n  type: git\n    repository: https://github.com/用户名/用户名.github.io.git # 将用户名替换为你自己的github用户名\n    branch: master\n</code></pre></li>\n</ol>\n<p>特别提醒：每个分号:后都要有一个空格，不然接下来生成和部署博客到github上时会报下面这种错误：</p>\n<pre><code>JS-YAML: bad indentation of a mapping entry at line , column\n</code></pre><p>三. 进到博客根目录下，先执行</p>\n<pre><code>hexo generate       # 或者：hexo g  生成静态页面至public目录\n</code></pre><p>如出现报错</p>\n<pre><code>ERROR Local hexo not found in ~/blog\nERROR Try runing: &apos;npm install hexo --save&apos;\n</code></pre><p>则执行：    </p>\n<pre><code>npm install hexo --save\n</code></pre><p>再执行：</p>\n<pre><code>hexo deploy  # 或者：hexo -g   将.deploy目录部署到GitHub\n</code></pre><p>如果无法连接到git,则执行：</p>\n<pre><code>npm install hexo-deployer-git --save  # 安装hexo-deployer-git\n</code></pre><p>最后再执行：</p>\n<pre><code>hexo g\nhexo d\n</code></pre><p>四. 进到浏览器，打开http://用户名.github.io网址，就可以看到和之前本地看到的hexo默认主题的首页，<br>看到你修改好的博客title，subtitle，author，等。至此，和github的关联已经建立好，接下来就可以写博客了</p>\n<h3 id=\"写博客\"><a href=\"#写博客\" class=\"headerlink\" title=\"写博客\"></a>写博客</h3><p>写博客主要使用到几个命令：</p>\n<pre><code>hexo new &quot;postName&quot; # 新建文章 默认在\\source\\_posts\\postName.md文件夹下\nhexo new page &quot;pageName&quot; #新建页面，如关于我界面\n</code></pre><p>新建后，在source文件目录下生成一个以postName命名的.md文件，直接用markdown语法编辑，写文章就是这么简单。<br>hexo可以将markdown语法的文件渲染成静态的HTML。关于markdown语法，非常简单，上手很快，可以上网去搜一下语法<br><a href=\"http://wowubuntu.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown 语法说明 (简体中文版)</a></p>\n<pre><code>hexo clean # 删除之前生成的public文件夹和缓存数据\nhexo g     # 重新生成博客文件\nhexo d     # 将修改同步到github远程仓库\n</code></pre><h3 id=\"换主题，个性化配置\"><a href=\"#换主题，个性化配置\" class=\"headerlink\" title=\"换主题，个性化配置\"></a>换主题，个性化配置</h3><ol>\n<li>更换主题<br>进入hexo相关主题展示的theme网站,选取一款你喜欢的主题。将你喜欢的主题clone到themes文件夹下，我选的是jacman主题，<br>直接编辑主目录下的_config.yml配置文件，找到theme,将默认的主题换成你喜欢的主题名即可</li>\n<li>配置主题样式<br>换完主题后，就可以修改主题样式了，主要修改主配置文件_config.yml以及主题文件下的配置文件_config.yml。</li>\n<li>添加第三方评论系统</li>\n</ol>\n<p>使用<a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">disqus</a>,直接注册，然后获取到duoshuo_shortname，填到jacman主题下面配置文件_config.yml对应的地方，第三方评论系统就安装好了</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://www.jianshu.com/p/e68fba58f75c\" target=\"_blank\" rel=\"noopener\">利用 GitHub Pages 快速搭建个人博客</a><br><a href=\"http://chenliangjing.me/2016/05/01/%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8B%E6%97%85/\" target=\"_blank\" rel=\"noopener\">我的个人技术博客搭建之旅</a></p>\n"},{"title":"Hexo新建页面显示多个文章","comments":1,"date":"2018-07-23T10:58:48.000Z","_content":"\n### 配置categories\n**1.生成post(文章)时默认生成categories配置项：在根目录下scaffolds/post.md中，\n添加一行categories:。同理可应用在page.md和photo.md，示例如下：**\n    \n    ---\n    title: {{ title }}\n    date: {{ date }}\n    tags: ['标签1','标签2']\n    categories: ['前端']\n    comments: false    // 是否开启评论\n    img:               // 自定义缩略图\n    ---\n\n**2.在实际写作时，在开头进行categories配置。例如：**\n\n    ---\n    title: Hexo新建页面显示多个文章\n    tags:\n      - 标签1\n      - 标签2\n    categories:\n      - 前端\n    comments: false    // 是否开启评论\n    img: // 自定义缩略图\n    date: 2018-07-23 18:58:48\n    ---\n    \n这样在文章发布时，在git中使用hexo g命令，hexo会在根目录/public/categrises下自动生成归档文件夹，如图：\n\n   ![](Hexo新建页面显示多个文章/categories.png)\n   \n**3.配置博客首页归档展示样式。在主题配置文件themes/_config.yml中添加以下代码:**\n\n    menu:\n    - page: home\n      url: /\n      icon: fa-home\n    - page: 前端\n      url: /categories/前端\n      icon:\n    - page: 后端\n      url: /categories/后端\n      icon:\n    - page: 工具\n      url: /categories/工具\n      icon:\n    - page: 分类\n      url: /category/\n      icon:\n    - page: 时间轴\n      url: /archives/\n      icon:\n### 补充说明\n**如果发现博客首页展示文本为英文，需要改为中文显示，需要修改先博客根目录下的_config.yml文件的language配置，示例如下：**\n\n    # Site\n    title: 借我一支烟\n    subtitle: 个人博客\n    description:\n    keywords:\n    author: Lin\n    language: zh-CN\n    timezone:\n然后为实现文章归档名称显示为中文，接着再修改主题配置文件下language/zh-CN.yml即可，示例如下：\n\n    read_more: 阅读全文\n    home: 首页\n    about: 关于我\n    archives: 归档\n\n### 引用本地图片不显示\n 究其原因，是图片路径出现问题。\n Hexo图片引用有他的方式，部署以后，图片会自动添加日期相关的文件结构目录。\n #####  解决方法\n _config.yml 文件中设置 post_asset_folder: true，开启资源文件夹功能，该功能支持用户通过相对路径标签引用资源。\n执行 hexo new [layout] <title> 创建一篇新的文章，会发现 source/_posts 下自动生成了一个和 md 文件同名的目录（也可以自己手动创建），\n这就是用于存放与文章有关的图片文件夹。如下图：\n\n![](Hexo新建页面显示多个文章/images_font.png)\n\n部署之后同目录出现\n\n![](Hexo新建页面显示多个文章/image_found.png)\n\n需要注意的是，使用该种方式在 markdown 文件中引用图片将不再使用 markdown 语法，而是使用标签插件引用相对路径，否则可能造成图片和其他资源显示不正确。引用语法如下：\n\n    {% asset_path slug %}\n    {% asset_img slug [title] %}\n    {% asset_link slug [title] %}\n在上述语法下，插入图片的方法：\n\n    {% asset_img image.png This is an example image %}\n查看页面，发现图片已经可以正常显示了，图片的路径和实际存放目录是一致的。\n如果想使用 markdown 语法插入相对路径的图片，可以利用插件。设置 post_asset_folder:true 后，在根目录下执行：\n\n    npm install https://github.com/CodeFalling/hexo-asset-image --save\n确保在 source/_posts 下创建和 markdown 文件同名的目录，里面存放需要的图片，然后在 markdown 中插入图片：\n \n    ! [hexo image] (hexo/image.png)\n生成的页面中图片引用路径\n\n    <img src=\"/2016/11/25/hexo/image.png\" alt=\"hexo image\">\n至此，用 markdown 完美实现本地图片插入。\n","source":"_posts/Hexo新建页面显示多个文章.md","raw":"---\ntitle: Hexo新建页面显示多个文章\ntags:\n  - Hexo\n  - 前端\ncategories:\n  - 前端\ncomments: false    // 是否开启评论\ndate: 2018-07-23 18:58:48\n---\n\n### 配置categories\n**1.生成post(文章)时默认生成categories配置项：在根目录下scaffolds/post.md中，\n添加一行categories:。同理可应用在page.md和photo.md，示例如下：**\n    \n    ---\n    title: {{ title }}\n    date: {{ date }}\n    tags: ['标签1','标签2']\n    categories: ['前端']\n    comments: false    // 是否开启评论\n    img:               // 自定义缩略图\n    ---\n\n**2.在实际写作时，在开头进行categories配置。例如：**\n\n    ---\n    title: Hexo新建页面显示多个文章\n    tags:\n      - 标签1\n      - 标签2\n    categories:\n      - 前端\n    comments: false    // 是否开启评论\n    img: // 自定义缩略图\n    date: 2018-07-23 18:58:48\n    ---\n    \n这样在文章发布时，在git中使用hexo g命令，hexo会在根目录/public/categrises下自动生成归档文件夹，如图：\n\n   ![](Hexo新建页面显示多个文章/categories.png)\n   \n**3.配置博客首页归档展示样式。在主题配置文件themes/_config.yml中添加以下代码:**\n\n    menu:\n    - page: home\n      url: /\n      icon: fa-home\n    - page: 前端\n      url: /categories/前端\n      icon:\n    - page: 后端\n      url: /categories/后端\n      icon:\n    - page: 工具\n      url: /categories/工具\n      icon:\n    - page: 分类\n      url: /category/\n      icon:\n    - page: 时间轴\n      url: /archives/\n      icon:\n### 补充说明\n**如果发现博客首页展示文本为英文，需要改为中文显示，需要修改先博客根目录下的_config.yml文件的language配置，示例如下：**\n\n    # Site\n    title: 借我一支烟\n    subtitle: 个人博客\n    description:\n    keywords:\n    author: Lin\n    language: zh-CN\n    timezone:\n然后为实现文章归档名称显示为中文，接着再修改主题配置文件下language/zh-CN.yml即可，示例如下：\n\n    read_more: 阅读全文\n    home: 首页\n    about: 关于我\n    archives: 归档\n\n### 引用本地图片不显示\n 究其原因，是图片路径出现问题。\n Hexo图片引用有他的方式，部署以后，图片会自动添加日期相关的文件结构目录。\n #####  解决方法\n _config.yml 文件中设置 post_asset_folder: true，开启资源文件夹功能，该功能支持用户通过相对路径标签引用资源。\n执行 hexo new [layout] <title> 创建一篇新的文章，会发现 source/_posts 下自动生成了一个和 md 文件同名的目录（也可以自己手动创建），\n这就是用于存放与文章有关的图片文件夹。如下图：\n\n![](Hexo新建页面显示多个文章/images_font.png)\n\n部署之后同目录出现\n\n![](Hexo新建页面显示多个文章/image_found.png)\n\n需要注意的是，使用该种方式在 markdown 文件中引用图片将不再使用 markdown 语法，而是使用标签插件引用相对路径，否则可能造成图片和其他资源显示不正确。引用语法如下：\n\n    {% asset_path slug %}\n    {% asset_img slug [title] %}\n    {% asset_link slug [title] %}\n在上述语法下，插入图片的方法：\n\n    {% asset_img image.png This is an example image %}\n查看页面，发现图片已经可以正常显示了，图片的路径和实际存放目录是一致的。\n如果想使用 markdown 语法插入相对路径的图片，可以利用插件。设置 post_asset_folder:true 后，在根目录下执行：\n\n    npm install https://github.com/CodeFalling/hexo-asset-image --save\n确保在 source/_posts 下创建和 markdown 文件同名的目录，里面存放需要的图片，然后在 markdown 中插入图片：\n \n    ! [hexo image] (hexo/image.png)\n生成的页面中图片引用路径\n\n    <img src=\"/2016/11/25/hexo/image.png\" alt=\"hexo image\">\n至此，用 markdown 完美实现本地图片插入。\n","slug":"Hexo新建页面显示多个文章","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiib0006y0w0ify05je1","content":"<h3 id=\"配置categories\"><a href=\"#配置categories\" class=\"headerlink\" title=\"配置categories\"></a>配置categories</h3><p><strong>1.生成post(文章)时默认生成categories配置项：在根目录下scaffolds/post.md中，<br>添加一行categories:。同理可应用在page.md和photo.md，示例如下：</strong></p>\n<pre><code>---\ntitle: {{ title }}\ndate: {{ date }}\ntags: [&apos;标签1&apos;,&apos;标签2&apos;]\ncategories: [&apos;前端&apos;]\ncomments: false    // 是否开启评论\nimg:               // 自定义缩略图\n---\n</code></pre><p><strong>2.在实际写作时，在开头进行categories配置。例如：</strong></p>\n<pre><code>---\ntitle: Hexo新建页面显示多个文章\ntags:\n  - 标签1\n  - 标签2\ncategories:\n  - 前端\ncomments: false    // 是否开启评论\nimg: // 自定义缩略图\ndate: 2018-07-23 18:58:48\n---\n</code></pre><p>这样在文章发布时，在git中使用hexo g命令，hexo会在根目录/public/categrises下自动生成归档文件夹，如图：</p>\n<p>   <img src=\"Hexo新建页面显示多个文章/categories.png\" alt=\"\"></p>\n<p><strong>3.配置博客首页归档展示样式。在主题配置文件themes/_config.yml中添加以下代码:</strong></p>\n<pre><code>menu:\n- page: home\n  url: /\n  icon: fa-home\n- page: 前端\n  url: /categories/前端\n  icon:\n- page: 后端\n  url: /categories/后端\n  icon:\n- page: 工具\n  url: /categories/工具\n  icon:\n- page: 分类\n  url: /category/\n  icon:\n- page: 时间轴\n  url: /archives/\n  icon:\n</code></pre><h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><p><strong>如果发现博客首页展示文本为英文，需要改为中文显示，需要修改先博客根目录下的_config.yml文件的language配置，示例如下：</strong></p>\n<pre><code># Site\ntitle: 借我一支烟\nsubtitle: 个人博客\ndescription:\nkeywords:\nauthor: Lin\nlanguage: zh-CN\ntimezone:\n</code></pre><p>然后为实现文章归档名称显示为中文，接着再修改主题配置文件下language/zh-CN.yml即可，示例如下：</p>\n<pre><code>read_more: 阅读全文\nhome: 首页\nabout: 关于我\narchives: 归档\n</code></pre><h3 id=\"引用本地图片不显示\"><a href=\"#引用本地图片不显示\" class=\"headerlink\" title=\"引用本地图片不显示\"></a>引用本地图片不显示</h3><p> 究其原因，是图片路径出现问题。<br> Hexo图片引用有他的方式，部署以后，图片会自动添加日期相关的文件结构目录。</p>\n<h5 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h5><p> _config.yml 文件中设置 post_asset_folder: true，开启资源文件夹功能，该功能支持用户通过相对路径标签引用资源。<br>执行 hexo new [layout] <title> 创建一篇新的文章，会发现 source/_posts 下自动生成了一个和 md 文件同名的目录（也可以自己手动创建），<br>这就是用于存放与文章有关的图片文件夹。如下图：</title></p>\n<p><img src=\"Hexo新建页面显示多个文章/images_font.png\" alt=\"\"></p>\n<p>部署之后同目录出现</p>\n<p><img src=\"Hexo新建页面显示多个文章/image_found.png\" alt=\"\"></p>\n<p>需要注意的是，使用该种方式在 markdown 文件中引用图片将不再使用 markdown 语法，而是使用标签插件引用相对路径，否则可能造成图片和其他资源显示不正确。引用语法如下：</p>\n<pre><code>{% asset_path slug %}\n{% asset_img slug [title] %}\n{% asset_link slug [title] %}\n</code></pre><p>在上述语法下，插入图片的方法：</p>\n<pre><code>{% asset_img image.png This is an example image %}\n</code></pre><p>查看页面，发现图片已经可以正常显示了，图片的路径和实际存放目录是一致的。<br>如果想使用 markdown 语法插入相对路径的图片，可以利用插件。设置 post_asset_folder:true 后，在根目录下执行：</p>\n<pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save\n</code></pre><p>确保在 source/_posts 下创建和 markdown 文件同名的目录，里面存放需要的图片，然后在 markdown 中插入图片：</p>\n<pre><code>! [hexo image] (hexo/image.png)\n</code></pre><p>生成的页面中图片引用路径</p>\n<pre><code>&lt;img src=&quot;/2016/11/25/hexo/image.png&quot; alt=&quot;hexo image&quot;&gt;\n</code></pre><p>至此，用 markdown 完美实现本地图片插入。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"配置categories\"><a href=\"#配置categories\" class=\"headerlink\" title=\"配置categories\"></a>配置categories</h3><p><strong>1.生成post(文章)时默认生成categories配置项：在根目录下scaffolds/post.md中，<br>添加一行categories:。同理可应用在page.md和photo.md，示例如下：</strong></p>\n<pre><code>---\ntitle: {{ title }}\ndate: {{ date }}\ntags: [&apos;标签1&apos;,&apos;标签2&apos;]\ncategories: [&apos;前端&apos;]\ncomments: false    // 是否开启评论\nimg:               // 自定义缩略图\n---\n</code></pre><p><strong>2.在实际写作时，在开头进行categories配置。例如：</strong></p>\n<pre><code>---\ntitle: Hexo新建页面显示多个文章\ntags:\n  - 标签1\n  - 标签2\ncategories:\n  - 前端\ncomments: false    // 是否开启评论\nimg: // 自定义缩略图\ndate: 2018-07-23 18:58:48\n---\n</code></pre><p>这样在文章发布时，在git中使用hexo g命令，hexo会在根目录/public/categrises下自动生成归档文件夹，如图：</p>\n<p>   <img src=\"Hexo新建页面显示多个文章/categories.png\" alt=\"\"></p>\n<p><strong>3.配置博客首页归档展示样式。在主题配置文件themes/_config.yml中添加以下代码:</strong></p>\n<pre><code>menu:\n- page: home\n  url: /\n  icon: fa-home\n- page: 前端\n  url: /categories/前端\n  icon:\n- page: 后端\n  url: /categories/后端\n  icon:\n- page: 工具\n  url: /categories/工具\n  icon:\n- page: 分类\n  url: /category/\n  icon:\n- page: 时间轴\n  url: /archives/\n  icon:\n</code></pre><h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><p><strong>如果发现博客首页展示文本为英文，需要改为中文显示，需要修改先博客根目录下的_config.yml文件的language配置，示例如下：</strong></p>\n<pre><code># Site\ntitle: 借我一支烟\nsubtitle: 个人博客\ndescription:\nkeywords:\nauthor: Lin\nlanguage: zh-CN\ntimezone:\n</code></pre><p>然后为实现文章归档名称显示为中文，接着再修改主题配置文件下language/zh-CN.yml即可，示例如下：</p>\n<pre><code>read_more: 阅读全文\nhome: 首页\nabout: 关于我\narchives: 归档\n</code></pre><h3 id=\"引用本地图片不显示\"><a href=\"#引用本地图片不显示\" class=\"headerlink\" title=\"引用本地图片不显示\"></a>引用本地图片不显示</h3><p> 究其原因，是图片路径出现问题。<br> Hexo图片引用有他的方式，部署以后，图片会自动添加日期相关的文件结构目录。</p>\n<h5 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h5><p> _config.yml 文件中设置 post_asset_folder: true，开启资源文件夹功能，该功能支持用户通过相对路径标签引用资源。<br>执行 hexo new [layout] <title> 创建一篇新的文章，会发现 source/_posts 下自动生成了一个和 md 文件同名的目录（也可以自己手动创建），<br>这就是用于存放与文章有关的图片文件夹。如下图：</title></p>\n<p><img src=\"Hexo新建页面显示多个文章/images_font.png\" alt=\"\"></p>\n<p>部署之后同目录出现</p>\n<p><img src=\"Hexo新建页面显示多个文章/image_found.png\" alt=\"\"></p>\n<p>需要注意的是，使用该种方式在 markdown 文件中引用图片将不再使用 markdown 语法，而是使用标签插件引用相对路径，否则可能造成图片和其他资源显示不正确。引用语法如下：</p>\n<pre><code>{% asset_path slug %}\n{% asset_img slug [title] %}\n{% asset_link slug [title] %}\n</code></pre><p>在上述语法下，插入图片的方法：</p>\n<pre><code>{% asset_img image.png This is an example image %}\n</code></pre><p>查看页面，发现图片已经可以正常显示了，图片的路径和实际存放目录是一致的。<br>如果想使用 markdown 语法插入相对路径的图片，可以利用插件。设置 post_asset_folder:true 后，在根目录下执行：</p>\n<pre><code>npm install https://github.com/CodeFalling/hexo-asset-image --save\n</code></pre><p>确保在 source/_posts 下创建和 markdown 文件同名的目录，里面存放需要的图片，然后在 markdown 中插入图片：</p>\n<pre><code>! [hexo image] (hexo/image.png)\n</code></pre><p>生成的页面中图片引用路径</p>\n<pre><code>&lt;img src=&quot;/2016/11/25/hexo/image.png&quot; alt=&quot;hexo image&quot;&gt;\n</code></pre><p>至此，用 markdown 完美实现本地图片插入。</p>\n"},{"title":"IOS马甲包混淆必过4.3审核上线方法整理","comments":1,"date":"2018-07-24T07:24:41.000Z","_content":"\n相关参考链接\n\n1. [https://zhuanlan.zhihu.com/p/38481422](https://zhuanlan.zhihu.com/p/38481422)\n\n2. [https://www.jianshu.com/p/871dda4f5dca](https://www.jianshu.com/p/871dda4f5dca)\n\n3. [https://www.jianshu.com/p/37db5b67704a](https://www.jianshu.com/p/37db5b67704a)\n\n4. [https://www.jianshu.com/p/eb3069bcba52](https://www.jianshu.com/p/eb3069bcba52)\n\n5. [https://blog.csdn.net/lyzz0612/article/details/80390362](https://blog.csdn.net/lyzz0612/article/details/80390362)\n\n6. [https://blog.csdn.net/kuaileboer/article/details/80030930](https://blog.csdn.net/kuaileboer/article/details/80030930)\n","source":"_posts/IOS马甲包混淆必过4-3审核上线方法整理.md","raw":"---\ntitle: IOS马甲包混淆必过4.3审核上线方法整理\ntags:\n  - IOS\n  - 审核\ncategories:\n  - 前端\ncomments: false    // 是否开启评论\ndate: 2018-07-24 15:24:41\n---\n\n相关参考链接\n\n1. [https://zhuanlan.zhihu.com/p/38481422](https://zhuanlan.zhihu.com/p/38481422)\n\n2. [https://www.jianshu.com/p/871dda4f5dca](https://www.jianshu.com/p/871dda4f5dca)\n\n3. [https://www.jianshu.com/p/37db5b67704a](https://www.jianshu.com/p/37db5b67704a)\n\n4. [https://www.jianshu.com/p/eb3069bcba52](https://www.jianshu.com/p/eb3069bcba52)\n\n5. [https://blog.csdn.net/lyzz0612/article/details/80390362](https://blog.csdn.net/lyzz0612/article/details/80390362)\n\n6. [https://blog.csdn.net/kuaileboer/article/details/80030930](https://blog.csdn.net/kuaileboer/article/details/80030930)\n","slug":"IOS马甲包混淆必过4-3审核上线方法整理","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiid0009y0w04jue7zlq","content":"<p>相关参考链接</p>\n<ol>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/38481422\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/38481422</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/871dda4f5dca\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/871dda4f5dca</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/37db5b67704a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/37db5b67704a</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/eb3069bcba52\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/eb3069bcba52</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/lyzz0612/article/details/80390362\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lyzz0612/article/details/80390362</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/kuaileboer/article/details/80030930\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kuaileboer/article/details/80030930</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>相关参考链接</p>\n<ol>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/38481422\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/38481422</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/871dda4f5dca\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/871dda4f5dca</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/37db5b67704a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/37db5b67704a</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/eb3069bcba52\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/eb3069bcba52</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/lyzz0612/article/details/80390362\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lyzz0612/article/details/80390362</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/kuaileboer/article/details/80030930\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/kuaileboer/article/details/80030930</a></p>\n</li>\n</ol>\n"},{"title":"Git 常用命令","comments":1,"date":"2018-07-24T07:32:58.000Z","_content":"\n### Git global setup\n\n    git config --global user.name \"YourNames\"\n    git config --global user.email \"YourMail\"\n    \nCreate a new repository\n\n    git clone git@xxx.com:open/open.git\n    cd open\n    touch README.md\n    git add README.md\n    git commit -m \"add README\"\n    git push -u origin master\nExisting folder or Git repository\n\n    cd existing_folder\n    git init\n    git remote add origin git@xxx.com:open/open.git\n    git add .\n    git commit\n    git push -u origin master\n如何删除本地分支\n\n    git branch -d branch_name\n如何删除远端分支\n\n    git push origin :branch_name\n远端分支已经删除，本地还出现这个分支\n\n    git fetch origin -p \n如何撤销上一次提交 ***高风险操作***\n    \n    git reset ^1 --hard \n\n\n\n\n\n\n\n\n","source":"_posts/Git-常用命令.md","raw":"---\ntitle: Git 常用命令\ntags:\n  - Git\ncategories:\n  - Git\ncomments: false    // 是否开启评论\ndate: 2018-07-24 15:32:58\n---\n\n### Git global setup\n\n    git config --global user.name \"YourNames\"\n    git config --global user.email \"YourMail\"\n    \nCreate a new repository\n\n    git clone git@xxx.com:open/open.git\n    cd open\n    touch README.md\n    git add README.md\n    git commit -m \"add README\"\n    git push -u origin master\nExisting folder or Git repository\n\n    cd existing_folder\n    git init\n    git remote add origin git@xxx.com:open/open.git\n    git add .\n    git commit\n    git push -u origin master\n如何删除本地分支\n\n    git branch -d branch_name\n如何删除远端分支\n\n    git push origin :branch_name\n远端分支已经删除，本地还出现这个分支\n\n    git fetch origin -p \n如何撤销上一次提交 ***高风险操作***\n    \n    git reset ^1 --hard \n\n\n\n\n\n\n\n\n","slug":"Git-常用命令","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiie000ay0w0qp6rqrd1","content":"<h3 id=\"Git-global-setup\"><a href=\"#Git-global-setup\" class=\"headerlink\" title=\"Git global setup\"></a>Git global setup</h3><pre><code>git config --global user.name &quot;YourNames&quot;\ngit config --global user.email &quot;YourMail&quot;\n</code></pre><p>Create a new repository</p>\n<pre><code>git clone git@xxx.com:open/open.git\ncd open\ntouch README.md\ngit add README.md\ngit commit -m &quot;add README&quot;\ngit push -u origin master\n</code></pre><p>Existing folder or Git repository</p>\n<pre><code>cd existing_folder\ngit init\ngit remote add origin git@xxx.com:open/open.git\ngit add .\ngit commit\ngit push -u origin master\n</code></pre><p>如何删除本地分支</p>\n<pre><code>git branch -d branch_name\n</code></pre><p>如何删除远端分支</p>\n<pre><code>git push origin :branch_name\n</code></pre><p>远端分支已经删除，本地还出现这个分支</p>\n<pre><code>git fetch origin -p \n</code></pre><p>如何撤销上一次提交 <strong><em>高风险操作</em></strong></p>\n<pre><code>git reset ^1 --hard \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Git-global-setup\"><a href=\"#Git-global-setup\" class=\"headerlink\" title=\"Git global setup\"></a>Git global setup</h3><pre><code>git config --global user.name &quot;YourNames&quot;\ngit config --global user.email &quot;YourMail&quot;\n</code></pre><p>Create a new repository</p>\n<pre><code>git clone git@xxx.com:open/open.git\ncd open\ntouch README.md\ngit add README.md\ngit commit -m &quot;add README&quot;\ngit push -u origin master\n</code></pre><p>Existing folder or Git repository</p>\n<pre><code>cd existing_folder\ngit init\ngit remote add origin git@xxx.com:open/open.git\ngit add .\ngit commit\ngit push -u origin master\n</code></pre><p>如何删除本地分支</p>\n<pre><code>git branch -d branch_name\n</code></pre><p>如何删除远端分支</p>\n<pre><code>git push origin :branch_name\n</code></pre><p>远端分支已经删除，本地还出现这个分支</p>\n<pre><code>git fetch origin -p \n</code></pre><p>如何撤销上一次提交 <strong><em>高风险操作</em></strong></p>\n<pre><code>git reset ^1 --hard \n</code></pre>"},{"title":"Markdown 语法说明 (简体中文版)","comments":1,"date":"2018-07-20T12:47:03.000Z","_content":"\n链接地址：[http://wowubuntu.com/markdown/#link](http://wowubuntu.com/markdown/#link)\n\n[简书](https://www.jianshu.com/p/67daca4d4502)\n\n### 说明：\n\n1. 引用是在名词前加4个空格，并且有空行\n","source":"_posts/Markdown.md","raw":"---\ntitle: Markdown 语法说明 (简体中文版)\ntags:\n  - 前端\n  - 工具\ncomments: false    // 是否开启评论\ndate: 2018-07-20 20:47:03\n---\n\n链接地址：[http://wowubuntu.com/markdown/#link](http://wowubuntu.com/markdown/#link)\n\n[简书](https://www.jianshu.com/p/67daca4d4502)\n\n### 说明：\n\n1. 引用是在名词前加4个空格，并且有空行\n","slug":"Markdown","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiig000ey0w0vyunenj0","content":"<p>链接地址：<a href=\"http://wowubuntu.com/markdown/#link\" target=\"_blank\" rel=\"noopener\">http://wowubuntu.com/markdown/#link</a></p>\n<p><a href=\"https://www.jianshu.com/p/67daca4d4502\" target=\"_blank\" rel=\"noopener\">简书</a></p>\n<h3 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h3><ol>\n<li>引用是在名词前加4个空格，并且有空行</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>链接地址：<a href=\"http://wowubuntu.com/markdown/#link\" target=\"_blank\" rel=\"noopener\">http://wowubuntu.com/markdown/#link</a></p>\n<p><a href=\"https://www.jianshu.com/p/67daca4d4502\" target=\"_blank\" rel=\"noopener\">简书</a></p>\n<h3 id=\"说明：\"><a href=\"#说明：\" class=\"headerlink\" title=\"说明：\"></a>说明：</h3><ol>\n<li>引用是在名词前加4个空格，并且有空行</li>\n</ol>\n"},{"title":"Python-读取文件","comments":1,"date":"2018-07-24T08:24:54.000Z","_content":"\n### 获取当前路径\n\n    def get_file_path():\n        # 获取脚本路径\n        path = sys.path[0]\n        if os.path.isdir(path):\n            return path\n        elif os.path.isfile(path):\n            return os.path.dirname(path)\n### 读取文件\n\n    item_object = open(item_txt_path, \"rU\")\n        try:\n            for line in islice(item_object, 1, None):\n                id_str = re.split(r\"\\t\", line)\n                id_list = {'id': id_str[0], 'name': id_str[1]}\n                self.idArr.append(id_list)\n        finally:\n            item_object.close()\nislice(item_object, 1, None)跳过第一行\n\n[github](https://github.com/CSLHouse/Python-ReadFile-UploadMysql.git)\n","source":"_posts/Python-读取文件.md","raw":"---\ntitle: Python-读取文件\ntags:\n  - Python\ncategories:\n  - Python\ncomments: false    // 是否开启评论\ndate: 2018-07-24 16:24:54\n---\n\n### 获取当前路径\n\n    def get_file_path():\n        # 获取脚本路径\n        path = sys.path[0]\n        if os.path.isdir(path):\n            return path\n        elif os.path.isfile(path):\n            return os.path.dirname(path)\n### 读取文件\n\n    item_object = open(item_txt_path, \"rU\")\n        try:\n            for line in islice(item_object, 1, None):\n                id_str = re.split(r\"\\t\", line)\n                id_list = {'id': id_str[0], 'name': id_str[1]}\n                self.idArr.append(id_list)\n        finally:\n            item_object.close()\nislice(item_object, 1, None)跳过第一行\n\n[github](https://github.com/CSLHouse/Python-ReadFile-UploadMysql.git)\n","slug":"Python-读取文件","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiih000gy0w04z69t2x8","content":"<h3 id=\"获取当前路径\"><a href=\"#获取当前路径\" class=\"headerlink\" title=\"获取当前路径\"></a>获取当前路径</h3><pre><code>def get_file_path():\n    # 获取脚本路径\n    path = sys.path[0]\n    if os.path.isdir(path):\n        return path\n    elif os.path.isfile(path):\n        return os.path.dirname(path)\n</code></pre><h3 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h3><pre><code>item_object = open(item_txt_path, &quot;rU&quot;)\n    try:\n        for line in islice(item_object, 1, None):\n            id_str = re.split(r&quot;\\t&quot;, line)\n            id_list = {&apos;id&apos;: id_str[0], &apos;name&apos;: id_str[1]}\n            self.idArr.append(id_list)\n    finally:\n        item_object.close()\n</code></pre><p>islice(item_object, 1, None)跳过第一行</p>\n<p><a href=\"https://github.com/CSLHouse/Python-ReadFile-UploadMysql.git\" target=\"_blank\" rel=\"noopener\">github</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"获取当前路径\"><a href=\"#获取当前路径\" class=\"headerlink\" title=\"获取当前路径\"></a>获取当前路径</h3><pre><code>def get_file_path():\n    # 获取脚本路径\n    path = sys.path[0]\n    if os.path.isdir(path):\n        return path\n    elif os.path.isfile(path):\n        return os.path.dirname(path)\n</code></pre><h3 id=\"读取文件\"><a href=\"#读取文件\" class=\"headerlink\" title=\"读取文件\"></a>读取文件</h3><pre><code>item_object = open(item_txt_path, &quot;rU&quot;)\n    try:\n        for line in islice(item_object, 1, None):\n            id_str = re.split(r&quot;\\t&quot;, line)\n            id_list = {&apos;id&apos;: id_str[0], &apos;name&apos;: id_str[1]}\n            self.idArr.append(id_list)\n    finally:\n        item_object.close()\n</code></pre><p>islice(item_object, 1, None)跳过第一行</p>\n<p><a href=\"https://github.com/CSLHouse/Python-ReadFile-UploadMysql.git\" target=\"_blank\" rel=\"noopener\">github</a></p>\n"},{"title":"Python--配置虚拟环境","comments":1,"date":"2018-07-20T12:24:15.000Z","_content":"\n# 安装虚拟环境\n\n1. 打开终端,利用pip/pip3 安装 (pip安装在python2,pip3安装在python3中)\n\n        执行：sudo pip install virtualenv\n        \n2. 创建环境\n\n   virtualenv 环境名\n   \n   例：\n       \n        1. mkdir ~/py_envs # 在用户目录下创建了一个统一管理虚拟环境的目录    \n        2. cd ~/py_envs # 跳进这个目录\n        3. virtualenv env_workspace1 # 创建一个虚拟工作空间\n        \n   创建指定python版本的环境\n   \n   **virtualenv venv --python=python2.7**\n3. 激活环境（切换到新环境目录）\n\n    执行：source ./bin/activate\n    例:\n    \n       cd env_workspace1 # 进入虚拟环境\n       source bin/activate # 激活虚拟环境\n4. 使用环境 （接下来直接pip安装需要的插件）\n\n   注意！不要加sudo，否则会安装到系统环境中，没有安装到虚拟环境中执行：pip install xxx\n   \n   例：\n   \n        pip install flask     \n        pip install django\n        pip install Scipy\n5. 退出环境\n\n        deactivate\n    \n6. 删除环境 （需要在退出环境之后才能操作）\n    \n        rmvirtualenv 环境名\n","source":"_posts/Python-配置虚拟环境.md","raw":"---\ntitle: Python--配置虚拟环境\ntags:\n  - Python\n  - 前端\ncategories: Python\ncomments: false    // 是否开启评论\ndate: 2018-07-20 20:24:15\n---\n\n# 安装虚拟环境\n\n1. 打开终端,利用pip/pip3 安装 (pip安装在python2,pip3安装在python3中)\n\n        执行：sudo pip install virtualenv\n        \n2. 创建环境\n\n   virtualenv 环境名\n   \n   例：\n       \n        1. mkdir ~/py_envs # 在用户目录下创建了一个统一管理虚拟环境的目录    \n        2. cd ~/py_envs # 跳进这个目录\n        3. virtualenv env_workspace1 # 创建一个虚拟工作空间\n        \n   创建指定python版本的环境\n   \n   **virtualenv venv --python=python2.7**\n3. 激活环境（切换到新环境目录）\n\n    执行：source ./bin/activate\n    例:\n    \n       cd env_workspace1 # 进入虚拟环境\n       source bin/activate # 激活虚拟环境\n4. 使用环境 （接下来直接pip安装需要的插件）\n\n   注意！不要加sudo，否则会安装到系统环境中，没有安装到虚拟环境中执行：pip install xxx\n   \n   例：\n   \n        pip install flask     \n        pip install django\n        pip install Scipy\n5. 退出环境\n\n        deactivate\n    \n6. 删除环境 （需要在退出环境之后才能操作）\n    \n        rmvirtualenv 环境名\n","slug":"Python-配置虚拟环境","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiij000ly0w0bhoztahl","content":"<h1 id=\"安装虚拟环境\"><a href=\"#安装虚拟环境\" class=\"headerlink\" title=\"安装虚拟环境\"></a>安装虚拟环境</h1><ol>\n<li><p>打开终端,利用pip/pip3 安装 (pip安装在python2,pip3安装在python3中)</p>\n<pre><code>执行：sudo pip install virtualenv\n</code></pre></li>\n<li><p>创建环境</p>\n<p>virtualenv 环境名</p>\n<p>例：</p>\n<pre><code>1. mkdir ~/py_envs # 在用户目录下创建了一个统一管理虚拟环境的目录    \n2. cd ~/py_envs # 跳进这个目录\n3. virtualenv env_workspace1 # 创建一个虚拟工作空间\n</code></pre><p>创建指定python版本的环境</p>\n<p><strong>virtualenv venv –python=python2.7</strong></p>\n</li>\n<li><p>激活环境（切换到新环境目录）</p>\n<p> 执行：source ./bin/activate<br> 例:</p>\n<pre><code>cd env_workspace1 # 进入虚拟环境\nsource bin/activate # 激活虚拟环境\n</code></pre></li>\n<li><p>使用环境 （接下来直接pip安装需要的插件）</p>\n<p>注意！不要加sudo，否则会安装到系统环境中，没有安装到虚拟环境中执行：pip install xxx</p>\n<p>例：</p>\n<pre><code>pip install flask     \npip install django\npip install Scipy\n</code></pre></li>\n<li><p>退出环境</p>\n<pre><code>deactivate\n</code></pre></li>\n<li><p>删除环境 （需要在退出环境之后才能操作）</p>\n<pre><code>rmvirtualenv 环境名\n</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"安装虚拟环境\"><a href=\"#安装虚拟环境\" class=\"headerlink\" title=\"安装虚拟环境\"></a>安装虚拟环境</h1><ol>\n<li><p>打开终端,利用pip/pip3 安装 (pip安装在python2,pip3安装在python3中)</p>\n<pre><code>执行：sudo pip install virtualenv\n</code></pre></li>\n<li><p>创建环境</p>\n<p>virtualenv 环境名</p>\n<p>例：</p>\n<pre><code>1. mkdir ~/py_envs # 在用户目录下创建了一个统一管理虚拟环境的目录    \n2. cd ~/py_envs # 跳进这个目录\n3. virtualenv env_workspace1 # 创建一个虚拟工作空间\n</code></pre><p>创建指定python版本的环境</p>\n<p><strong>virtualenv venv –python=python2.7</strong></p>\n</li>\n<li><p>激活环境（切换到新环境目录）</p>\n<p> 执行：source ./bin/activate<br> 例:</p>\n<pre><code>cd env_workspace1 # 进入虚拟环境\nsource bin/activate # 激活虚拟环境\n</code></pre></li>\n<li><p>使用环境 （接下来直接pip安装需要的插件）</p>\n<p>注意！不要加sudo，否则会安装到系统环境中，没有安装到虚拟环境中执行：pip install xxx</p>\n<p>例：</p>\n<pre><code>pip install flask     \npip install django\npip install Scipy\n</code></pre></li>\n<li><p>退出环境</p>\n<pre><code>deactivate\n</code></pre></li>\n<li><p>删除环境 （需要在退出环境之后才能操作）</p>\n<pre><code>rmvirtualenv 环境名\n</code></pre></li>\n</ol>\n"},{"title":"centos7安装mysql","comments":1,"date":"2018-08-10T10:02:20.000Z","_content":"## 环境\nLinux版本：5.7\n\n## 安装\n[下载地址](https://pan.baidu.com/s/14YeOQnQs7HKVHf16ngnSwA)\nyum install -y mysql*\n注：一开始一直报‘Failed to start mysqld.service: Unit not found.’\n网上查找方法，好一通折腾，原来没安装mysql-community-server。\n\n### 启动\n执行\n\n    service mysqld start\n通过如下命令找到mysql root初始密码\n\n    grep 'temporary password' /var/log/mysqld.log\n\n- 登录mysql，修改密码\n执行\n\n      mysql -uroot -p\n\n然后输入密码登录时，一直如下错误：\n\n      ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)\n\n一般这个错误是由密码错误引起，解决的办法自然就是重置密码\n解决方案如下：\n1. 停止mysql数据库：service mysqld stop或systemctl stop mysqld\n\n2. 用以下命令启动MySQL，以不检查权限的方式启动：\n\nmysqld --skip-grant-tables &\n\n此时又报了一个错误：2018-02-01T02:52:55.093724Z 0 [ERROR] Fatal error: Please read \"Security\" section of the manual to find out how to run mysqld as root!\n\n执行命令：mysqld --user=root --skip-grant-tables &\n\n3. 登录mysql：service mysqld start \n   mysql -uroot或mysql\n\n4. 更新root密码\n\nmysql5.7以下版本：UPDATE mysql.user SET Password=PASSWORD('123456') where USER='root';\n\nmysql5.7版本：UPDATE mysql.user SET authentication_string=PASSWORD('123456') where USER='root';\n\n5.刷新权限：flush privileges;\n\n6.退出mysql：exit或quit\n\n7.使用root用户重新登录mysql\n\nmysql -uroot -p\n\nEnter password:<输入新设的密码123456>\n","source":"_posts/centos7安装mysql.md","raw":"---\ntitle: centos7安装mysql\ntags:\n  - centos\n  - linux\ncategories:\n  - 后端\ncomments: false    // 是否开启评论\ndate: 2018-08-10 18:02:20\n---\n## 环境\nLinux版本：5.7\n\n## 安装\n[下载地址](https://pan.baidu.com/s/14YeOQnQs7HKVHf16ngnSwA)\nyum install -y mysql*\n注：一开始一直报‘Failed to start mysqld.service: Unit not found.’\n网上查找方法，好一通折腾，原来没安装mysql-community-server。\n\n### 启动\n执行\n\n    service mysqld start\n通过如下命令找到mysql root初始密码\n\n    grep 'temporary password' /var/log/mysqld.log\n\n- 登录mysql，修改密码\n执行\n\n      mysql -uroot -p\n\n然后输入密码登录时，一直如下错误：\n\n      ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)\n\n一般这个错误是由密码错误引起，解决的办法自然就是重置密码\n解决方案如下：\n1. 停止mysql数据库：service mysqld stop或systemctl stop mysqld\n\n2. 用以下命令启动MySQL，以不检查权限的方式启动：\n\nmysqld --skip-grant-tables &\n\n此时又报了一个错误：2018-02-01T02:52:55.093724Z 0 [ERROR] Fatal error: Please read \"Security\" section of the manual to find out how to run mysqld as root!\n\n执行命令：mysqld --user=root --skip-grant-tables &\n\n3. 登录mysql：service mysqld start \n   mysql -uroot或mysql\n\n4. 更新root密码\n\nmysql5.7以下版本：UPDATE mysql.user SET Password=PASSWORD('123456') where USER='root';\n\nmysql5.7版本：UPDATE mysql.user SET authentication_string=PASSWORD('123456') where USER='root';\n\n5.刷新权限：flush privileges;\n\n6.退出mysql：exit或quit\n\n7.使用root用户重新登录mysql\n\nmysql -uroot -p\n\nEnter password:<输入新设的密码123456>\n","slug":"centos7安装mysql","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiil000ny0w0eh2idzr3","content":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>Linux版本：5.7</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><a href=\"https://pan.baidu.com/s/14YeOQnQs7HKVHf16ngnSwA\" target=\"_blank\" rel=\"noopener\">下载地址</a><br>yum install -y mysql*<br>注：一开始一直报‘Failed to start mysqld.service: Unit not found.’<br>网上查找方法，好一通折腾，原来没安装mysql-community-server。</p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>执行</p>\n<pre><code>service mysqld start\n</code></pre><p>通过如下命令找到mysql root初始密码</p>\n<pre><code>grep &apos;temporary password&apos; /var/log/mysqld.log\n</code></pre><ul>\n<li><p>登录mysql，修改密码<br>执行</p>\n<pre><code>mysql -uroot -p\n</code></pre></li>\n</ul>\n<p>然后输入密码登录时，一直如下错误：</p>\n<pre><code>ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES)\n</code></pre><p>一般这个错误是由密码错误引起，解决的办法自然就是重置密码<br>解决方案如下：</p>\n<ol>\n<li><p>停止mysql数据库：service mysqld stop或systemctl stop mysqld</p>\n</li>\n<li><p>用以下命令启动MySQL，以不检查权限的方式启动：</p>\n</li>\n</ol>\n<p>mysqld –skip-grant-tables &amp;</p>\n<p>此时又报了一个错误：2018-02-01T02:52:55.093724Z 0 [ERROR] Fatal error: Please read “Security” section of the manual to find out how to run mysqld as root!</p>\n<p>执行命令：mysqld –user=root –skip-grant-tables &amp;</p>\n<ol start=\"3\">\n<li><p>登录mysql：service mysqld start<br>mysql -uroot或mysql</p>\n</li>\n<li><p>更新root密码</p>\n</li>\n</ol>\n<p>mysql5.7以下版本：UPDATE mysql.user SET Password=PASSWORD(‘123456’) where USER=’root’;</p>\n<p>mysql5.7版本：UPDATE mysql.user SET authentication_string=PASSWORD(‘123456’) where USER=’root’;</p>\n<p>5.刷新权限：flush privileges;</p>\n<p>6.退出mysql：exit或quit</p>\n<p>7.使用root用户重新登录mysql</p>\n<p>mysql -uroot -p</p>\n<p>Enter password:&lt;输入新设的密码123456&gt;</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>Linux版本：5.7</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><a href=\"https://pan.baidu.com/s/14YeOQnQs7HKVHf16ngnSwA\" target=\"_blank\" rel=\"noopener\">下载地址</a><br>yum install -y mysql*<br>注：一开始一直报‘Failed to start mysqld.service: Unit not found.’<br>网上查找方法，好一通折腾，原来没安装mysql-community-server。</p>\n<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>执行</p>\n<pre><code>service mysqld start\n</code></pre><p>通过如下命令找到mysql root初始密码</p>\n<pre><code>grep &apos;temporary password&apos; /var/log/mysqld.log\n</code></pre><ul>\n<li><p>登录mysql，修改密码<br>执行</p>\n<pre><code>mysql -uroot -p\n</code></pre></li>\n</ul>\n<p>然后输入密码登录时，一直如下错误：</p>\n<pre><code>ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES)\n</code></pre><p>一般这个错误是由密码错误引起，解决的办法自然就是重置密码<br>解决方案如下：</p>\n<ol>\n<li><p>停止mysql数据库：service mysqld stop或systemctl stop mysqld</p>\n</li>\n<li><p>用以下命令启动MySQL，以不检查权限的方式启动：</p>\n</li>\n</ol>\n<p>mysqld –skip-grant-tables &amp;</p>\n<p>此时又报了一个错误：2018-02-01T02:52:55.093724Z 0 [ERROR] Fatal error: Please read “Security” section of the manual to find out how to run mysqld as root!</p>\n<p>执行命令：mysqld –user=root –skip-grant-tables &amp;</p>\n<ol start=\"3\">\n<li><p>登录mysql：service mysqld start<br>mysql -uroot或mysql</p>\n</li>\n<li><p>更新root密码</p>\n</li>\n</ol>\n<p>mysql5.7以下版本：UPDATE mysql.user SET Password=PASSWORD(‘123456’) where USER=’root’;</p>\n<p>mysql5.7版本：UPDATE mysql.user SET authentication_string=PASSWORD(‘123456’) where USER=’root’;</p>\n<p>5.刷新权限：flush privileges;</p>\n<p>6.退出mysql：exit或quit</p>\n<p>7.使用root用户重新登录mysql</p>\n<p>mysql -uroot -p</p>\n<p>Enter password:&lt;输入新设的密码123456&gt;</p>\n"},{"title":"centos7配置网关","comments":1,"date":"2018-08-02T09:37:29.000Z","_content":"### 起源\n搭建虚拟机并配置centos7之后，在主机终端采用ssh root@192.168.131.141方式连接虚拟机，\n当访问公司内网，执行curl http://###下载资源，下载失败，错误显示'### port 443: \"拒绝连接\"',\n\n### 配置网关\n一开始以为没配置网关，所以网上搜索了网关的配置方法，记录一下：\n\n1、CentOS 修改DNS \n\n修改对应网卡的DNS的配置文件 \n\n    # vi /etc/resolv.conf  \n修改以下内容 \n\n    nameserver 8.8.8.8 #google域名服务器 \n    nameserver 8.8.4.4 #google域名服务器 \n2、CentOS 修改网关  \n修改对应网卡的网关的配置文件 \n\n    [root@centos]# vi /etc/sysconfig/network \n\n修改以下内容 \nNETWORKING=yes(表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动) \nHOSTNAME=centos(设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应) \nGATEWAY=192.168.1.1(设置本机连接的网关的IP地址。例如，网关为10.0.0.2) \n3、CentOS 修改IP地址 \n\n修改对应网卡的IP地址的配置文件\n注：查看/etc/sysconfig/network-scripts下，是否已经有网卡位置文件，一个和使用ip addr命令查看ip第二条开头的名称一致的文件（我的是ens33）\n\n    # vi /etc/sysconfig/network-scripts/ifcfg-eth0 \n\n修改以下内容 \n\n    TYPE=Ethernet\n    PROXY_METHOD=none\n    BROWSER_ONLY=no\n    BOOTPROTO=static\n    DEFROUTE=yes\n    IPV4_FAILURE_FATAL=no\n    IPV6INIT=yes\n    IPV6_AUTOCONF=yes\n    IPV6_DEFROUTE=yes\n    IPV6_FAILURE_FATAL=no\n    IPV6_ADDR_GEN_MODE=stable-privacy\n    NAME=ens33\n    UUID=bfef954d-eca2-4096-947f-8c6faf5e44b0\n    DEVICE=ens33\n    ONBOOT=yes\n    IPADDR=192.168.131.141\n    GATEWAY=192.168.131.2\n    NETMAK=255.255.255.0\n    NM_COTROLLED=no\n    DNS1=8.8.8.8 \n4、重新启动网络配置 \n\n    # service network restart  \n或 \n\n    # /etc/init.d/network restart \n\n### 解决问题\n请教高人才发现时时DNS写错了，与公司的dns不一致，\n执行vi /etc/resolv.conf ，添加nameserver 192.168.1.254之后成功\n\n","source":"_posts/centos7配置网关.md","raw":"---\ntitle: centos7配置网关\ntags:\n  - centos\n  - linux\n  - 443\n  - 后端\ncategories:\n  - 后端\ncomments: false    // 是否开启评论\ndate: 2018-08-02 17:37:29\n---\n### 起源\n搭建虚拟机并配置centos7之后，在主机终端采用ssh root@192.168.131.141方式连接虚拟机，\n当访问公司内网，执行curl http://###下载资源，下载失败，错误显示'### port 443: \"拒绝连接\"',\n\n### 配置网关\n一开始以为没配置网关，所以网上搜索了网关的配置方法，记录一下：\n\n1、CentOS 修改DNS \n\n修改对应网卡的DNS的配置文件 \n\n    # vi /etc/resolv.conf  \n修改以下内容 \n\n    nameserver 8.8.8.8 #google域名服务器 \n    nameserver 8.8.4.4 #google域名服务器 \n2、CentOS 修改网关  \n修改对应网卡的网关的配置文件 \n\n    [root@centos]# vi /etc/sysconfig/network \n\n修改以下内容 \nNETWORKING=yes(表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动) \nHOSTNAME=centos(设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应) \nGATEWAY=192.168.1.1(设置本机连接的网关的IP地址。例如，网关为10.0.0.2) \n3、CentOS 修改IP地址 \n\n修改对应网卡的IP地址的配置文件\n注：查看/etc/sysconfig/network-scripts下，是否已经有网卡位置文件，一个和使用ip addr命令查看ip第二条开头的名称一致的文件（我的是ens33）\n\n    # vi /etc/sysconfig/network-scripts/ifcfg-eth0 \n\n修改以下内容 \n\n    TYPE=Ethernet\n    PROXY_METHOD=none\n    BROWSER_ONLY=no\n    BOOTPROTO=static\n    DEFROUTE=yes\n    IPV4_FAILURE_FATAL=no\n    IPV6INIT=yes\n    IPV6_AUTOCONF=yes\n    IPV6_DEFROUTE=yes\n    IPV6_FAILURE_FATAL=no\n    IPV6_ADDR_GEN_MODE=stable-privacy\n    NAME=ens33\n    UUID=bfef954d-eca2-4096-947f-8c6faf5e44b0\n    DEVICE=ens33\n    ONBOOT=yes\n    IPADDR=192.168.131.141\n    GATEWAY=192.168.131.2\n    NETMAK=255.255.255.0\n    NM_COTROLLED=no\n    DNS1=8.8.8.8 \n4、重新启动网络配置 \n\n    # service network restart  \n或 \n\n    # /etc/init.d/network restart \n\n### 解决问题\n请教高人才发现时时DNS写错了，与公司的dns不一致，\n执行vi /etc/resolv.conf ，添加nameserver 192.168.1.254之后成功\n\n","slug":"centos7配置网关","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiio000ry0w0udq5slsv","content":"<h3 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h3><p>搭建虚拟机并配置centos7之后，在主机终端采用ssh <a href=\"mailto:root@192.168.131.141\" target=\"_blank\" rel=\"noopener\">root@192.168.131.141</a>方式连接虚拟机，<br>当访问公司内网，执行curl http://###下载资源，下载失败，错误显示’### port 443: “拒绝连接”‘,</p>\n<h3 id=\"配置网关\"><a href=\"#配置网关\" class=\"headerlink\" title=\"配置网关\"></a>配置网关</h3><p>一开始以为没配置网关，所以网上搜索了网关的配置方法，记录一下：</p>\n<p>1、CentOS 修改DNS </p>\n<p>修改对应网卡的DNS的配置文件 </p>\n<pre><code># vi /etc/resolv.conf  \n</code></pre><p>修改以下内容 </p>\n<pre><code>nameserver 8.8.8.8 #google域名服务器 \nnameserver 8.8.4.4 #google域名服务器 \n</code></pre><p>2、CentOS 修改网关<br>修改对应网卡的网关的配置文件 </p>\n<pre><code>[root@centos]# vi /etc/sysconfig/network \n</code></pre><p>修改以下内容<br>NETWORKING=yes(表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动)<br>HOSTNAME=centos(设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应)<br>GATEWAY=192.168.1.1(设置本机连接的网关的IP地址。例如，网关为10.0.0.2)<br>3、CentOS 修改IP地址 </p>\n<p>修改对应网卡的IP地址的配置文件<br>注：查看/etc/sysconfig/network-scripts下，是否已经有网卡位置文件，一个和使用ip addr命令查看ip第二条开头的名称一致的文件（我的是ens33）</p>\n<pre><code># vi /etc/sysconfig/network-scripts/ifcfg-eth0 \n</code></pre><p>修改以下内容 </p>\n<pre><code>TYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=static\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=ens33\nUUID=bfef954d-eca2-4096-947f-8c6faf5e44b0\nDEVICE=ens33\nONBOOT=yes\nIPADDR=192.168.131.141\nGATEWAY=192.168.131.2\nNETMAK=255.255.255.0\nNM_COTROLLED=no\nDNS1=8.8.8.8 \n</code></pre><p>4、重新启动网络配置 </p>\n<pre><code># service network restart  \n</code></pre><p>或 </p>\n<pre><code># /etc/init.d/network restart \n</code></pre><h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>请教高人才发现时时DNS写错了，与公司的dns不一致，<br>执行vi /etc/resolv.conf ，添加nameserver 192.168.1.254之后成功</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h3><p>搭建虚拟机并配置centos7之后，在主机终端采用ssh <a href=\"mailto:root@192.168.131.141\" target=\"_blank\" rel=\"noopener\">root@192.168.131.141</a>方式连接虚拟机，<br>当访问公司内网，执行curl http://###下载资源，下载失败，错误显示’### port 443: “拒绝连接”‘,</p>\n<h3 id=\"配置网关\"><a href=\"#配置网关\" class=\"headerlink\" title=\"配置网关\"></a>配置网关</h3><p>一开始以为没配置网关，所以网上搜索了网关的配置方法，记录一下：</p>\n<p>1、CentOS 修改DNS </p>\n<p>修改对应网卡的DNS的配置文件 </p>\n<pre><code># vi /etc/resolv.conf  \n</code></pre><p>修改以下内容 </p>\n<pre><code>nameserver 8.8.8.8 #google域名服务器 \nnameserver 8.8.4.4 #google域名服务器 \n</code></pre><p>2、CentOS 修改网关<br>修改对应网卡的网关的配置文件 </p>\n<pre><code>[root@centos]# vi /etc/sysconfig/network \n</code></pre><p>修改以下内容<br>NETWORKING=yes(表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动)<br>HOSTNAME=centos(设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应)<br>GATEWAY=192.168.1.1(设置本机连接的网关的IP地址。例如，网关为10.0.0.2)<br>3、CentOS 修改IP地址 </p>\n<p>修改对应网卡的IP地址的配置文件<br>注：查看/etc/sysconfig/network-scripts下，是否已经有网卡位置文件，一个和使用ip addr命令查看ip第二条开头的名称一致的文件（我的是ens33）</p>\n<pre><code># vi /etc/sysconfig/network-scripts/ifcfg-eth0 \n</code></pre><p>修改以下内容 </p>\n<pre><code>TYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=static\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=ens33\nUUID=bfef954d-eca2-4096-947f-8c6faf5e44b0\nDEVICE=ens33\nONBOOT=yes\nIPADDR=192.168.131.141\nGATEWAY=192.168.131.2\nNETMAK=255.255.255.0\nNM_COTROLLED=no\nDNS1=8.8.8.8 \n</code></pre><p>4、重新启动网络配置 </p>\n<pre><code># service network restart  \n</code></pre><p>或 </p>\n<pre><code># /etc/init.d/network restart \n</code></pre><h3 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h3><p>请教高人才发现时时DNS写错了，与公司的dns不一致，<br>执行vi /etc/resolv.conf ，添加nameserver 192.168.1.254之后成功</p>\n"},{"title":"charles+android监听websocket","comments":1,"date":"2018-07-24T07:41:57.000Z","_content":"### 设备环境\ncharles版本4.0.1\n\n小米6 android 8.0.0\n\n### 安装证书\n1. 按照Charles的提示，手机打开 chls.pro/ssl\n2. 小米通过UC浏览器下载得到一个 charles-proxy-ssl-proxying-certificate.pem 证书\n3. 设置 > 更多设置(系统和设备) > 系统安全 > 安装位置应用>文件管理\n\n注：小米通过自带浏览器（QQ浏览器或者其它浏览器未测）下载得到一个 getssl.crt 证书，安装不成功\n\n### charles监听安卓websocket\n3.11版本之后，开始支持websocket抓取，\n不知道什么原因，使用上面wifi代理配置，无法抓取到websocket请求，查了很多文章都没有成功，最后，看到一句话：有些协议不会经过wifi代理，\n\n于是借助drony，设置步骤：\n进入setting选项卡，选择Wi-Fi：\n![](charles-android监听websocket/wifi.png)\n找到使用的网络名，点进去设置，设置为charles的地址地址和端口：\n![](charles-android监听websocket/networkdetails.png)\n修改系統代理設定\nWIFI代理設定, 進入你連接的WIFI網絡的內容:\n![](charles-android监听websocket/wlan.png)\n![](charles-android监听websocket/homewifi.png)\n","source":"_posts/charles-android监听websocket.md","raw":"---\ntitle: charles+android监听websocket\ntags:\n  - charles\n  - android\ncategories:\n  - 工具\ncomments: false    // 是否开启评论\ndate: 2018-07-24 15:41:57\n---\n### 设备环境\ncharles版本4.0.1\n\n小米6 android 8.0.0\n\n### 安装证书\n1. 按照Charles的提示，手机打开 chls.pro/ssl\n2. 小米通过UC浏览器下载得到一个 charles-proxy-ssl-proxying-certificate.pem 证书\n3. 设置 > 更多设置(系统和设备) > 系统安全 > 安装位置应用>文件管理\n\n注：小米通过自带浏览器（QQ浏览器或者其它浏览器未测）下载得到一个 getssl.crt 证书，安装不成功\n\n### charles监听安卓websocket\n3.11版本之后，开始支持websocket抓取，\n不知道什么原因，使用上面wifi代理配置，无法抓取到websocket请求，查了很多文章都没有成功，最后，看到一句话：有些协议不会经过wifi代理，\n\n于是借助drony，设置步骤：\n进入setting选项卡，选择Wi-Fi：\n![](charles-android监听websocket/wifi.png)\n找到使用的网络名，点进去设置，设置为charles的地址地址和端口：\n![](charles-android监听websocket/networkdetails.png)\n修改系統代理設定\nWIFI代理設定, 進入你連接的WIFI網絡的內容:\n![](charles-android监听websocket/wlan.png)\n![](charles-android监听websocket/homewifi.png)\n","slug":"charles-android监听websocket","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiio000sy0w0vd1o8ws0","content":"<h3 id=\"设备环境\"><a href=\"#设备环境\" class=\"headerlink\" title=\"设备环境\"></a>设备环境</h3><p>charles版本4.0.1</p>\n<p>小米6 android 8.0.0</p>\n<h3 id=\"安装证书\"><a href=\"#安装证书\" class=\"headerlink\" title=\"安装证书\"></a>安装证书</h3><ol>\n<li>按照Charles的提示，手机打开 chls.pro/ssl</li>\n<li>小米通过UC浏览器下载得到一个 charles-proxy-ssl-proxying-certificate.pem 证书</li>\n<li>设置 &gt; 更多设置(系统和设备) &gt; 系统安全 &gt; 安装位置应用&gt;文件管理</li>\n</ol>\n<p>注：小米通过自带浏览器（QQ浏览器或者其它浏览器未测）下载得到一个 getssl.crt 证书，安装不成功</p>\n<h3 id=\"charles监听安卓websocket\"><a href=\"#charles监听安卓websocket\" class=\"headerlink\" title=\"charles监听安卓websocket\"></a>charles监听安卓websocket</h3><p>3.11版本之后，开始支持websocket抓取，<br>不知道什么原因，使用上面wifi代理配置，无法抓取到websocket请求，查了很多文章都没有成功，最后，看到一句话：有些协议不会经过wifi代理，</p>\n<p>于是借助drony，设置步骤：<br>进入setting选项卡，选择Wi-Fi：<br><img src=\"charles-android监听websocket/wifi.png\" alt=\"\"><br>找到使用的网络名，点进去设置，设置为charles的地址地址和端口：<br><img src=\"charles-android监听websocket/networkdetails.png\" alt=\"\"><br>修改系統代理設定<br>WIFI代理設定, 進入你連接的WIFI網絡的內容:<br><img src=\"charles-android监听websocket/wlan.png\" alt=\"\"><br><img src=\"charles-android监听websocket/homewifi.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"设备环境\"><a href=\"#设备环境\" class=\"headerlink\" title=\"设备环境\"></a>设备环境</h3><p>charles版本4.0.1</p>\n<p>小米6 android 8.0.0</p>\n<h3 id=\"安装证书\"><a href=\"#安装证书\" class=\"headerlink\" title=\"安装证书\"></a>安装证书</h3><ol>\n<li>按照Charles的提示，手机打开 chls.pro/ssl</li>\n<li>小米通过UC浏览器下载得到一个 charles-proxy-ssl-proxying-certificate.pem 证书</li>\n<li>设置 &gt; 更多设置(系统和设备) &gt; 系统安全 &gt; 安装位置应用&gt;文件管理</li>\n</ol>\n<p>注：小米通过自带浏览器（QQ浏览器或者其它浏览器未测）下载得到一个 getssl.crt 证书，安装不成功</p>\n<h3 id=\"charles监听安卓websocket\"><a href=\"#charles监听安卓websocket\" class=\"headerlink\" title=\"charles监听安卓websocket\"></a>charles监听安卓websocket</h3><p>3.11版本之后，开始支持websocket抓取，<br>不知道什么原因，使用上面wifi代理配置，无法抓取到websocket请求，查了很多文章都没有成功，最后，看到一句话：有些协议不会经过wifi代理，</p>\n<p>于是借助drony，设置步骤：<br>进入setting选项卡，选择Wi-Fi：<br><img src=\"charles-android监听websocket/wifi.png\" alt=\"\"><br>找到使用的网络名，点进去设置，设置为charles的地址地址和端口：<br><img src=\"charles-android监听websocket/networkdetails.png\" alt=\"\"><br>修改系統代理設定<br>WIFI代理設定, 進入你連接的WIFI網絡的內容:<br><img src=\"charles-android监听websocket/wlan.png\" alt=\"\"><br><img src=\"charles-android监听websocket/homewifi.png\" alt=\"\"></p>\n"},{"title":"django","comments":1,"date":"2018-08-17T03:54:16.000Z","_content":"\n## 开启新项目\n#### 创建项目\n\ncd 到一个你想放置你代码的目录，然后运行以下命令：\n\n    $ django-admin startproject mysite\n运行：\n\n    $ python manage.py runserver\n更换端口：\n\n    $ python manage.py runserver 8080\n#### 创建应用\n应用是一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者简单的投票程序。项目则是一个网站使用的配置和应用的集合。项目可以包含很多个应用。应用可以被很多个项目使用。\n\nmanage.py 所在的目录下，运行命令\n\n    $ python manage.py startapp polls\n\n## 编写视图\n在 polls 目录里新建一个 urls.py 文件，输入如下代码：\n\n    from django.urls import path\n    \n    from . import views\n    \n    urlpatterns = [\n        path('', views.index, name='index'),\n    ]\n下一步是要在根 URLconf 文件中指定我们创建的 polls.urls 模块。在 mysite/urls.py 文件的 urlpatterns 列表里插入一个 include()， 如下：\n\n    from django.contrib import admin\n    from django.urls import include, path\n    \n    urlpatterns = [\n        path('polls/', include('polls.urls')),\n        path('admin/', admin.site.urls),\n    ]\n#### path() 参数\n- route\n    \nroute 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。\n\n这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。\n\n- view\n\n当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。\n\n-  kwargs\n\n任意个关键字参数可以作为一个字典传递给目标视图函数。\n\n- name\n\n为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。\n\n## 数据库配置\n打开 mysite/settings.py，这个配置文件通常使用 SQLite 作为默认数据库。\n\n如果想使用其他数据库，需要安装合适的[database bindings](https://docs.djangoproject.com/zh-hans/2.1/topics/install/#database-installation)，然后改变设置文件中 DATABASES 'default' 项目中的一些键值：\n           \n- ENGINE \n\n可选值有'django.db.backends.sqlite3'，'django.db.backends.postgresql'，'django.db.backends.mysql'，\n或 'django.db.backends.oracle'。其它 可用后端。\n\n- NAME - 数据库的名称。\n\n如果使用的是SQLite，数据库将是你电脑上的一个文件，在这种情况下， NAME 应该是此文件的绝对路径，包括文件名。\n默认值 os.path.join(BASE_DIR, 'db.sqlite3') 将会把数据库文件储存在项目的根目录。\n\n如果你不使用 SQLite，则必须添加一些额外设置，比如 USER 、 PASSWORD 、 HOST 等等。\n想了解更多数据库设置方面的内容，请看文档：[DATABASES](https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-DATABASES) 。\n\n## 创建模型\n\n模型 - 也就是数据库结构设计和附加的其它元数据。\n\n    from django.db import models\n    \n    \n    class Question(models.Model):\n        question_text = models.CharField(max_length=200)\n        pub_date = models.DateTimeField('date published')\n    \n    \n    class Choice(models.Model):\n        question = models.ForeignKey(Question, on_delete=models.CASCADE)\n        choice_text = models.CharField(max_length=200)\n        votes = models.IntegerField(default=0)\n\n## 激活模型\n\n上面的一小段用于创建模型的代码,Django 可以：\n- 为这个应用创建数据库 schema（生成 CREATE TABLE 语句）。\n\n- 创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API。\n\n但是首先得把 polls 应用安装到项目里。\n\n因为 PollsConfig 类写在文件 polls/apps.py 中，所以它的点式路径是 'polls.apps.PollsConfig'。\n在文件 mysite/settings.py 中 INSTALLED_APPS 子项添加点式路径后，它看起来像这样：\n\n    INSTALLED_APPS = [\n        'polls.apps.PollsConfig',\n        'django.contrib.admin',\n        'django.contrib.auth',\n        'django.contrib.contenttypes',\n        'django.contrib.sessions',\n        'django.contrib.messages',\n        'django.contrib.staticfiles',\n    ]\n现在你的 Django 项目会包含 polls 应用。接着运行下面的命令：\n\n    python manage.py makemigrations polls\n    \n\n## 写一个真正有用的视图\n每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 HttpResponse 对象，或者抛出一个异常，比如 Http404 。\n\n首先，在 polls 目录里创建一个 templates 目录。Django 将会在这个目录里查找模板文件。\n\n默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS 设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS \n文件夹中寻找 \"templates\" 子目录。\n\n在刚刚创建的 templates 目录里，再创建一个目录 polls，然后在其中新建一个文件 index.html 。\n换句话说，你的模板文件的路径应该是 polls/templates/polls/index.html 。因为 Django 会寻找到对应的 app_directories ，\n所以你只需要使用 polls/index.html 就可以引用到这一模板了。\n\n\n## 自定义 应用 的界面和风格\n\n首先，在你的 polls 目录下创建一个名为 static 的目录。\n将以下代码放入样式表(polls/static/polls/style.css)：\n\n    li a {\n        color: green;\n    }\n下一步，在 polls/templates/polls/index.html 的文件头添加以下内容：\n\n    {% load static %}\n    \n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{% static 'polls/style.css' %}\">\n    {% static %} 模板标签会生成静态文件的绝对路径。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/django.md","raw":"---\ntitle: django\ntags:\n  - Python\n  - django\ncategories:\n  - 前端\ncomments: false    // 是否开启评论\ndate: 2018-08-17 11:54:16\n---\n\n## 开启新项目\n#### 创建项目\n\ncd 到一个你想放置你代码的目录，然后运行以下命令：\n\n    $ django-admin startproject mysite\n运行：\n\n    $ python manage.py runserver\n更换端口：\n\n    $ python manage.py runserver 8080\n#### 创建应用\n应用是一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者简单的投票程序。项目则是一个网站使用的配置和应用的集合。项目可以包含很多个应用。应用可以被很多个项目使用。\n\nmanage.py 所在的目录下，运行命令\n\n    $ python manage.py startapp polls\n\n## 编写视图\n在 polls 目录里新建一个 urls.py 文件，输入如下代码：\n\n    from django.urls import path\n    \n    from . import views\n    \n    urlpatterns = [\n        path('', views.index, name='index'),\n    ]\n下一步是要在根 URLconf 文件中指定我们创建的 polls.urls 模块。在 mysite/urls.py 文件的 urlpatterns 列表里插入一个 include()， 如下：\n\n    from django.contrib import admin\n    from django.urls import include, path\n    \n    urlpatterns = [\n        path('polls/', include('polls.urls')),\n        path('admin/', admin.site.urls),\n    ]\n#### path() 参数\n- route\n    \nroute 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。\n\n这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。\n\n- view\n\n当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。\n\n-  kwargs\n\n任意个关键字参数可以作为一个字典传递给目标视图函数。\n\n- name\n\n为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。\n\n## 数据库配置\n打开 mysite/settings.py，这个配置文件通常使用 SQLite 作为默认数据库。\n\n如果想使用其他数据库，需要安装合适的[database bindings](https://docs.djangoproject.com/zh-hans/2.1/topics/install/#database-installation)，然后改变设置文件中 DATABASES 'default' 项目中的一些键值：\n           \n- ENGINE \n\n可选值有'django.db.backends.sqlite3'，'django.db.backends.postgresql'，'django.db.backends.mysql'，\n或 'django.db.backends.oracle'。其它 可用后端。\n\n- NAME - 数据库的名称。\n\n如果使用的是SQLite，数据库将是你电脑上的一个文件，在这种情况下， NAME 应该是此文件的绝对路径，包括文件名。\n默认值 os.path.join(BASE_DIR, 'db.sqlite3') 将会把数据库文件储存在项目的根目录。\n\n如果你不使用 SQLite，则必须添加一些额外设置，比如 USER 、 PASSWORD 、 HOST 等等。\n想了解更多数据库设置方面的内容，请看文档：[DATABASES](https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-DATABASES) 。\n\n## 创建模型\n\n模型 - 也就是数据库结构设计和附加的其它元数据。\n\n    from django.db import models\n    \n    \n    class Question(models.Model):\n        question_text = models.CharField(max_length=200)\n        pub_date = models.DateTimeField('date published')\n    \n    \n    class Choice(models.Model):\n        question = models.ForeignKey(Question, on_delete=models.CASCADE)\n        choice_text = models.CharField(max_length=200)\n        votes = models.IntegerField(default=0)\n\n## 激活模型\n\n上面的一小段用于创建模型的代码,Django 可以：\n- 为这个应用创建数据库 schema（生成 CREATE TABLE 语句）。\n\n- 创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API。\n\n但是首先得把 polls 应用安装到项目里。\n\n因为 PollsConfig 类写在文件 polls/apps.py 中，所以它的点式路径是 'polls.apps.PollsConfig'。\n在文件 mysite/settings.py 中 INSTALLED_APPS 子项添加点式路径后，它看起来像这样：\n\n    INSTALLED_APPS = [\n        'polls.apps.PollsConfig',\n        'django.contrib.admin',\n        'django.contrib.auth',\n        'django.contrib.contenttypes',\n        'django.contrib.sessions',\n        'django.contrib.messages',\n        'django.contrib.staticfiles',\n    ]\n现在你的 Django 项目会包含 polls 应用。接着运行下面的命令：\n\n    python manage.py makemigrations polls\n    \n\n## 写一个真正有用的视图\n每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 HttpResponse 对象，或者抛出一个异常，比如 Http404 。\n\n首先，在 polls 目录里创建一个 templates 目录。Django 将会在这个目录里查找模板文件。\n\n默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS 设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS \n文件夹中寻找 \"templates\" 子目录。\n\n在刚刚创建的 templates 目录里，再创建一个目录 polls，然后在其中新建一个文件 index.html 。\n换句话说，你的模板文件的路径应该是 polls/templates/polls/index.html 。因为 Django 会寻找到对应的 app_directories ，\n所以你只需要使用 polls/index.html 就可以引用到这一模板了。\n\n\n## 自定义 应用 的界面和风格\n\n首先，在你的 polls 目录下创建一个名为 static 的目录。\n将以下代码放入样式表(polls/static/polls/style.css)：\n\n    li a {\n        color: green;\n    }\n下一步，在 polls/templates/polls/index.html 的文件头添加以下内容：\n\n    {% load static %}\n    \n    <link rel=\"stylesheet\" type=\"text/css\" href=\"{% static 'polls/style.css' %}\">\n    {% static %} 模板标签会生成静态文件的绝对路径。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"django","published":1,"updated":"2019-01-09T09:50:41.384Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiiq000vy0w05g0bh89x","content":"<h2 id=\"开启新项目\"><a href=\"#开启新项目\" class=\"headerlink\" title=\"开启新项目\"></a>开启新项目</h2><h4 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h4><p>cd 到一个你想放置你代码的目录，然后运行以下命令：</p>\n<pre><code>$ django-admin startproject mysite\n</code></pre><p>运行：</p>\n<pre><code>$ python manage.py runserver\n</code></pre><p>更换端口：</p>\n<pre><code>$ python manage.py runserver 8080\n</code></pre><h4 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h4><p>应用是一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者简单的投票程序。项目则是一个网站使用的配置和应用的集合。项目可以包含很多个应用。应用可以被很多个项目使用。</p>\n<p>manage.py 所在的目录下，运行命令</p>\n<pre><code>$ python manage.py startapp polls\n</code></pre><h2 id=\"编写视图\"><a href=\"#编写视图\" class=\"headerlink\" title=\"编写视图\"></a>编写视图</h2><p>在 polls 目录里新建一个 urls.py 文件，输入如下代码：</p>\n<pre><code>from django.urls import path\n\nfrom . import views\n\nurlpatterns = [\n    path(&apos;&apos;, views.index, name=&apos;index&apos;),\n]\n</code></pre><p>下一步是要在根 URLconf 文件中指定我们创建的 polls.urls 模块。在 mysite/urls.py 文件的 urlpatterns 列表里插入一个 include()， 如下：</p>\n<pre><code>from django.contrib import admin\nfrom django.urls import include, path\n\nurlpatterns = [\n    path(&apos;polls/&apos;, include(&apos;polls.urls&apos;)),\n    path(&apos;admin/&apos;, admin.site.urls),\n]\n</code></pre><h4 id=\"path-参数\"><a href=\"#path-参数\" class=\"headerlink\" title=\"path() 参数\"></a>path() 参数</h4><ul>\n<li>route</li>\n</ul>\n<p>route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。</p>\n<p>这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 <a href=\"https://www.example.com/myapp/\" target=\"_blank\" rel=\"noopener\">https://www.example.com/myapp/</a> 时，它会尝试匹配 myapp/ 。处理请求 <a href=\"https://www.example.com/myapp/?page=3\" target=\"_blank\" rel=\"noopener\">https://www.example.com/myapp/?page=3</a> 时，也只会尝试匹配 myapp/。</p>\n<ul>\n<li>view</li>\n</ul>\n<p>当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。</p>\n<ul>\n<li>kwargs</li>\n</ul>\n<p>任意个关键字参数可以作为一个字典传递给目标视图函数。</p>\n<ul>\n<li>name</li>\n</ul>\n<p>为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。</p>\n<h2 id=\"数据库配置\"><a href=\"#数据库配置\" class=\"headerlink\" title=\"数据库配置\"></a>数据库配置</h2><p>打开 mysite/settings.py，这个配置文件通常使用 SQLite 作为默认数据库。</p>\n<p>如果想使用其他数据库，需要安装合适的<a href=\"https://docs.djangoproject.com/zh-hans/2.1/topics/install/#database-installation\" target=\"_blank\" rel=\"noopener\">database bindings</a>，然后改变设置文件中 DATABASES ‘default’ 项目中的一些键值：</p>\n<ul>\n<li>ENGINE </li>\n</ul>\n<p>可选值有’django.db.backends.sqlite3’，’django.db.backends.postgresql’，’django.db.backends.mysql’，<br>或 ‘django.db.backends.oracle’。其它 可用后端。</p>\n<ul>\n<li>NAME - 数据库的名称。</li>\n</ul>\n<p>如果使用的是SQLite，数据库将是你电脑上的一个文件，在这种情况下， NAME 应该是此文件的绝对路径，包括文件名。<br>默认值 os.path.join(BASE_DIR, ‘db.sqlite3’) 将会把数据库文件储存在项目的根目录。</p>\n<p>如果你不使用 SQLite，则必须添加一些额外设置，比如 USER 、 PASSWORD 、 HOST 等等。<br>想了解更多数据库设置方面的内容，请看文档：<a href=\"https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-DATABASES\" target=\"_blank\" rel=\"noopener\">DATABASES</a> 。</p>\n<h2 id=\"创建模型\"><a href=\"#创建模型\" class=\"headerlink\" title=\"创建模型\"></a>创建模型</h2><p>模型 - 也就是数据库结构设计和附加的其它元数据。</p>\n<pre><code>from django.db import models\n\n\nclass Question(models.Model):\n    question_text = models.CharField(max_length=200)\n    pub_date = models.DateTimeField(&apos;date published&apos;)\n\n\nclass Choice(models.Model):\n    question = models.ForeignKey(Question, on_delete=models.CASCADE)\n    choice_text = models.CharField(max_length=200)\n    votes = models.IntegerField(default=0)\n</code></pre><h2 id=\"激活模型\"><a href=\"#激活模型\" class=\"headerlink\" title=\"激活模型\"></a>激活模型</h2><p>上面的一小段用于创建模型的代码,Django 可以：</p>\n<ul>\n<li><p>为这个应用创建数据库 schema（生成 CREATE TABLE 语句）。</p>\n</li>\n<li><p>创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API。</p>\n</li>\n</ul>\n<p>但是首先得把 polls 应用安装到项目里。</p>\n<p>因为 PollsConfig 类写在文件 polls/apps.py 中，所以它的点式路径是 ‘polls.apps.PollsConfig’。<br>在文件 mysite/settings.py 中 INSTALLED_APPS 子项添加点式路径后，它看起来像这样：</p>\n<pre><code>INSTALLED_APPS = [\n    &apos;polls.apps.PollsConfig&apos;,\n    &apos;django.contrib.admin&apos;,\n    &apos;django.contrib.auth&apos;,\n    &apos;django.contrib.contenttypes&apos;,\n    &apos;django.contrib.sessions&apos;,\n    &apos;django.contrib.messages&apos;,\n    &apos;django.contrib.staticfiles&apos;,\n]\n</code></pre><p>现在你的 Django 项目会包含 polls 应用。接着运行下面的命令：</p>\n<pre><code>python manage.py makemigrations polls\n</code></pre><h2 id=\"写一个真正有用的视图\"><a href=\"#写一个真正有用的视图\" class=\"headerlink\" title=\"写一个真正有用的视图\"></a>写一个真正有用的视图</h2><p>每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 HttpResponse 对象，或者抛出一个异常，比如 Http404 。</p>\n<p>首先，在 polls 目录里创建一个 templates 目录。Django 将会在这个目录里查找模板文件。</p>\n<p>默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS 设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS<br>文件夹中寻找 “templates” 子目录。</p>\n<p>在刚刚创建的 templates 目录里，再创建一个目录 polls，然后在其中新建一个文件 index.html 。<br>换句话说，你的模板文件的路径应该是 polls/templates/polls/index.html 。因为 Django 会寻找到对应的 app_directories ，<br>所以你只需要使用 polls/index.html 就可以引用到这一模板了。</p>\n<h2 id=\"自定义-应用-的界面和风格\"><a href=\"#自定义-应用-的界面和风格\" class=\"headerlink\" title=\"自定义 应用 的界面和风格\"></a>自定义 应用 的界面和风格</h2><p>首先，在你的 polls 目录下创建一个名为 static 的目录。<br>将以下代码放入样式表(polls/static/polls/style.css)：</p>\n<pre><code>li a {\n    color: green;\n}\n</code></pre><p>下一步，在 polls/templates/polls/index.html 的文件头添加以下内容：</p>\n<pre><code>{% load static %}\n\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{% static 'polls/style.css' %}&quot;&gt;\n{% static %} 模板标签会生成静态文件的绝对路径。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"开启新项目\"><a href=\"#开启新项目\" class=\"headerlink\" title=\"开启新项目\"></a>开启新项目</h2><h4 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h4><p>cd 到一个你想放置你代码的目录，然后运行以下命令：</p>\n<pre><code>$ django-admin startproject mysite\n</code></pre><p>运行：</p>\n<pre><code>$ python manage.py runserver\n</code></pre><p>更换端口：</p>\n<pre><code>$ python manage.py runserver 8080\n</code></pre><h4 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h4><p>应用是一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者简单的投票程序。项目则是一个网站使用的配置和应用的集合。项目可以包含很多个应用。应用可以被很多个项目使用。</p>\n<p>manage.py 所在的目录下，运行命令</p>\n<pre><code>$ python manage.py startapp polls\n</code></pre><h2 id=\"编写视图\"><a href=\"#编写视图\" class=\"headerlink\" title=\"编写视图\"></a>编写视图</h2><p>在 polls 目录里新建一个 urls.py 文件，输入如下代码：</p>\n<pre><code>from django.urls import path\n\nfrom . import views\n\nurlpatterns = [\n    path(&apos;&apos;, views.index, name=&apos;index&apos;),\n]\n</code></pre><p>下一步是要在根 URLconf 文件中指定我们创建的 polls.urls 模块。在 mysite/urls.py 文件的 urlpatterns 列表里插入一个 include()， 如下：</p>\n<pre><code>from django.contrib import admin\nfrom django.urls import include, path\n\nurlpatterns = [\n    path(&apos;polls/&apos;, include(&apos;polls.urls&apos;)),\n    path(&apos;admin/&apos;, admin.site.urls),\n]\n</code></pre><h4 id=\"path-参数\"><a href=\"#path-参数\" class=\"headerlink\" title=\"path() 参数\"></a>path() 参数</h4><ul>\n<li>route</li>\n</ul>\n<p>route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。</p>\n<p>这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 <a href=\"https://www.example.com/myapp/\" target=\"_blank\" rel=\"noopener\">https://www.example.com/myapp/</a> 时，它会尝试匹配 myapp/ 。处理请求 <a href=\"https://www.example.com/myapp/?page=3\" target=\"_blank\" rel=\"noopener\">https://www.example.com/myapp/?page=3</a> 时，也只会尝试匹配 myapp/。</p>\n<ul>\n<li>view</li>\n</ul>\n<p>当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。</p>\n<ul>\n<li>kwargs</li>\n</ul>\n<p>任意个关键字参数可以作为一个字典传递给目标视图函数。</p>\n<ul>\n<li>name</li>\n</ul>\n<p>为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。</p>\n<h2 id=\"数据库配置\"><a href=\"#数据库配置\" class=\"headerlink\" title=\"数据库配置\"></a>数据库配置</h2><p>打开 mysite/settings.py，这个配置文件通常使用 SQLite 作为默认数据库。</p>\n<p>如果想使用其他数据库，需要安装合适的<a href=\"https://docs.djangoproject.com/zh-hans/2.1/topics/install/#database-installation\" target=\"_blank\" rel=\"noopener\">database bindings</a>，然后改变设置文件中 DATABASES ‘default’ 项目中的一些键值：</p>\n<ul>\n<li>ENGINE </li>\n</ul>\n<p>可选值有’django.db.backends.sqlite3’，’django.db.backends.postgresql’，’django.db.backends.mysql’，<br>或 ‘django.db.backends.oracle’。其它 可用后端。</p>\n<ul>\n<li>NAME - 数据库的名称。</li>\n</ul>\n<p>如果使用的是SQLite，数据库将是你电脑上的一个文件，在这种情况下， NAME 应该是此文件的绝对路径，包括文件名。<br>默认值 os.path.join(BASE_DIR, ‘db.sqlite3’) 将会把数据库文件储存在项目的根目录。</p>\n<p>如果你不使用 SQLite，则必须添加一些额外设置，比如 USER 、 PASSWORD 、 HOST 等等。<br>想了解更多数据库设置方面的内容，请看文档：<a href=\"https://docs.djangoproject.com/zh-hans/2.1/ref/settings/#std:setting-DATABASES\" target=\"_blank\" rel=\"noopener\">DATABASES</a> 。</p>\n<h2 id=\"创建模型\"><a href=\"#创建模型\" class=\"headerlink\" title=\"创建模型\"></a>创建模型</h2><p>模型 - 也就是数据库结构设计和附加的其它元数据。</p>\n<pre><code>from django.db import models\n\n\nclass Question(models.Model):\n    question_text = models.CharField(max_length=200)\n    pub_date = models.DateTimeField(&apos;date published&apos;)\n\n\nclass Choice(models.Model):\n    question = models.ForeignKey(Question, on_delete=models.CASCADE)\n    choice_text = models.CharField(max_length=200)\n    votes = models.IntegerField(default=0)\n</code></pre><h2 id=\"激活模型\"><a href=\"#激活模型\" class=\"headerlink\" title=\"激活模型\"></a>激活模型</h2><p>上面的一小段用于创建模型的代码,Django 可以：</p>\n<ul>\n<li><p>为这个应用创建数据库 schema（生成 CREATE TABLE 语句）。</p>\n</li>\n<li><p>创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API。</p>\n</li>\n</ul>\n<p>但是首先得把 polls 应用安装到项目里。</p>\n<p>因为 PollsConfig 类写在文件 polls/apps.py 中，所以它的点式路径是 ‘polls.apps.PollsConfig’。<br>在文件 mysite/settings.py 中 INSTALLED_APPS 子项添加点式路径后，它看起来像这样：</p>\n<pre><code>INSTALLED_APPS = [\n    &apos;polls.apps.PollsConfig&apos;,\n    &apos;django.contrib.admin&apos;,\n    &apos;django.contrib.auth&apos;,\n    &apos;django.contrib.contenttypes&apos;,\n    &apos;django.contrib.sessions&apos;,\n    &apos;django.contrib.messages&apos;,\n    &apos;django.contrib.staticfiles&apos;,\n]\n</code></pre><p>现在你的 Django 项目会包含 polls 应用。接着运行下面的命令：</p>\n<pre><code>python manage.py makemigrations polls\n</code></pre><h2 id=\"写一个真正有用的视图\"><a href=\"#写一个真正有用的视图\" class=\"headerlink\" title=\"写一个真正有用的视图\"></a>写一个真正有用的视图</h2><p>每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 HttpResponse 对象，或者抛出一个异常，比如 Http404 。</p>\n<p>首先，在 polls 目录里创建一个 templates 目录。Django 将会在这个目录里查找模板文件。</p>\n<p>默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS 设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS<br>文件夹中寻找 “templates” 子目录。</p>\n<p>在刚刚创建的 templates 目录里，再创建一个目录 polls，然后在其中新建一个文件 index.html 。<br>换句话说，你的模板文件的路径应该是 polls/templates/polls/index.html 。因为 Django 会寻找到对应的 app_directories ，<br>所以你只需要使用 polls/index.html 就可以引用到这一模板了。</p>\n<h2 id=\"自定义-应用-的界面和风格\"><a href=\"#自定义-应用-的界面和风格\" class=\"headerlink\" title=\"自定义 应用 的界面和风格\"></a>自定义 应用 的界面和风格</h2><p>首先，在你的 polls 目录下创建一个名为 static 的目录。<br>将以下代码放入样式表(polls/static/polls/style.css)：</p>\n<pre><code>li a {\n    color: green;\n}\n</code></pre><p>下一步，在 polls/templates/polls/index.html 的文件头添加以下内容：</p>\n<pre><code>{% load static %}\n\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{% static 'polls/style.css' %}&quot;&gt;\n{% static %} 模板标签会生成静态文件的绝对路径。\n</code></pre>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2019-01-09T09:50:41.384Z","updated":"2019-01-09T09:50:41.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjqp0aiir000zy0w0hn3z30gd","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"mac使用ssh连接远程服务器并实现文件上传下砸","comments":1,"date":"2018-08-20T10:54:41.000Z","_content":"\n### 使用ssh连接远程主机\n\n    ssh username@192.168.100.100\n    其中，username是登录用户名，@后接ip地址，点击确定之后输入密码即连接到远程主机。要查看当前有多少个处于登录状态的用户，可以使用who命令查看。\n\n### 使用scp命令实现上传下载\n\n1.从服务器上下载文件 scp username@servername:/path/filename /Users/mac/Desktop（本地目录）\n例如:\n    \n    scp root@123.207.170.40:/root/test.txt /Users/mac/Desktop就是将服务器上的/root/test.txt下载到本地的/Users/mac/Desktop目录下。注意两个地址之间有空格！\n\n2.上传本地文件到服务器 scp /path/filename username@servername:/path ;\n例如\n    \n    scp /Users/mac/Desktop/test.txt root@123.207.170.40:/root/\n\n3.从服务器下载整个目录 scp -r username@servername:/root/（远程目录） /Users/mac/Desktop（本地目录）\n例如:\n\n    scp -r root@192.168.0.101:/root/ /Users/mac/Desktop/\n\n4.上传目录到服务器 scp -r local_dir username@servername:remote_dir\n例如：\n\n    scp -r test root@192.168.0.101:/root/ 把当前目录下的test目录上传到服务器的/root/ 目录\n\n注：目标服务器要开启写入权限。\n","source":"_posts/mac使用ssh连接远程服务器并实现文件上传下砸.md","raw":"---\ntitle: mac使用ssh连接远程服务器并实现文件上传下砸\ntags:\n  - linux\ncategories:\n  - 后端\ncomments: false    // 是否开启评论\ndate: 2018-08-20 18:54:41\n---\n\n### 使用ssh连接远程主机\n\n    ssh username@192.168.100.100\n    其中，username是登录用户名，@后接ip地址，点击确定之后输入密码即连接到远程主机。要查看当前有多少个处于登录状态的用户，可以使用who命令查看。\n\n### 使用scp命令实现上传下载\n\n1.从服务器上下载文件 scp username@servername:/path/filename /Users/mac/Desktop（本地目录）\n例如:\n    \n    scp root@123.207.170.40:/root/test.txt /Users/mac/Desktop就是将服务器上的/root/test.txt下载到本地的/Users/mac/Desktop目录下。注意两个地址之间有空格！\n\n2.上传本地文件到服务器 scp /path/filename username@servername:/path ;\n例如\n    \n    scp /Users/mac/Desktop/test.txt root@123.207.170.40:/root/\n\n3.从服务器下载整个目录 scp -r username@servername:/root/（远程目录） /Users/mac/Desktop（本地目录）\n例如:\n\n    scp -r root@192.168.0.101:/root/ /Users/mac/Desktop/\n\n4.上传目录到服务器 scp -r local_dir username@servername:remote_dir\n例如：\n\n    scp -r test root@192.168.0.101:/root/ 把当前目录下的test目录上传到服务器的/root/ 目录\n\n注：目标服务器要开启写入权限。\n","slug":"mac使用ssh连接远程服务器并实现文件上传下砸","published":1,"updated":"2019-01-09T09:50:41.384Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiis0013y0w0wgvqx8mi","content":"<h3 id=\"使用ssh连接远程主机\"><a href=\"#使用ssh连接远程主机\" class=\"headerlink\" title=\"使用ssh连接远程主机\"></a>使用ssh连接远程主机</h3><pre><code>ssh username@192.168.100.100\n其中，username是登录用户名，@后接ip地址，点击确定之后输入密码即连接到远程主机。要查看当前有多少个处于登录状态的用户，可以使用who命令查看。\n</code></pre><h3 id=\"使用scp命令实现上传下载\"><a href=\"#使用scp命令实现上传下载\" class=\"headerlink\" title=\"使用scp命令实现上传下载\"></a>使用scp命令实现上传下载</h3><p>1.从服务器上下载文件 scp username@servername:/path/filename /Users/mac/Desktop（本地目录）<br>例如:</p>\n<pre><code>scp root@123.207.170.40:/root/test.txt /Users/mac/Desktop就是将服务器上的/root/test.txt下载到本地的/Users/mac/Desktop目录下。注意两个地址之间有空格！\n</code></pre><p>2.上传本地文件到服务器 scp /path/filename username@servername:/path ;<br>例如</p>\n<pre><code>scp /Users/mac/Desktop/test.txt root@123.207.170.40:/root/\n</code></pre><p>3.从服务器下载整个目录 scp -r username@servername:/root/（远程目录） /Users/mac/Desktop（本地目录）<br>例如:</p>\n<pre><code>scp -r root@192.168.0.101:/root/ /Users/mac/Desktop/\n</code></pre><p>4.上传目录到服务器 scp -r local_dir username@servername:remote_dir<br>例如：</p>\n<pre><code>scp -r test root@192.168.0.101:/root/ 把当前目录下的test目录上传到服务器的/root/ 目录\n</code></pre><p>注：目标服务器要开启写入权限。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"使用ssh连接远程主机\"><a href=\"#使用ssh连接远程主机\" class=\"headerlink\" title=\"使用ssh连接远程主机\"></a>使用ssh连接远程主机</h3><pre><code>ssh username@192.168.100.100\n其中，username是登录用户名，@后接ip地址，点击确定之后输入密码即连接到远程主机。要查看当前有多少个处于登录状态的用户，可以使用who命令查看。\n</code></pre><h3 id=\"使用scp命令实现上传下载\"><a href=\"#使用scp命令实现上传下载\" class=\"headerlink\" title=\"使用scp命令实现上传下载\"></a>使用scp命令实现上传下载</h3><p>1.从服务器上下载文件 scp username@servername:/path/filename /Users/mac/Desktop（本地目录）<br>例如:</p>\n<pre><code>scp root@123.207.170.40:/root/test.txt /Users/mac/Desktop就是将服务器上的/root/test.txt下载到本地的/Users/mac/Desktop目录下。注意两个地址之间有空格！\n</code></pre><p>2.上传本地文件到服务器 scp /path/filename username@servername:/path ;<br>例如</p>\n<pre><code>scp /Users/mac/Desktop/test.txt root@123.207.170.40:/root/\n</code></pre><p>3.从服务器下载整个目录 scp -r username@servername:/root/（远程目录） /Users/mac/Desktop（本地目录）<br>例如:</p>\n<pre><code>scp -r root@192.168.0.101:/root/ /Users/mac/Desktop/\n</code></pre><p>4.上传目录到服务器 scp -r local_dir username@servername:remote_dir<br>例如：</p>\n<pre><code>scp -r test root@192.168.0.101:/root/ 把当前目录下的test目录上传到服务器的/root/ 目录\n</code></pre><p>注：目标服务器要开启写入权限。</p>\n"},{"title":"前端UI框架","comments":1,"date":"2018-07-24T10:51:12.000Z","_content":"\n### Bootstrap\nBootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。\n\nGithub：https://github.com/twbs/bootstrap\n\n中文教程：[http://www.bootcss.com/](http://www.bootcss.com/)\n\n### Semantic-ui\n\nSemantic 是一个为主题化而设计的UI框架。主要特点：50+ UI 元素；3000 + CSS 变量；3 级变量继承(和 SublimeText 类似)；用 em 作为单位构建以实现响应式设计；Flexbox 友好。\n\n官网：https://semantic-ui.com/\n\nGithub：https://github.com/Semantic-Org/Semantic-UI\n\n### Foundation\n\nFoundation 是一个易用、强大而且灵活的框架，用于构建基于任何设备上的 Web 应用。提供多种 Web 上的 UI 组件，如表单、按钮、Tabs 等等。\n\n官网：http://foundation.zurb.com/\n\nGithub：https://github.com/zurb/foundation-sites\n\n### Iview\n\niView 主要服务于 PC 界面的中后台业务，是一套高质量的开源 UI 组件库。主要特性：使用单文件的 Vue 组件化开发模式；基于 npm + webpack + babel 开发，支持 ES2015；高质量、功能丰富；友好的 API ，自由灵活地使用空间；详细、友好的文档，事无巨细。\n\n官网：https://www.iviewui.com/\n\nGithub：https://github.com/iview/iview\n\n### Layui\n\nLayui 是一款采用自身模块规范编写的国产前端UI框架，遵循原生HTML/CSS/JS的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到API的每一处细节都经过精心雕琢，非常适合界面的快速开发。\n\n官网：http://www.layui.com/\n\nGithub：https://github.com/sentsin/layui\n\n### Frozenui\n\nFrozen UI是一个开源的简单易用，轻量快捷的移动端UI框架。基于手Q样式规范，选取最常用的组件， 做成手Q公用离线包减少请求，升级方式友好，文档完善，目前全面应用在腾讯手Q增值业务中。\n\n官网：http://frozenui.github.io\n\nGithub：https://github.com/frozenui/frozenui\n\n","source":"_posts/前端UI框架.md","raw":"---\ntitle: 前端UI框架\ntags:\n  - 前端\ncategories:\n  - 前端\ncomments: false    // 是否开启评论\ndate: 2018-07-24 18:51:12\n---\n\n### Bootstrap\nBootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。\n\nGithub：https://github.com/twbs/bootstrap\n\n中文教程：[http://www.bootcss.com/](http://www.bootcss.com/)\n\n### Semantic-ui\n\nSemantic 是一个为主题化而设计的UI框架。主要特点：50+ UI 元素；3000 + CSS 变量；3 级变量继承(和 SublimeText 类似)；用 em 作为单位构建以实现响应式设计；Flexbox 友好。\n\n官网：https://semantic-ui.com/\n\nGithub：https://github.com/Semantic-Org/Semantic-UI\n\n### Foundation\n\nFoundation 是一个易用、强大而且灵活的框架，用于构建基于任何设备上的 Web 应用。提供多种 Web 上的 UI 组件，如表单、按钮、Tabs 等等。\n\n官网：http://foundation.zurb.com/\n\nGithub：https://github.com/zurb/foundation-sites\n\n### Iview\n\niView 主要服务于 PC 界面的中后台业务，是一套高质量的开源 UI 组件库。主要特性：使用单文件的 Vue 组件化开发模式；基于 npm + webpack + babel 开发，支持 ES2015；高质量、功能丰富；友好的 API ，自由灵活地使用空间；详细、友好的文档，事无巨细。\n\n官网：https://www.iviewui.com/\n\nGithub：https://github.com/iview/iview\n\n### Layui\n\nLayui 是一款采用自身模块规范编写的国产前端UI框架，遵循原生HTML/CSS/JS的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到API的每一处细节都经过精心雕琢，非常适合界面的快速开发。\n\n官网：http://www.layui.com/\n\nGithub：https://github.com/sentsin/layui\n\n### Frozenui\n\nFrozen UI是一个开源的简单易用，轻量快捷的移动端UI框架。基于手Q样式规范，选取最常用的组件， 做成手Q公用离线包减少请求，升级方式友好，文档完善，目前全面应用在腾讯手Q增值业务中。\n\n官网：http://frozenui.github.io\n\nGithub：https://github.com/frozenui/frozenui\n\n","slug":"前端UI框架","published":1,"updated":"2019-01-09T09:50:41.384Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiit0016y0w0r2qji70l","content":"<h3 id=\"Bootstrap\"><a href=\"#Bootstrap\" class=\"headerlink\" title=\"Bootstrap\"></a>Bootstrap</h3><p>Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。</p>\n<p>Github：<a href=\"https://github.com/twbs/bootstrap\" target=\"_blank\" rel=\"noopener\">https://github.com/twbs/bootstrap</a></p>\n<p>中文教程：<a href=\"http://www.bootcss.com/\" target=\"_blank\" rel=\"noopener\">http://www.bootcss.com/</a></p>\n<h3 id=\"Semantic-ui\"><a href=\"#Semantic-ui\" class=\"headerlink\" title=\"Semantic-ui\"></a>Semantic-ui</h3><p>Semantic 是一个为主题化而设计的UI框架。主要特点：50+ UI 元素；3000 + CSS 变量；3 级变量继承(和 SublimeText 类似)；用 em 作为单位构建以实现响应式设计；Flexbox 友好。</p>\n<p>官网：<a href=\"https://semantic-ui.com/\" target=\"_blank\" rel=\"noopener\">https://semantic-ui.com/</a></p>\n<p>Github：<a href=\"https://github.com/Semantic-Org/Semantic-UI\" target=\"_blank\" rel=\"noopener\">https://github.com/Semantic-Org/Semantic-UI</a></p>\n<h3 id=\"Foundation\"><a href=\"#Foundation\" class=\"headerlink\" title=\"Foundation\"></a>Foundation</h3><p>Foundation 是一个易用、强大而且灵活的框架，用于构建基于任何设备上的 Web 应用。提供多种 Web 上的 UI 组件，如表单、按钮、Tabs 等等。</p>\n<p>官网：<a href=\"http://foundation.zurb.com/\" target=\"_blank\" rel=\"noopener\">http://foundation.zurb.com/</a></p>\n<p>Github：<a href=\"https://github.com/zurb/foundation-sites\" target=\"_blank\" rel=\"noopener\">https://github.com/zurb/foundation-sites</a></p>\n<h3 id=\"Iview\"><a href=\"#Iview\" class=\"headerlink\" title=\"Iview\"></a>Iview</h3><p>iView 主要服务于 PC 界面的中后台业务，是一套高质量的开源 UI 组件库。主要特性：使用单文件的 Vue 组件化开发模式；基于 npm + webpack + babel 开发，支持 ES2015；高质量、功能丰富；友好的 API ，自由灵活地使用空间；详细、友好的文档，事无巨细。</p>\n<p>官网：<a href=\"https://www.iviewui.com/\" target=\"_blank\" rel=\"noopener\">https://www.iviewui.com/</a></p>\n<p>Github：<a href=\"https://github.com/iview/iview\" target=\"_blank\" rel=\"noopener\">https://github.com/iview/iview</a></p>\n<h3 id=\"Layui\"><a href=\"#Layui\" class=\"headerlink\" title=\"Layui\"></a>Layui</h3><p>Layui 是一款采用自身模块规范编写的国产前端UI框架，遵循原生HTML/CSS/JS的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到API的每一处细节都经过精心雕琢，非常适合界面的快速开发。</p>\n<p>官网：<a href=\"http://www.layui.com/\" target=\"_blank\" rel=\"noopener\">http://www.layui.com/</a></p>\n<p>Github：<a href=\"https://github.com/sentsin/layui\" target=\"_blank\" rel=\"noopener\">https://github.com/sentsin/layui</a></p>\n<h3 id=\"Frozenui\"><a href=\"#Frozenui\" class=\"headerlink\" title=\"Frozenui\"></a>Frozenui</h3><p>Frozen UI是一个开源的简单易用，轻量快捷的移动端UI框架。基于手Q样式规范，选取最常用的组件， 做成手Q公用离线包减少请求，升级方式友好，文档完善，目前全面应用在腾讯手Q增值业务中。</p>\n<p>官网：<a href=\"http://frozenui.github.io\" target=\"_blank\" rel=\"noopener\">http://frozenui.github.io</a></p>\n<p>Github：<a href=\"https://github.com/frozenui/frozenui\" target=\"_blank\" rel=\"noopener\">https://github.com/frozenui/frozenui</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Bootstrap\"><a href=\"#Bootstrap\" class=\"headerlink\" title=\"Bootstrap\"></a>Bootstrap</h3><p>Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。</p>\n<p>Github：<a href=\"https://github.com/twbs/bootstrap\" target=\"_blank\" rel=\"noopener\">https://github.com/twbs/bootstrap</a></p>\n<p>中文教程：<a href=\"http://www.bootcss.com/\" target=\"_blank\" rel=\"noopener\">http://www.bootcss.com/</a></p>\n<h3 id=\"Semantic-ui\"><a href=\"#Semantic-ui\" class=\"headerlink\" title=\"Semantic-ui\"></a>Semantic-ui</h3><p>Semantic 是一个为主题化而设计的UI框架。主要特点：50+ UI 元素；3000 + CSS 变量；3 级变量继承(和 SublimeText 类似)；用 em 作为单位构建以实现响应式设计；Flexbox 友好。</p>\n<p>官网：<a href=\"https://semantic-ui.com/\" target=\"_blank\" rel=\"noopener\">https://semantic-ui.com/</a></p>\n<p>Github：<a href=\"https://github.com/Semantic-Org/Semantic-UI\" target=\"_blank\" rel=\"noopener\">https://github.com/Semantic-Org/Semantic-UI</a></p>\n<h3 id=\"Foundation\"><a href=\"#Foundation\" class=\"headerlink\" title=\"Foundation\"></a>Foundation</h3><p>Foundation 是一个易用、强大而且灵活的框架，用于构建基于任何设备上的 Web 应用。提供多种 Web 上的 UI 组件，如表单、按钮、Tabs 等等。</p>\n<p>官网：<a href=\"http://foundation.zurb.com/\" target=\"_blank\" rel=\"noopener\">http://foundation.zurb.com/</a></p>\n<p>Github：<a href=\"https://github.com/zurb/foundation-sites\" target=\"_blank\" rel=\"noopener\">https://github.com/zurb/foundation-sites</a></p>\n<h3 id=\"Iview\"><a href=\"#Iview\" class=\"headerlink\" title=\"Iview\"></a>Iview</h3><p>iView 主要服务于 PC 界面的中后台业务，是一套高质量的开源 UI 组件库。主要特性：使用单文件的 Vue 组件化开发模式；基于 npm + webpack + babel 开发，支持 ES2015；高质量、功能丰富；友好的 API ，自由灵活地使用空间；详细、友好的文档，事无巨细。</p>\n<p>官网：<a href=\"https://www.iviewui.com/\" target=\"_blank\" rel=\"noopener\">https://www.iviewui.com/</a></p>\n<p>Github：<a href=\"https://github.com/iview/iview\" target=\"_blank\" rel=\"noopener\">https://github.com/iview/iview</a></p>\n<h3 id=\"Layui\"><a href=\"#Layui\" class=\"headerlink\" title=\"Layui\"></a>Layui</h3><p>Layui 是一款采用自身模块规范编写的国产前端UI框架，遵循原生HTML/CSS/JS的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到API的每一处细节都经过精心雕琢，非常适合界面的快速开发。</p>\n<p>官网：<a href=\"http://www.layui.com/\" target=\"_blank\" rel=\"noopener\">http://www.layui.com/</a></p>\n<p>Github：<a href=\"https://github.com/sentsin/layui\" target=\"_blank\" rel=\"noopener\">https://github.com/sentsin/layui</a></p>\n<h3 id=\"Frozenui\"><a href=\"#Frozenui\" class=\"headerlink\" title=\"Frozenui\"></a>Frozenui</h3><p>Frozen UI是一个开源的简单易用，轻量快捷的移动端UI框架。基于手Q样式规范，选取最常用的组件， 做成手Q公用离线包减少请求，升级方式友好，文档完善，目前全面应用在腾讯手Q增值业务中。</p>\n<p>官网：<a href=\"http://frozenui.github.io\" target=\"_blank\" rel=\"noopener\">http://frozenui.github.io</a></p>\n<p>Github：<a href=\"https://github.com/frozenui/frozenui\" target=\"_blank\" rel=\"noopener\">https://github.com/frozenui/frozenui</a></p>\n"},{"title":"/usr/bin/pip: No such file or directory","comments":1,"date":"2018-07-24T07:30:20.000Z","_content":"\n应用pip时出现You are using pip version 9.0.1, however version 10.0.1 is available.问题，说明需要更新，\n\n使用sudo -H pip install --upgrade pip命令更新成功之后，运行pip --version，得到-bash: /usr/bin/pip: No such file or directory；\n\n执行which pip得到/usr/local/bin/pip，可见是出现了缓存问题，\n\n执行hash -r可清除缓存，pip正常\n","source":"_posts/usr-bin-pip-No-such-file-or-directory.md","raw":"---\ntitle: '/usr/bin/pip: No such file or directory'\ntags:\n  - Python\ncategories:\n  - Python\ncomments: false    // 是否开启评论\ndate: 2018-07-24 15:30:20\n---\n\n应用pip时出现You are using pip version 9.0.1, however version 10.0.1 is available.问题，说明需要更新，\n\n使用sudo -H pip install --upgrade pip命令更新成功之后，运行pip --version，得到-bash: /usr/bin/pip: No such file or directory；\n\n执行which pip得到/usr/local/bin/pip，可见是出现了缓存问题，\n\n执行hash -r可清除缓存，pip正常\n","slug":"usr-bin-pip-No-such-file-or-directory","published":1,"updated":"2019-01-09T09:50:41.384Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiiu001ay0w0jhq2267w","content":"<p>应用pip时出现You are using pip version 9.0.1, however version 10.0.1 is available.问题，说明需要更新，</p>\n<p>使用sudo -H pip install –upgrade pip命令更新成功之后，运行pip –version，得到-bash: /usr/bin/pip: No such file or directory；</p>\n<p>执行which pip得到/usr/local/bin/pip，可见是出现了缓存问题，</p>\n<p>执行hash -r可清除缓存，pip正常</p>\n","site":{"data":{}},"excerpt":"","more":"<p>应用pip时出现You are using pip version 9.0.1, however version 10.0.1 is available.问题，说明需要更新，</p>\n<p>使用sudo -H pip install –upgrade pip命令更新成功之后，运行pip –version，得到-bash: /usr/bin/pip: No such file or directory；</p>\n<p>执行which pip得到/usr/local/bin/pip，可见是出现了缓存问题，</p>\n<p>执行hash -r可清除缓存，pip正常</p>\n"},{"title":"彻底关闭windows Defender","comments":1,"date":"2018-07-24T07:27:45.000Z","_content":"\nwindows Defender是win10自带的保护电脑的工具，当遇到安装的软件性能出现问题时，需验证是否是windows Defender的影响.\n[关闭windows Defender](https://jingyan.baidu.com/article/59a015e3702f57f7948865cb.html) （验证有效）：\n\n1. win加r搜索输入regedit进入注册表编辑器\n2. 找到‘HKEY_LOCAL_MACHINE’选项（左侧菜单栏第三个就是），打开。\n3. 接下来找到SYSTEM，然后打开第三个选项。\n4. 继续找‘CurrentControlSet’---‘Services’—‘SecurityHealthService’\n5. 最后找到start时候打开，将里面数字2改为4重启即可永远关闭，开启重新改回2，再重启生效\n","source":"_posts/彻底关闭windows-Defender.md","raw":"---\ntitle: 彻底关闭windows Defender\ntags:\n  - windows10\n  - windows defender\ncategories:\n  - 前端\ncomments: false    // 是否开启评论\ndate: 2018-07-24 15:27:45\n---\n\nwindows Defender是win10自带的保护电脑的工具，当遇到安装的软件性能出现问题时，需验证是否是windows Defender的影响.\n[关闭windows Defender](https://jingyan.baidu.com/article/59a015e3702f57f7948865cb.html) （验证有效）：\n\n1. win加r搜索输入regedit进入注册表编辑器\n2. 找到‘HKEY_LOCAL_MACHINE’选项（左侧菜单栏第三个就是），打开。\n3. 接下来找到SYSTEM，然后打开第三个选项。\n4. 继续找‘CurrentControlSet’---‘Services’—‘SecurityHealthService’\n5. 最后找到start时候打开，将里面数字2改为4重启即可永远关闭，开启重新改回2，再重启生效\n","slug":"彻底关闭windows-Defender","published":1,"updated":"2019-01-09T09:50:41.384Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiiw001ey0w09a9urb37","content":"<p>windows Defender是win10自带的保护电脑的工具，当遇到安装的软件性能出现问题时，需验证是否是windows Defender的影响.<br><a href=\"https://jingyan.baidu.com/article/59a015e3702f57f7948865cb.html\" target=\"_blank\" rel=\"noopener\">关闭windows Defender</a> （验证有效）：</p>\n<ol>\n<li>win加r搜索输入regedit进入注册表编辑器</li>\n<li>找到‘HKEY_LOCAL_MACHINE’选项（左侧菜单栏第三个就是），打开。</li>\n<li>接下来找到SYSTEM，然后打开第三个选项。</li>\n<li>继续找‘CurrentControlSet’—‘Services’—‘SecurityHealthService’</li>\n<li>最后找到start时候打开，将里面数字2改为4重启即可永远关闭，开启重新改回2，再重启生效</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>windows Defender是win10自带的保护电脑的工具，当遇到安装的软件性能出现问题时，需验证是否是windows Defender的影响.<br><a href=\"https://jingyan.baidu.com/article/59a015e3702f57f7948865cb.html\" target=\"_blank\" rel=\"noopener\">关闭windows Defender</a> （验证有效）：</p>\n<ol>\n<li>win加r搜索输入regedit进入注册表编辑器</li>\n<li>找到‘HKEY_LOCAL_MACHINE’选项（左侧菜单栏第三个就是），打开。</li>\n<li>接下来找到SYSTEM，然后打开第三个选项。</li>\n<li>继续找‘CurrentControlSet’—‘Services’—‘SecurityHealthService’</li>\n<li>最后找到start时候打开，将里面数字2改为4重启即可永远关闭，开启重新改回2，再重启生效</li>\n</ol>\n"},{"title":"搭建自己的翻墙服务器","comments":1,"date":"2018-08-07T15:07:17.000Z","_content":"### 所需工具\n- 亚马逊服务器\n- securecrt\n- SwitchyOmega\n\n### 注册激活\n网上搜'[亚马逊服务器注册激活](https://blog.csdn.net/awschina/article/details/17149515)'，教程很多。\n\n### 亚马逊主机\n亚马逊开通了AWS云服务，可以通过申请亚马逊aws试用资格享受12个月免费主机试用资格。不过要注意日期，超过12个月之后就要收费了，到时候再考虑其他渠道，比如阿里云。。\n\n1. 创建实例\n   打开[亚马逊aws云服务](https://amazonaws-china.com/cn/about-aws/select-regions/?sc_channel=PS&sc_campaign=acquisition_CN&sc_publisher=baidu&sc_medium=bz&sc_content=pc&sc_detail=HL&sc_category=pc&sc_segment=test&sc_country=CN&trkCampaign=request_for_pilot_account&trk=baidu-ppc-test)，自己注册，注册方法自行百度，注意区域选择离中国近的地区\n2. 进入【EC2】> 云虚拟服务器，在出现的页面点击创建实例：【启动实例】---选择免费实例\n3. 进入Amazon系统映像，选择linux版本、64位\n4. 进入实例套餐（选择免费类型），点击启动实例\n5. 创建密钥对，一定下载保存\n6. 启动实例\n\n### SecureCRT访问Amazon EC2主机\n1. 上传xxx.pem文件到一个linux系统下，修改其权限为600,。命令 chmod 600 xxx.pem\n\n2. 改写密钥格式为 OpenSSH，命令 ssh-keygen -p -f xxx.pem（如果询问passphrase直接回车）\n\n3. 生成公密钥 .pub 文件 命令 ssh-keygen -e -f xxx.pem > xxx.pem.pub\n\n4. 在SecureCRT中新建连接，协议选择ssh2 ，主机名填写public dns（这个地址EC2的控制台中会提供），用户名填写ec2-user 。\n\n5. 右键点击属性，选中'SSH2',再选择鉴权（Authentication）中的公钥（PublicKey），选中之后右边的属性（Properties）才可选择，点击属性（Properties），选中3生成的共钥，确认即可。\n如图：![](搭建自己的翻墙服务器/PublicKey.png)\n注：公钥和密钥在同一个目录下。\n\n6. 右键属性，选择‘端口转发(Por Forwarding)’--‘添加(Add)’，名字(Name)填‘socks5’,端口自定义（比如1888），然后勾选上‘Dynamic forwarding using SOCKS 4 or 5'.\n如图：![](搭建自己的翻墙服务器/socksport.png)\n\n7. 在SecureCRT连接的列表中找到刚创建的连接，右键属性，左边树中选择PortForwarding,点击添加，name填socks5,Port自定义，比如1888\n   \n### 配置SwitchyOmega\n\n#### 下载安装\n点击 [Github-SwitchyOmega](https://github.com/FelisCatus/SwitchyOmega/releases)，下载页面有详细的安装教程，仔细看一下就好。；\n\n#### 配置 Shadowsocks 情景模式\n1. 打开 Chrome， 点击右上角的  图标，再点击 **选项**。\n2. 点击左侧的 新建情景模式，输入情景模式名称 Shadowsocks【自己任意设置名称】，类型选择第一个代理服务器。创建完成后做如下配置：\n![](搭建自己的翻墙服务器/shadowsocks.png)\n注：代理端口是上一项第（6）条填的端口号\n3. 保存后你就可以通过这个情景模式科学上网了\n\n#### 配置自动切换模式\n点击左侧的 自动切换，或者自己新建情景模式，类型选择第二个 自动切换模式。然后做如下配置：\n![](搭建自己的翻墙服务器/auto.png)\n\n- 切换规则 是在访问 条件设置 的域名时候使用后面设置的 情景模式。比如图中我设置 *.google.com 和 *.github.com 使用 Shadowsocks 情景模式【刚刚创建的那个情景模式】。我们可以点击 添加条件 来添加自己的规则。\n遇到资源未加载的情况时，点击添加条件，即是添加切换规则\n\n- 将图中 规则列表规则 前面的框打√，再将后面的 情景模式 设置为 Shadowsocks，意思是规则列表中的内容，我们使用 Shadowsocks 情景模式。然后 规则列表设置 中：\n    \n        规则列表格式： AutoProxy；\n        规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\n-这样设置完成 规则列表规则 后就不需要在切换规则中一个一个添加条件了。\n\n\n### openwrt翻墙\n\n利用openwrt可打造一台翻墙路由器，也可搭建一台翻墙虚拟机\n","source":"_posts/搭建自己的翻墙服务器.md","raw":"---\ntitle: 搭建自己的翻墙服务器\ntags:\n  - 翻墙\n  - securecrt\ncategories:\n  - 后端\ncomments: false    // 是否开启评论\ndate: 2018-08-07 23:07:17\n---\n### 所需工具\n- 亚马逊服务器\n- securecrt\n- SwitchyOmega\n\n### 注册激活\n网上搜'[亚马逊服务器注册激活](https://blog.csdn.net/awschina/article/details/17149515)'，教程很多。\n\n### 亚马逊主机\n亚马逊开通了AWS云服务，可以通过申请亚马逊aws试用资格享受12个月免费主机试用资格。不过要注意日期，超过12个月之后就要收费了，到时候再考虑其他渠道，比如阿里云。。\n\n1. 创建实例\n   打开[亚马逊aws云服务](https://amazonaws-china.com/cn/about-aws/select-regions/?sc_channel=PS&sc_campaign=acquisition_CN&sc_publisher=baidu&sc_medium=bz&sc_content=pc&sc_detail=HL&sc_category=pc&sc_segment=test&sc_country=CN&trkCampaign=request_for_pilot_account&trk=baidu-ppc-test)，自己注册，注册方法自行百度，注意区域选择离中国近的地区\n2. 进入【EC2】> 云虚拟服务器，在出现的页面点击创建实例：【启动实例】---选择免费实例\n3. 进入Amazon系统映像，选择linux版本、64位\n4. 进入实例套餐（选择免费类型），点击启动实例\n5. 创建密钥对，一定下载保存\n6. 启动实例\n\n### SecureCRT访问Amazon EC2主机\n1. 上传xxx.pem文件到一个linux系统下，修改其权限为600,。命令 chmod 600 xxx.pem\n\n2. 改写密钥格式为 OpenSSH，命令 ssh-keygen -p -f xxx.pem（如果询问passphrase直接回车）\n\n3. 生成公密钥 .pub 文件 命令 ssh-keygen -e -f xxx.pem > xxx.pem.pub\n\n4. 在SecureCRT中新建连接，协议选择ssh2 ，主机名填写public dns（这个地址EC2的控制台中会提供），用户名填写ec2-user 。\n\n5. 右键点击属性，选中'SSH2',再选择鉴权（Authentication）中的公钥（PublicKey），选中之后右边的属性（Properties）才可选择，点击属性（Properties），选中3生成的共钥，确认即可。\n如图：![](搭建自己的翻墙服务器/PublicKey.png)\n注：公钥和密钥在同一个目录下。\n\n6. 右键属性，选择‘端口转发(Por Forwarding)’--‘添加(Add)’，名字(Name)填‘socks5’,端口自定义（比如1888），然后勾选上‘Dynamic forwarding using SOCKS 4 or 5'.\n如图：![](搭建自己的翻墙服务器/socksport.png)\n\n7. 在SecureCRT连接的列表中找到刚创建的连接，右键属性，左边树中选择PortForwarding,点击添加，name填socks5,Port自定义，比如1888\n   \n### 配置SwitchyOmega\n\n#### 下载安装\n点击 [Github-SwitchyOmega](https://github.com/FelisCatus/SwitchyOmega/releases)，下载页面有详细的安装教程，仔细看一下就好。；\n\n#### 配置 Shadowsocks 情景模式\n1. 打开 Chrome， 点击右上角的  图标，再点击 **选项**。\n2. 点击左侧的 新建情景模式，输入情景模式名称 Shadowsocks【自己任意设置名称】，类型选择第一个代理服务器。创建完成后做如下配置：\n![](搭建自己的翻墙服务器/shadowsocks.png)\n注：代理端口是上一项第（6）条填的端口号\n3. 保存后你就可以通过这个情景模式科学上网了\n\n#### 配置自动切换模式\n点击左侧的 自动切换，或者自己新建情景模式，类型选择第二个 自动切换模式。然后做如下配置：\n![](搭建自己的翻墙服务器/auto.png)\n\n- 切换规则 是在访问 条件设置 的域名时候使用后面设置的 情景模式。比如图中我设置 *.google.com 和 *.github.com 使用 Shadowsocks 情景模式【刚刚创建的那个情景模式】。我们可以点击 添加条件 来添加自己的规则。\n遇到资源未加载的情况时，点击添加条件，即是添加切换规则\n\n- 将图中 规则列表规则 前面的框打√，再将后面的 情景模式 设置为 Shadowsocks，意思是规则列表中的内容，我们使用 Shadowsocks 情景模式。然后 规则列表设置 中：\n    \n        规则列表格式： AutoProxy；\n        规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\n-这样设置完成 规则列表规则 后就不需要在切换规则中一个一个添加条件了。\n\n\n### openwrt翻墙\n\n利用openwrt可打造一台翻墙路由器，也可搭建一台翻墙虚拟机\n","slug":"搭建自己的翻墙服务器","published":1,"updated":"2019-01-09T09:50:41.384Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiix001gy0w0qng99d1b","content":"<h3 id=\"所需工具\"><a href=\"#所需工具\" class=\"headerlink\" title=\"所需工具\"></a>所需工具</h3><ul>\n<li>亚马逊服务器</li>\n<li>securecrt</li>\n<li>SwitchyOmega</li>\n</ul>\n<h3 id=\"注册激活\"><a href=\"#注册激活\" class=\"headerlink\" title=\"注册激活\"></a>注册激活</h3><p>网上搜’<a href=\"https://blog.csdn.net/awschina/article/details/17149515\" target=\"_blank\" rel=\"noopener\">亚马逊服务器注册激活</a>‘，教程很多。</p>\n<h3 id=\"亚马逊主机\"><a href=\"#亚马逊主机\" class=\"headerlink\" title=\"亚马逊主机\"></a>亚马逊主机</h3><p>亚马逊开通了AWS云服务，可以通过申请亚马逊aws试用资格享受12个月免费主机试用资格。不过要注意日期，超过12个月之后就要收费了，到时候再考虑其他渠道，比如阿里云。。</p>\n<ol>\n<li>创建实例<br>打开<a href=\"https://amazonaws-china.com/cn/about-aws/select-regions/?sc_channel=PS&amp;sc_campaign=acquisition_CN&amp;sc_publisher=baidu&amp;sc_medium=bz&amp;sc_content=pc&amp;sc_detail=HL&amp;sc_category=pc&amp;sc_segment=test&amp;sc_country=CN&amp;trkCampaign=request_for_pilot_account&amp;trk=baidu-ppc-test\" target=\"_blank\" rel=\"noopener\">亚马逊aws云服务</a>，自己注册，注册方法自行百度，注意区域选择离中国近的地区</li>\n<li>进入【EC2】&gt; 云虚拟服务器，在出现的页面点击创建实例：【启动实例】—选择免费实例</li>\n<li>进入Amazon系统映像，选择linux版本、64位</li>\n<li>进入实例套餐（选择免费类型），点击启动实例</li>\n<li>创建密钥对，一定下载保存</li>\n<li>启动实例</li>\n</ol>\n<h3 id=\"SecureCRT访问Amazon-EC2主机\"><a href=\"#SecureCRT访问Amazon-EC2主机\" class=\"headerlink\" title=\"SecureCRT访问Amazon EC2主机\"></a>SecureCRT访问Amazon EC2主机</h3><ol>\n<li><p>上传xxx.pem文件到一个linux系统下，修改其权限为600,。命令 chmod 600 xxx.pem</p>\n</li>\n<li><p>改写密钥格式为 OpenSSH，命令 ssh-keygen -p -f xxx.pem（如果询问passphrase直接回车）</p>\n</li>\n<li><p>生成公密钥 .pub 文件 命令 ssh-keygen -e -f xxx.pem &gt; xxx.pem.pub</p>\n</li>\n<li><p>在SecureCRT中新建连接，协议选择ssh2 ，主机名填写public dns（这个地址EC2的控制台中会提供），用户名填写ec2-user 。</p>\n</li>\n<li><p>右键点击属性，选中’SSH2’,再选择鉴权（Authentication）中的公钥（PublicKey），选中之后右边的属性（Properties）才可选择，点击属性（Properties），选中3生成的共钥，确认即可。<br>如图：<img src=\"搭建自己的翻墙服务器/PublicKey.png\" alt=\"\"><br>注：公钥和密钥在同一个目录下。</p>\n</li>\n<li><p>右键属性，选择‘端口转发(Por Forwarding)’–‘添加(Add)’，名字(Name)填‘socks5’,端口自定义（比如1888），然后勾选上‘Dynamic forwarding using SOCKS 4 or 5’.<br>如图：<img src=\"搭建自己的翻墙服务器/socksport.png\" alt=\"\"></p>\n</li>\n<li><p>在SecureCRT连接的列表中找到刚创建的连接，右键属性，左边树中选择PortForwarding,点击添加，name填socks5,Port自定义，比如1888</p>\n</li>\n</ol>\n<h3 id=\"配置SwitchyOmega\"><a href=\"#配置SwitchyOmega\" class=\"headerlink\" title=\"配置SwitchyOmega\"></a>配置SwitchyOmega</h3><h4 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h4><p>点击 <a href=\"https://github.com/FelisCatus/SwitchyOmega/releases\" target=\"_blank\" rel=\"noopener\">Github-SwitchyOmega</a>，下载页面有详细的安装教程，仔细看一下就好。；</p>\n<h4 id=\"配置-Shadowsocks-情景模式\"><a href=\"#配置-Shadowsocks-情景模式\" class=\"headerlink\" title=\"配置 Shadowsocks 情景模式\"></a>配置 Shadowsocks 情景模式</h4><ol>\n<li>打开 Chrome， 点击右上角的  图标，再点击 <strong>选项</strong>。</li>\n<li>点击左侧的 新建情景模式，输入情景模式名称 Shadowsocks【自己任意设置名称】，类型选择第一个代理服务器。创建完成后做如下配置：<br><img src=\"搭建自己的翻墙服务器/shadowsocks.png\" alt=\"\"><br>注：代理端口是上一项第（6）条填的端口号</li>\n<li>保存后你就可以通过这个情景模式科学上网了</li>\n</ol>\n<h4 id=\"配置自动切换模式\"><a href=\"#配置自动切换模式\" class=\"headerlink\" title=\"配置自动切换模式\"></a>配置自动切换模式</h4><p>点击左侧的 自动切换，或者自己新建情景模式，类型选择第二个 自动切换模式。然后做如下配置：<br><img src=\"搭建自己的翻墙服务器/auto.png\" alt=\"\"></p>\n<ul>\n<li><p>切换规则 是在访问 条件设置 的域名时候使用后面设置的 情景模式。比如图中我设置 <em>.google.com 和 </em>.github.com 使用 Shadowsocks 情景模式【刚刚创建的那个情景模式】。我们可以点击 添加条件 来添加自己的规则。<br>遇到资源未加载的情况时，点击添加条件，即是添加切换规则</p>\n</li>\n<li><p>将图中 规则列表规则 前面的框打√，再将后面的 情景模式 设置为 Shadowsocks，意思是规则列表中的内容，我们使用 Shadowsocks 情景模式。然后 规则列表设置 中：</p>\n<pre><code>规则列表格式： AutoProxy；\n规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\n</code></pre><p>-这样设置完成 规则列表规则 后就不需要在切换规则中一个一个添加条件了。</p>\n</li>\n</ul>\n<h3 id=\"openwrt翻墙\"><a href=\"#openwrt翻墙\" class=\"headerlink\" title=\"openwrt翻墙\"></a>openwrt翻墙</h3><p>利用openwrt可打造一台翻墙路由器，也可搭建一台翻墙虚拟机</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"所需工具\"><a href=\"#所需工具\" class=\"headerlink\" title=\"所需工具\"></a>所需工具</h3><ul>\n<li>亚马逊服务器</li>\n<li>securecrt</li>\n<li>SwitchyOmega</li>\n</ul>\n<h3 id=\"注册激活\"><a href=\"#注册激活\" class=\"headerlink\" title=\"注册激活\"></a>注册激活</h3><p>网上搜’<a href=\"https://blog.csdn.net/awschina/article/details/17149515\" target=\"_blank\" rel=\"noopener\">亚马逊服务器注册激活</a>‘，教程很多。</p>\n<h3 id=\"亚马逊主机\"><a href=\"#亚马逊主机\" class=\"headerlink\" title=\"亚马逊主机\"></a>亚马逊主机</h3><p>亚马逊开通了AWS云服务，可以通过申请亚马逊aws试用资格享受12个月免费主机试用资格。不过要注意日期，超过12个月之后就要收费了，到时候再考虑其他渠道，比如阿里云。。</p>\n<ol>\n<li>创建实例<br>打开<a href=\"https://amazonaws-china.com/cn/about-aws/select-regions/?sc_channel=PS&amp;sc_campaign=acquisition_CN&amp;sc_publisher=baidu&amp;sc_medium=bz&amp;sc_content=pc&amp;sc_detail=HL&amp;sc_category=pc&amp;sc_segment=test&amp;sc_country=CN&amp;trkCampaign=request_for_pilot_account&amp;trk=baidu-ppc-test\" target=\"_blank\" rel=\"noopener\">亚马逊aws云服务</a>，自己注册，注册方法自行百度，注意区域选择离中国近的地区</li>\n<li>进入【EC2】&gt; 云虚拟服务器，在出现的页面点击创建实例：【启动实例】—选择免费实例</li>\n<li>进入Amazon系统映像，选择linux版本、64位</li>\n<li>进入实例套餐（选择免费类型），点击启动实例</li>\n<li>创建密钥对，一定下载保存</li>\n<li>启动实例</li>\n</ol>\n<h3 id=\"SecureCRT访问Amazon-EC2主机\"><a href=\"#SecureCRT访问Amazon-EC2主机\" class=\"headerlink\" title=\"SecureCRT访问Amazon EC2主机\"></a>SecureCRT访问Amazon EC2主机</h3><ol>\n<li><p>上传xxx.pem文件到一个linux系统下，修改其权限为600,。命令 chmod 600 xxx.pem</p>\n</li>\n<li><p>改写密钥格式为 OpenSSH，命令 ssh-keygen -p -f xxx.pem（如果询问passphrase直接回车）</p>\n</li>\n<li><p>生成公密钥 .pub 文件 命令 ssh-keygen -e -f xxx.pem &gt; xxx.pem.pub</p>\n</li>\n<li><p>在SecureCRT中新建连接，协议选择ssh2 ，主机名填写public dns（这个地址EC2的控制台中会提供），用户名填写ec2-user 。</p>\n</li>\n<li><p>右键点击属性，选中’SSH2’,再选择鉴权（Authentication）中的公钥（PublicKey），选中之后右边的属性（Properties）才可选择，点击属性（Properties），选中3生成的共钥，确认即可。<br>如图：<img src=\"搭建自己的翻墙服务器/PublicKey.png\" alt=\"\"><br>注：公钥和密钥在同一个目录下。</p>\n</li>\n<li><p>右键属性，选择‘端口转发(Por Forwarding)’–‘添加(Add)’，名字(Name)填‘socks5’,端口自定义（比如1888），然后勾选上‘Dynamic forwarding using SOCKS 4 or 5’.<br>如图：<img src=\"搭建自己的翻墙服务器/socksport.png\" alt=\"\"></p>\n</li>\n<li><p>在SecureCRT连接的列表中找到刚创建的连接，右键属性，左边树中选择PortForwarding,点击添加，name填socks5,Port自定义，比如1888</p>\n</li>\n</ol>\n<h3 id=\"配置SwitchyOmega\"><a href=\"#配置SwitchyOmega\" class=\"headerlink\" title=\"配置SwitchyOmega\"></a>配置SwitchyOmega</h3><h4 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h4><p>点击 <a href=\"https://github.com/FelisCatus/SwitchyOmega/releases\" target=\"_blank\" rel=\"noopener\">Github-SwitchyOmega</a>，下载页面有详细的安装教程，仔细看一下就好。；</p>\n<h4 id=\"配置-Shadowsocks-情景模式\"><a href=\"#配置-Shadowsocks-情景模式\" class=\"headerlink\" title=\"配置 Shadowsocks 情景模式\"></a>配置 Shadowsocks 情景模式</h4><ol>\n<li>打开 Chrome， 点击右上角的  图标，再点击 <strong>选项</strong>。</li>\n<li>点击左侧的 新建情景模式，输入情景模式名称 Shadowsocks【自己任意设置名称】，类型选择第一个代理服务器。创建完成后做如下配置：<br><img src=\"搭建自己的翻墙服务器/shadowsocks.png\" alt=\"\"><br>注：代理端口是上一项第（6）条填的端口号</li>\n<li>保存后你就可以通过这个情景模式科学上网了</li>\n</ol>\n<h4 id=\"配置自动切换模式\"><a href=\"#配置自动切换模式\" class=\"headerlink\" title=\"配置自动切换模式\"></a>配置自动切换模式</h4><p>点击左侧的 自动切换，或者自己新建情景模式，类型选择第二个 自动切换模式。然后做如下配置：<br><img src=\"搭建自己的翻墙服务器/auto.png\" alt=\"\"></p>\n<ul>\n<li><p>切换规则 是在访问 条件设置 的域名时候使用后面设置的 情景模式。比如图中我设置 <em>.google.com 和 </em>.github.com 使用 Shadowsocks 情景模式【刚刚创建的那个情景模式】。我们可以点击 添加条件 来添加自己的规则。<br>遇到资源未加载的情况时，点击添加条件，即是添加切换规则</p>\n</li>\n<li><p>将图中 规则列表规则 前面的框打√，再将后面的 情景模式 设置为 Shadowsocks，意思是规则列表中的内容，我们使用 Shadowsocks 情景模式。然后 规则列表设置 中：</p>\n<pre><code>规则列表格式： AutoProxy；\n规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\n</code></pre><p>-这样设置完成 规则列表规则 后就不需要在切换规则中一个一个添加条件了。</p>\n</li>\n</ul>\n<h3 id=\"openwrt翻墙\"><a href=\"#openwrt翻墙\" class=\"headerlink\" title=\"openwrt翻墙\"></a>openwrt翻墙</h3><p>利用openwrt可打造一台翻墙路由器，也可搭建一台翻墙虚拟机</p>\n"},{"title":"浏览器翻墙工具","comments":1,"date":"2018-07-23T12:54:53.000Z","_content":"Chrome浏览器自动翻墙插件\n\n通过附件或者Github下载插件，导入附件内的配置备份，在浏览器中插件界面配置为自动切换模式即可无缝打开google等网站。\n\n###  下载地址\n\n\n- [SwitchyOmega.crx](https://github.com/FelisCatus/SwitchyOmega/releases)\n\n\n### 配置备份\n\n- [OmegaOptions.bak]()\n\n### 配置说明文档\n\n- [https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList](https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList)\n\n","source":"_posts/浏览器翻墙工具.md","raw":"---\ntitle: 浏览器翻墙工具\ntags:\n  - Chrome\n  - 翻墙\ncategories:\n  - 工具\ncomments: false    // 是否开启评论\ndate: 2018-07-23 20:54:53\n---\nChrome浏览器自动翻墙插件\n\n通过附件或者Github下载插件，导入附件内的配置备份，在浏览器中插件界面配置为自动切换模式即可无缝打开google等网站。\n\n###  下载地址\n\n\n- [SwitchyOmega.crx](https://github.com/FelisCatus/SwitchyOmega/releases)\n\n\n### 配置备份\n\n- [OmegaOptions.bak]()\n\n### 配置说明文档\n\n- [https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList](https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList)\n\n","slug":"浏览器翻墙工具","published":1,"updated":"2019-01-09T09:50:41.384Z","layout":"post","photos":[],"link":"","_id":"cjqp0aiiy001ky0w0ay3rtppr","content":"<p>Chrome浏览器自动翻墙插件</p>\n<p>通过附件或者Github下载插件，导入附件内的配置备份，在浏览器中插件界面配置为自动切换模式即可无缝打开google等网站。</p>\n<h3 id=\"下载地址\"><a href=\"#下载地址\" class=\"headerlink\" title=\"下载地址\"></a>下载地址</h3><ul>\n<li><a href=\"https://github.com/FelisCatus/SwitchyOmega/releases\" target=\"_blank\" rel=\"noopener\">SwitchyOmega.crx</a></li>\n</ul>\n<h3 id=\"配置备份\"><a href=\"#配置备份\" class=\"headerlink\" title=\"配置备份\"></a>配置备份</h3><ul>\n<li><a href=\"\">OmegaOptions.bak</a></li>\n</ul>\n<h3 id=\"配置说明文档\"><a href=\"#配置说明文档\" class=\"headerlink\" title=\"配置说明文档\"></a>配置说明文档</h3><ul>\n<li><a href=\"https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList\" target=\"_blank\" rel=\"noopener\">https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Chrome浏览器自动翻墙插件</p>\n<p>通过附件或者Github下载插件，导入附件内的配置备份，在浏览器中插件界面配置为自动切换模式即可无缝打开google等网站。</p>\n<h3 id=\"下载地址\"><a href=\"#下载地址\" class=\"headerlink\" title=\"下载地址\"></a>下载地址</h3><ul>\n<li><a href=\"https://github.com/FelisCatus/SwitchyOmega/releases\" target=\"_blank\" rel=\"noopener\">SwitchyOmega.crx</a></li>\n</ul>\n<h3 id=\"配置备份\"><a href=\"#配置备份\" class=\"headerlink\" title=\"配置备份\"></a>配置备份</h3><ul>\n<li><a href=\"\">OmegaOptions.bak</a></li>\n</ul>\n<h3 id=\"配置说明文档\"><a href=\"#配置说明文档\" class=\"headerlink\" title=\"配置说明文档\"></a>配置说明文档</h3><ul>\n<li><a href=\"https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList\" target=\"_blank\" rel=\"noopener\">https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList</a></li>\n</ul>\n"},{"title":"linux常用命令","comments":1,"date":"2018-08-03T06:10:54.000Z","_content":"### mkdir 创建文件夹/目录\n命令参数：\n\n      -m, --mode=模式，设定权限<模式> (类似 chmod)，而不是 rwxrwxrwx 减 umask\n    \n      -p, --parents     可以是一个路径名称。\n                        此时若路径中的某些目录尚不存在,加上此选项后,\n                        系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; \n    \n      -v, --verbose     每次创建新目录都显示信息\n\n          --help        显示此帮助信息并退出\n    \n          --version     输出版本信息并退出\n\n### cp 复制\ncp命令语法\n\n    cp [options] sourcedir   destdir\n参数说明：\n\n    -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\n    -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\n    -f：覆盖已经存在的目标文件而不给出提示。\n    -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答\"y\"时目标文件将被覆盖。\n    -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n    -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\n    -l：不复制文件，只是生成链接文件。\n\n### 解压缩文件夹\ntar命令\n\n    　　解包：tar zxvf FileName.tar\n    \n    　　打包：tar czvf FileName.tar DirName\nzip命令\n\n    　　解压：unzip FileName.zip\n    \n    　　压缩：zip FileName.zip DirName\n### rm 删除文件夹\n\nrm -rf 目录名字   \n\n    -r 向下递归，不管有多少级目录，一并删除\n    -f 直接强行删除，没有任何提示\n删除文件夹实例：\n\n    rm -rf /var/log/httpd\n删除文件使用实例：\n\n    rm -f /var/log/httpd/access.log\n\n### 文件和目录 \n    cd /home 进入 '/ home' 目录' \n    cd .. 返回上一级目录 \n    cd ../.. 返回上两级目录 \n    cd 进入个人的主目录 \n    cd ~user1 进入个人的主目录 \n    cd - 返回上次所在的目录 \n    pwd 显示工作路径 \n    ls 查看目录中的文件 \n    ls -F 查看目录中的文件 \n    ls -l 显示文件和目录的详细资料 \n    ls -a 显示隐藏文件 \n    ls *[0-9]* 显示包含数字的文件名和目录名 \n    tree 显示文件和目录由根目录开始的树形结构(1) \n    lstree 显示文件和目录由根目录开始的树形结构(2) \n    mkdir dir1 创建一个叫做 'dir1' 的目录' \n    mkdir dir1 dir2 同时创建两个目录 \n    mkdir -p /tmp/dir1/dir2 创建一个目录树 \n    rm -f file1 删除一个叫做 'file1' 的文件' \n    rmdir dir1 删除一个叫做 'dir1' 的目录' \n    rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 \n    rm -rf dir1 dir2 同时删除两个目录及它们的内容 \n    mv dir1 new_dir 重命名/移动 一个目录 \n    cp file1 file2 复制一个文件 \n    cp dir/* . 复制一个目录下的所有文件到当前工作目录 \n    cp -a /tmp/dir1 . 复制一个目录到当前工作目录 \n    cp -a dir1 dir2 复制一个目录 \n    ln -s file1 lnk1 创建一个指向文件或目录的软链接 \n    ln file1 lnk1 创建一个指向文件或目录的物理链接 \n\n### 文件搜索 \n\n    find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录 \n    find / -user user1 搜索属于用户 'user1' 的文件和目录 \n    find /home/user1 -name \\*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 \n    find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 \n    find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 \n    find / -name \\*.rpm -exec chmod 755 '{}' \\; 搜索以 '.rpm' 结尾的文件并定义其权限 \n    find / -xdev -name \\*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备 \n    locate \\*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令 \n    whereis halt 显示一个二进制文件、源码或man的位置 \n    which halt 显示一个二进制文件或可执行文件的完整路径 \n\n### 打包和压缩文件 \n\n    bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件 \n    bzip2 file1 压缩一个叫做 'file1' 的文件 \n    gunzip file1.gz 解压一个叫做 'file1.gz'的文件 \n    gzip file1 压缩一个叫做 'file1'的文件 \n    gzip -9 file1 最大程度压缩 \n    rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包 \n    rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1' \n    rar x file1.rar 解压rar包 \n    unrar x file1.rar 解压rar包 \n    tar -cvf archive.tar file1 创建一个非压缩的 tarball \n    tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件 \n    tar -tf archive.tar 显示一个包中的内容 \n    tar -xvf archive.tar 释放一个包 \n    tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 \n    tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 \n    tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 \n    tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 \n    tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 \n    zip file1.zip file1 创建一个zip格式的压缩包 \n    zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 \n    unzip file1.zip 解压一个zip格式压缩包 \n### YUM 软件包升级器 - （Fedora, RedHat及类似系统） \n    yum install package_name 下载并安装一个rpm包 \n    yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 \n    yum update package_name.rpm 更新当前系统中所有安装的rpm包 \n    yum update package_name 更新一个rpm包 \n    yum remove package_name 删除一个rpm包 \n    yum list 列出当前系统中安装的所有包 \n    yum search package_name 在rpm仓库中搜寻软件包 \n    yum clean packages 清理rpm缓存删除下载的包 \n    yum clean headers 删除所有头文件 \n    yum clean all 删除所有缓存的包和头文件 \n### 文本处理 \n    cat file1 file2 ... | command <> file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT \n    cat file1 | command( sed, grep, awk, grep, etc...) > result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 \n    cat file1 | command( sed, grep, awk, grep, etc...) >> result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 \n    grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词\"Aug\" \n    grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以\"Aug\"开始的词汇 \n    grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行 \n    grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串\"Aug\" \n    sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 \"string1\" 替换成 \"string2\" \n    sed '/^$/d' example.txt 从example.txt文件中删除所有空白行 \n    sed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行 \n    echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容 \n    sed -e '1d' result.txt 从文件example.txt 中排除第一行 \n    sed -n '/stringa1/p' 查看只包含词汇 \"string1\"的行 \n    sed -e 's/ *$//' example.txt 删除每一行最后的空白字符 \n    sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 \"string1\" 并保留剩余全部 \n    sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容 \n    sed -n '5p;5q' example.txt 查看第5行 \n    sed -e 's/00*/0/g' example.txt 用单个零替换多个零 \n    cat -n file1 标示文件的行数 \n    cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行 \n    echo a b c | awk '{print $1}' 查看一行第一栏 \n    echo a b c | awk '{print $1,$3}' 查看一行的第一和第三栏 \n    paste file1 file2 合并两个文件或两栏的内容 \n    paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用\"+\"区分 \n    sort file1 file2 排序两个文件的内容 \n    sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) \n    sort file1 file2 | uniq -u 删除交集，留下其他的行 \n    sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) \n    comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容 \n    comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容 \n    comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 \n","source":"_posts/linux常用命令.md","raw":"---\ntitle: linux常用命令\ntags:\n  - linux\n  - 命令\ncategories:\n  - 后端\ncomments: false    // 是否开启评论\ndate: 2018-08-03 14:10:54\n---\n### mkdir 创建文件夹/目录\n命令参数：\n\n      -m, --mode=模式，设定权限<模式> (类似 chmod)，而不是 rwxrwxrwx 减 umask\n    \n      -p, --parents     可以是一个路径名称。\n                        此时若路径中的某些目录尚不存在,加上此选项后,\n                        系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; \n    \n      -v, --verbose     每次创建新目录都显示信息\n\n          --help        显示此帮助信息并退出\n    \n          --version     输出版本信息并退出\n\n### cp 复制\ncp命令语法\n\n    cp [options] sourcedir   destdir\n参数说明：\n\n    -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\n    -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\n    -f：覆盖已经存在的目标文件而不给出提示。\n    -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答\"y\"时目标文件将被覆盖。\n    -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n    -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\n    -l：不复制文件，只是生成链接文件。\n\n### 解压缩文件夹\ntar命令\n\n    　　解包：tar zxvf FileName.tar\n    \n    　　打包：tar czvf FileName.tar DirName\nzip命令\n\n    　　解压：unzip FileName.zip\n    \n    　　压缩：zip FileName.zip DirName\n### rm 删除文件夹\n\nrm -rf 目录名字   \n\n    -r 向下递归，不管有多少级目录，一并删除\n    -f 直接强行删除，没有任何提示\n删除文件夹实例：\n\n    rm -rf /var/log/httpd\n删除文件使用实例：\n\n    rm -f /var/log/httpd/access.log\n\n### 文件和目录 \n    cd /home 进入 '/ home' 目录' \n    cd .. 返回上一级目录 \n    cd ../.. 返回上两级目录 \n    cd 进入个人的主目录 \n    cd ~user1 进入个人的主目录 \n    cd - 返回上次所在的目录 \n    pwd 显示工作路径 \n    ls 查看目录中的文件 \n    ls -F 查看目录中的文件 \n    ls -l 显示文件和目录的详细资料 \n    ls -a 显示隐藏文件 \n    ls *[0-9]* 显示包含数字的文件名和目录名 \n    tree 显示文件和目录由根目录开始的树形结构(1) \n    lstree 显示文件和目录由根目录开始的树形结构(2) \n    mkdir dir1 创建一个叫做 'dir1' 的目录' \n    mkdir dir1 dir2 同时创建两个目录 \n    mkdir -p /tmp/dir1/dir2 创建一个目录树 \n    rm -f file1 删除一个叫做 'file1' 的文件' \n    rmdir dir1 删除一个叫做 'dir1' 的目录' \n    rm -rf dir1 删除一个叫做 'dir1' 的目录并同时删除其内容 \n    rm -rf dir1 dir2 同时删除两个目录及它们的内容 \n    mv dir1 new_dir 重命名/移动 一个目录 \n    cp file1 file2 复制一个文件 \n    cp dir/* . 复制一个目录下的所有文件到当前工作目录 \n    cp -a /tmp/dir1 . 复制一个目录到当前工作目录 \n    cp -a dir1 dir2 复制一个目录 \n    ln -s file1 lnk1 创建一个指向文件或目录的软链接 \n    ln file1 lnk1 创建一个指向文件或目录的物理链接 \n\n### 文件搜索 \n\n    find / -name file1 从 '/' 开始进入根文件系统搜索文件和目录 \n    find / -user user1 搜索属于用户 'user1' 的文件和目录 \n    find /home/user1 -name \\*.bin 在目录 '/ home/user1' 中搜索带有'.bin' 结尾的文件 \n    find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 \n    find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 \n    find / -name \\*.rpm -exec chmod 755 '{}' \\; 搜索以 '.rpm' 结尾的文件并定义其权限 \n    find / -xdev -name \\*.rpm 搜索以 '.rpm' 结尾的文件，忽略光驱、捷盘等可移动设备 \n    locate \\*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令 \n    whereis halt 显示一个二进制文件、源码或man的位置 \n    which halt 显示一个二进制文件或可执行文件的完整路径 \n\n### 打包和压缩文件 \n\n    bunzip2 file1.bz2 解压一个叫做 'file1.bz2'的文件 \n    bzip2 file1 压缩一个叫做 'file1' 的文件 \n    gunzip file1.gz 解压一个叫做 'file1.gz'的文件 \n    gzip file1 压缩一个叫做 'file1'的文件 \n    gzip -9 file1 最大程度压缩 \n    rar a file1.rar test_file 创建一个叫做 'file1.rar' 的包 \n    rar a file1.rar file1 file2 dir1 同时压缩 'file1', 'file2' 以及目录 'dir1' \n    rar x file1.rar 解压rar包 \n    unrar x file1.rar 解压rar包 \n    tar -cvf archive.tar file1 创建一个非压缩的 tarball \n    tar -cvf archive.tar file1 file2 dir1 创建一个包含了 'file1', 'file2' 以及 'dir1'的档案文件 \n    tar -tf archive.tar 显示一个包中的内容 \n    tar -xvf archive.tar 释放一个包 \n    tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 \n    tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 \n    tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 \n    tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 \n    tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 \n    zip file1.zip file1 创建一个zip格式的压缩包 \n    zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 \n    unzip file1.zip 解压一个zip格式压缩包 \n### YUM 软件包升级器 - （Fedora, RedHat及类似系统） \n    yum install package_name 下载并安装一个rpm包 \n    yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 \n    yum update package_name.rpm 更新当前系统中所有安装的rpm包 \n    yum update package_name 更新一个rpm包 \n    yum remove package_name 删除一个rpm包 \n    yum list 列出当前系统中安装的所有包 \n    yum search package_name 在rpm仓库中搜寻软件包 \n    yum clean packages 清理rpm缓存删除下载的包 \n    yum clean headers 删除所有头文件 \n    yum clean all 删除所有缓存的包和头文件 \n### 文本处理 \n    cat file1 file2 ... | command <> file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT \n    cat file1 | command( sed, grep, awk, grep, etc...) > result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 \n    cat file1 | command( sed, grep, awk, grep, etc...) >> result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 \n    grep Aug /var/log/messages 在文件 '/var/log/messages'中查找关键词\"Aug\" \n    grep ^Aug /var/log/messages 在文件 '/var/log/messages'中查找以\"Aug\"开始的词汇 \n    grep [0-9] /var/log/messages 选择 '/var/log/messages' 文件中所有包含数字的行 \n    grep Aug -R /var/log/* 在目录 '/var/log' 及随后的目录中搜索字符串\"Aug\" \n    sed 's/stringa1/stringa2/g' example.txt 将example.txt文件中的 \"string1\" 替换成 \"string2\" \n    sed '/^$/d' example.txt 从example.txt文件中删除所有空白行 \n    sed '/ *#/d; /^$/d' example.txt 从example.txt文件中删除所有注释和空白行 \n    echo 'esempio' | tr '[:lower:]' '[:upper:]' 合并上下单元格内容 \n    sed -e '1d' result.txt 从文件example.txt 中排除第一行 \n    sed -n '/stringa1/p' 查看只包含词汇 \"string1\"的行 \n    sed -e 's/ *$//' example.txt 删除每一行最后的空白字符 \n    sed -e 's/stringa1//g' example.txt 从文档中只删除词汇 \"string1\" 并保留剩余全部 \n    sed -n '1,5p;5q' example.txt 查看从第一行到第5行内容 \n    sed -n '5p;5q' example.txt 查看第5行 \n    sed -e 's/00*/0/g' example.txt 用单个零替换多个零 \n    cat -n file1 标示文件的行数 \n    cat example.txt | awk 'NR%2==1' 删除example.txt文件中的所有偶数行 \n    echo a b c | awk '{print $1}' 查看一行第一栏 \n    echo a b c | awk '{print $1,$3}' 查看一行的第一和第三栏 \n    paste file1 file2 合并两个文件或两栏的内容 \n    paste -d '+' file1 file2 合并两个文件或两栏的内容，中间用\"+\"区分 \n    sort file1 file2 排序两个文件的内容 \n    sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) \n    sort file1 file2 | uniq -u 删除交集，留下其他的行 \n    sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) \n    comm -1 file1 file2 比较两个文件的内容只删除 'file1' 所包含的内容 \n    comm -2 file1 file2 比较两个文件的内容只删除 'file2' 所包含的内容 \n    comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 \n","slug":"linux常用命令","published":1,"updated":"2019-01-09T09:50:41.384Z","layout":"post","photos":[],"link":"","_id":"cjqp0aijc0039y0w0iza0s8hf","content":"<h3 id=\"mkdir-创建文件夹-目录\"><a href=\"#mkdir-创建文件夹-目录\" class=\"headerlink\" title=\"mkdir 创建文件夹/目录\"></a>mkdir 创建文件夹/目录</h3><p>命令参数：</p>\n<pre><code>-m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask\n\n-p, --parents     可以是一个路径名称。\n                  此时若路径中的某些目录尚不存在,加上此选项后,\n                  系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; \n\n-v, --verbose     每次创建新目录都显示信息\n\n    --help        显示此帮助信息并退出\n\n    --version     输出版本信息并退出\n</code></pre><h3 id=\"cp-复制\"><a href=\"#cp-复制\" class=\"headerlink\" title=\"cp 复制\"></a>cp 复制</h3><p>cp命令语法</p>\n<pre><code>cp [options] sourcedir   destdir\n</code></pre><p>参数说明：</p>\n<pre><code>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\n-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\n-f：覆盖已经存在的目标文件而不给出提示。\n-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答&quot;y&quot;时目标文件将被覆盖。\n-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\n-l：不复制文件，只是生成链接文件。\n</code></pre><h3 id=\"解压缩文件夹\"><a href=\"#解压缩文件夹\" class=\"headerlink\" title=\"解压缩文件夹\"></a>解压缩文件夹</h3><p>tar命令</p>\n<pre><code>　　解包：tar zxvf FileName.tar\n\n　　打包：tar czvf FileName.tar DirName\n</code></pre><p>zip命令</p>\n<pre><code>　　解压：unzip FileName.zip\n\n　　压缩：zip FileName.zip DirName\n</code></pre><h3 id=\"rm-删除文件夹\"><a href=\"#rm-删除文件夹\" class=\"headerlink\" title=\"rm 删除文件夹\"></a>rm 删除文件夹</h3><p>rm -rf 目录名字   </p>\n<pre><code>-r 向下递归，不管有多少级目录，一并删除\n-f 直接强行删除，没有任何提示\n</code></pre><p>删除文件夹实例：</p>\n<pre><code>rm -rf /var/log/httpd\n</code></pre><p>删除文件使用实例：</p>\n<pre><code>rm -f /var/log/httpd/access.log\n</code></pre><h3 id=\"文件和目录\"><a href=\"#文件和目录\" class=\"headerlink\" title=\"文件和目录\"></a>文件和目录</h3><pre><code>cd /home 进入 &apos;/ home&apos; 目录&apos; \ncd .. 返回上一级目录 \ncd ../.. 返回上两级目录 \ncd 进入个人的主目录 \ncd ~user1 进入个人的主目录 \ncd - 返回上次所在的目录 \npwd 显示工作路径 \nls 查看目录中的文件 \nls -F 查看目录中的文件 \nls -l 显示文件和目录的详细资料 \nls -a 显示隐藏文件 \nls *[0-9]* 显示包含数字的文件名和目录名 \ntree 显示文件和目录由根目录开始的树形结构(1) \nlstree 显示文件和目录由根目录开始的树形结构(2) \nmkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos; \nmkdir dir1 dir2 同时创建两个目录 \nmkdir -p /tmp/dir1/dir2 创建一个目录树 \nrm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; \nrmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; \nrm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 \nrm -rf dir1 dir2 同时删除两个目录及它们的内容 \nmv dir1 new_dir 重命名/移动 一个目录 \ncp file1 file2 复制一个文件 \ncp dir/* . 复制一个目录下的所有文件到当前工作目录 \ncp -a /tmp/dir1 . 复制一个目录到当前工作目录 \ncp -a dir1 dir2 复制一个目录 \nln -s file1 lnk1 创建一个指向文件或目录的软链接 \nln file1 lnk1 创建一个指向文件或目录的物理链接 \n</code></pre><h3 id=\"文件搜索\"><a href=\"#文件搜索\" class=\"headerlink\" title=\"文件搜索\"></a>文件搜索</h3><pre><code>find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 \nfind / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 \nfind /home/user1 -name \\*.bin 在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件 \nfind /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 \nfind /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 \nfind / -name \\*.rpm -exec chmod 755 &apos;{}&apos; \\; 搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限 \nfind / -xdev -name \\*.rpm 搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备 \nlocate \\*.ps 寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令 \nwhereis halt 显示一个二进制文件、源码或man的位置 \nwhich halt 显示一个二进制文件或可执行文件的完整路径 \n</code></pre><h3 id=\"打包和压缩文件\"><a href=\"#打包和压缩文件\" class=\"headerlink\" title=\"打包和压缩文件\"></a>打包和压缩文件</h3><pre><code>bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 \nbzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 \ngunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 \ngzip file1 压缩一个叫做 &apos;file1&apos;的文件 \ngzip -9 file1 最大程度压缩 \nrar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 \nrar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; \nrar x file1.rar 解压rar包 \nunrar x file1.rar 解压rar包 \ntar -cvf archive.tar file1 创建一个非压缩的 tarball \ntar -cvf archive.tar file1 file2 dir1 创建一个包含了 &apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件 \ntar -tf archive.tar 显示一个包中的内容 \ntar -xvf archive.tar 释放一个包 \ntar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 \ntar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 \ntar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 \ntar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 \ntar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 \nzip file1.zip file1 创建一个zip格式的压缩包 \nzip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 \nunzip file1.zip 解压一个zip格式压缩包 \n</code></pre><h3 id=\"YUM-软件包升级器-（Fedora-RedHat及类似系统）\"><a href=\"#YUM-软件包升级器-（Fedora-RedHat及类似系统）\" class=\"headerlink\" title=\"YUM 软件包升级器 - （Fedora, RedHat及类似系统）\"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><pre><code>yum install package_name 下载并安装一个rpm包 \nyum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 \nyum update package_name.rpm 更新当前系统中所有安装的rpm包 \nyum update package_name 更新一个rpm包 \nyum remove package_name 删除一个rpm包 \nyum list 列出当前系统中安装的所有包 \nyum search package_name 在rpm仓库中搜寻软件包 \nyum clean packages 清理rpm缓存删除下载的包 \nyum clean headers 删除所有头文件 \nyum clean all 删除所有缓存的包和头文件 \n</code></pre><h3 id=\"文本处理\"><a href=\"#文本处理\" class=\"headerlink\" title=\"文本处理\"></a>文本处理</h3><pre><code>cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT \ncat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 \ncat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 \ngrep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; \ngrep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 \ngrep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 \ngrep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; \nsed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; \nsed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 \nsed &apos;/ *#/d; /^$/d&apos; example.txt 从example.txt文件中删除所有注释和空白行 \necho &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; 合并上下单元格内容 \nsed -e &apos;1d&apos; result.txt 从文件example.txt 中排除第一行 \nsed -n &apos;/stringa1/p&apos; 查看只包含词汇 &quot;string1&quot;的行 \nsed -e &apos;s/ *$//&apos; example.txt 删除每一行最后的空白字符 \nsed -e &apos;s/stringa1//g&apos; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 \nsed -n &apos;1,5p;5q&apos; example.txt 查看从第一行到第5行内容 \nsed -n &apos;5p;5q&apos; example.txt 查看第5行 \nsed -e &apos;s/00*/0/g&apos; example.txt 用单个零替换多个零 \ncat -n file1 标示文件的行数 \ncat example.txt | awk &apos;NR%2==1&apos; 删除example.txt文件中的所有偶数行 \necho a b c | awk &apos;{print $1}&apos; 查看一行第一栏 \necho a b c | awk &apos;{print $1,$3}&apos; 查看一行的第一和第三栏 \npaste file1 file2 合并两个文件或两栏的内容 \npaste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 \nsort file1 file2 排序两个文件的内容 \nsort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) \nsort file1 file2 | uniq -u 删除交集，留下其他的行 \nsort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) \ncomm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 \ncomm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 \ncomm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"mkdir-创建文件夹-目录\"><a href=\"#mkdir-创建文件夹-目录\" class=\"headerlink\" title=\"mkdir 创建文件夹/目录\"></a>mkdir 创建文件夹/目录</h3><p>命令参数：</p>\n<pre><code>-m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask\n\n-p, --parents     可以是一个路径名称。\n                  此时若路径中的某些目录尚不存在,加上此选项后,\n                  系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; \n\n-v, --verbose     每次创建新目录都显示信息\n\n    --help        显示此帮助信息并退出\n\n    --version     输出版本信息并退出\n</code></pre><h3 id=\"cp-复制\"><a href=\"#cp-复制\" class=\"headerlink\" title=\"cp 复制\"></a>cp 复制</h3><p>cp命令语法</p>\n<pre><code>cp [options] sourcedir   destdir\n</code></pre><p>参数说明：</p>\n<pre><code>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\n-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\n-f：覆盖已经存在的目标文件而不给出提示。\n-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答&quot;y&quot;时目标文件将被覆盖。\n-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\n-l：不复制文件，只是生成链接文件。\n</code></pre><h3 id=\"解压缩文件夹\"><a href=\"#解压缩文件夹\" class=\"headerlink\" title=\"解压缩文件夹\"></a>解压缩文件夹</h3><p>tar命令</p>\n<pre><code>　　解包：tar zxvf FileName.tar\n\n　　打包：tar czvf FileName.tar DirName\n</code></pre><p>zip命令</p>\n<pre><code>　　解压：unzip FileName.zip\n\n　　压缩：zip FileName.zip DirName\n</code></pre><h3 id=\"rm-删除文件夹\"><a href=\"#rm-删除文件夹\" class=\"headerlink\" title=\"rm 删除文件夹\"></a>rm 删除文件夹</h3><p>rm -rf 目录名字   </p>\n<pre><code>-r 向下递归，不管有多少级目录，一并删除\n-f 直接强行删除，没有任何提示\n</code></pre><p>删除文件夹实例：</p>\n<pre><code>rm -rf /var/log/httpd\n</code></pre><p>删除文件使用实例：</p>\n<pre><code>rm -f /var/log/httpd/access.log\n</code></pre><h3 id=\"文件和目录\"><a href=\"#文件和目录\" class=\"headerlink\" title=\"文件和目录\"></a>文件和目录</h3><pre><code>cd /home 进入 &apos;/ home&apos; 目录&apos; \ncd .. 返回上一级目录 \ncd ../.. 返回上两级目录 \ncd 进入个人的主目录 \ncd ~user1 进入个人的主目录 \ncd - 返回上次所在的目录 \npwd 显示工作路径 \nls 查看目录中的文件 \nls -F 查看目录中的文件 \nls -l 显示文件和目录的详细资料 \nls -a 显示隐藏文件 \nls *[0-9]* 显示包含数字的文件名和目录名 \ntree 显示文件和目录由根目录开始的树形结构(1) \nlstree 显示文件和目录由根目录开始的树形结构(2) \nmkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos; \nmkdir dir1 dir2 同时创建两个目录 \nmkdir -p /tmp/dir1/dir2 创建一个目录树 \nrm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; \nrmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; \nrm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 \nrm -rf dir1 dir2 同时删除两个目录及它们的内容 \nmv dir1 new_dir 重命名/移动 一个目录 \ncp file1 file2 复制一个文件 \ncp dir/* . 复制一个目录下的所有文件到当前工作目录 \ncp -a /tmp/dir1 . 复制一个目录到当前工作目录 \ncp -a dir1 dir2 复制一个目录 \nln -s file1 lnk1 创建一个指向文件或目录的软链接 \nln file1 lnk1 创建一个指向文件或目录的物理链接 \n</code></pre><h3 id=\"文件搜索\"><a href=\"#文件搜索\" class=\"headerlink\" title=\"文件搜索\"></a>文件搜索</h3><pre><code>find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 \nfind / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 \nfind /home/user1 -name \\*.bin 在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件 \nfind /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 \nfind /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 \nfind / -name \\*.rpm -exec chmod 755 &apos;{}&apos; \\; 搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限 \nfind / -xdev -name \\*.rpm 搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备 \nlocate \\*.ps 寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令 \nwhereis halt 显示一个二进制文件、源码或man的位置 \nwhich halt 显示一个二进制文件或可执行文件的完整路径 \n</code></pre><h3 id=\"打包和压缩文件\"><a href=\"#打包和压缩文件\" class=\"headerlink\" title=\"打包和压缩文件\"></a>打包和压缩文件</h3><pre><code>bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 \nbzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 \ngunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 \ngzip file1 压缩一个叫做 &apos;file1&apos;的文件 \ngzip -9 file1 最大程度压缩 \nrar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 \nrar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; \nrar x file1.rar 解压rar包 \nunrar x file1.rar 解压rar包 \ntar -cvf archive.tar file1 创建一个非压缩的 tarball \ntar -cvf archive.tar file1 file2 dir1 创建一个包含了 &apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件 \ntar -tf archive.tar 显示一个包中的内容 \ntar -xvf archive.tar 释放一个包 \ntar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 \ntar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 \ntar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 \ntar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 \ntar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 \nzip file1.zip file1 创建一个zip格式的压缩包 \nzip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 \nunzip file1.zip 解压一个zip格式压缩包 \n</code></pre><h3 id=\"YUM-软件包升级器-（Fedora-RedHat及类似系统）\"><a href=\"#YUM-软件包升级器-（Fedora-RedHat及类似系统）\" class=\"headerlink\" title=\"YUM 软件包升级器 - （Fedora, RedHat及类似系统）\"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><pre><code>yum install package_name 下载并安装一个rpm包 \nyum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 \nyum update package_name.rpm 更新当前系统中所有安装的rpm包 \nyum update package_name 更新一个rpm包 \nyum remove package_name 删除一个rpm包 \nyum list 列出当前系统中安装的所有包 \nyum search package_name 在rpm仓库中搜寻软件包 \nyum clean packages 清理rpm缓存删除下载的包 \nyum clean headers 删除所有头文件 \nyum clean all 删除所有缓存的包和头文件 \n</code></pre><h3 id=\"文本处理\"><a href=\"#文本处理\" class=\"headerlink\" title=\"文本处理\"></a>文本处理</h3><pre><code>cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT \ncat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 \ncat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 \ngrep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; \ngrep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 \ngrep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 \ngrep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; \nsed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; \nsed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 \nsed &apos;/ *#/d; /^$/d&apos; example.txt 从example.txt文件中删除所有注释和空白行 \necho &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; 合并上下单元格内容 \nsed -e &apos;1d&apos; result.txt 从文件example.txt 中排除第一行 \nsed -n &apos;/stringa1/p&apos; 查看只包含词汇 &quot;string1&quot;的行 \nsed -e &apos;s/ *$//&apos; example.txt 删除每一行最后的空白字符 \nsed -e &apos;s/stringa1//g&apos; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 \nsed -n &apos;1,5p;5q&apos; example.txt 查看从第一行到第5行内容 \nsed -n &apos;5p;5q&apos; example.txt 查看第5行 \nsed -e &apos;s/00*/0/g&apos; example.txt 用单个零替换多个零 \ncat -n file1 标示文件的行数 \ncat example.txt | awk &apos;NR%2==1&apos; 删除example.txt文件中的所有偶数行 \necho a b c | awk &apos;{print $1}&apos; 查看一行第一栏 \necho a b c | awk &apos;{print $1,$3}&apos; 查看一行的第一和第三栏 \npaste file1 file2 合并两个文件或两栏的内容 \npaste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 \nsort file1 file2 排序两个文件的内容 \nsort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) \nsort file1 file2 | uniq -u 删除交集，留下其他的行 \nsort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) \ncomm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 \ncomm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 \ncomm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 \n</code></pre>"},{"title":"ansible 应用","comments":1,"date":"2018-07-31T02:38:16.000Z","_content":"\n链接地址：[http://www.ansible.com.cn/docs/YAMLSyntax.html](http://www.ansible.com.cn/docs/YAMLSyntax.html)\n\n### 环境创建\n- 参考[Python-配置虚拟环境](./Python-配置虚拟环境.md),创建ansible的应用环境。\n- 安装：pip install ansible\n\n### 建立免密钥登陆\n为了避免Ansible下发指令时输入目标主机密码，通过证书签名达到SSH无密码是一个好的方案，推荐使用ssh-keygen与ssh-copy-id来实现快速证书的生成和公钥下发，其中ssh-keygen生成一对密钥，使用ssh-copy-id来下发生成的公钥。具体操作如下：\n生成管理主机得私钥和公钥\n    \n    ssh-keygen -t rsa -b 2048 -P '' -f /root/.ssh/id_rsa\n添加主机信息到主机清单中\n    \n    #host\n    192.168.77.129 ansible_ssh_pass=1234567\n    192.168.77.130 ansible_ssh_pass=123456   \n    \n ansible_ssh_pass密码如果一样的话，这里就不需要定义了。在运行ansible-playbook时 加上-k参数，就可以输入登陆密码\n\n配置palybook\n   \n    - hosts: testhosts\n     user: root\n     tasks:\n        - name: ssh-copy\n          authorized_key: user=root key=\"{{ lookup('file', '/Users/tpw-dev/.ssh/id_rsa.pub') }}\"\n          tags: sshkey\n\n运行playbook\n   \n    ansible-playbook -i hosts ssh-addkey.yml\n这样，管理节点的公钥就会添加到节点得authorized_keys文件中，再把主机清单里的ansible_ssh_pass去掉，执行ansible all -m ping 就不需要密码了。\n\n### Inventory(清单)文件\nAnsible 可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置. 默认的文件路径为 /etc/ansible/hosts，\n在执行ansible-book命令时，也可通过执行-i选项制定inventory 文件。\n\nInventory 参数的说明\n\n    ansible_ssh_host\n              将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\n        \n        ansible_ssh_port\n              ssh端口号.如果不是默认的端口号,通过此变量设置.\n        \n        ansible_ssh_user\n              默认的 ssh 用户名\n        \n        ansible_ssh_pass\n              ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)\n        \n        ansible_sudo_pass\n              sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\n        \n        ansible_sudo_exe (new in version 1.8)\n              sudo 命令路径(适用于1.8及以上版本)\n        \n        ansible_connection\n              与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 'smart','smart' 方式会根据是否支持 ControlPersist, 来判断'ssh' 方式是否可行.\n        \n        ansible_ssh_private_key_file\n              ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.\n        \n        ansible_shell_type\n              目标系统的shell类型.默认情况下,命令的执行使用 'sh' 语法,可设置为 'csh' 或 'fish'.\n        \n        ansible_python_interpreter\n              目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是\"/usr/bin/python\",比如  \\*BSD, 或者 /usr/bin/python\n              不是 2.X 版本的 Python.我们不使用 \"/usr/bin/env\" 机制,因为这要求远程用户的路径设置正确,且要求 \"python\" 可执行程序名不可为 python以外的名字(实际有可能名为python26).\n              与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....\n\n    \n### Playbooks 介绍\nplaybook 由一个或多个 ‘plays’ 组成.它的内容是一个以 ‘plays’ 为元素的列表.在 ansible 中,play 的内容,被称为 tasks,即任务.\n\n这里有一个 playbook,其中仅包含一个 play:\n\n    ---\n    - hosts: webservers\n      vars:\n        http_port: 80\n        max_clients: 200\n      remote_user: root\n      tasks:\n      - name: ensure apache is at the latest version\n        yum: pkg=httpd state=latest\n      - name: write the apache config file\n        template: src=/srv/httpd.j2 dest=/etc/httpd.conf\n        notify:\n        - restart apache\n#### playbook基础\n\n##### 主机与用户\n\n**hosts 行的内容是一个或多个组或主机的 patterns,以逗号为分隔符**\n\nremote_user 就是账户名:\n\n    ---\n    - hosts: webservers\n      remote_user: root\n      \n##### Tasks 列表\n\n每一个 play 包含了一个 task 列表（任务列表）.一个 task 在其所对应的所有主机上（通过 host pattern 匹配的所有主机）执行完毕之后,下一个 task 才会执行.\n每个 task 的目标在于执行一个 moudle,modules 具有”幂等”性,意思是如果你再一次地执行 moudle,moudle 只会执行必要的改动,只会改变需要改变的地方.所以重复多次执行 playbook 也很安全.\n下面是一种基本的 task 的定义,service moudle 使用 key=value 格式的参数,这也是大多数 module 使用的参数格式:\n\n    tasks:\n      - name: make sure apache is running\n        service: name=httpd state=running\n比较特别的两个 modudle 是 command 和 shell ,它们不使用 key=value 格式的参数,而是这样:\n\n    tasks:\n      - name: disable selinux\n        command: /sbin/setenforce 0\n        \n**tasks可添加biaoqian(tags),这样在执行命令时可制定tasks**\n如下：\n\n    - name: Create Base folder\n        file:\n          path: \"{{baseDeployPathPrefix}}{{serverId}}\"\n          state: directory\n        tags: system\n      - name: copy redis dir \n        synchronize:\n          src: redis-4.0.10\n          dest: \"{{baseDeployPathPrefix}}{{serverId}}\"\n        tags: redis\n     \n     ansible-playbook -i test_hosts -e \"target=s1001\" -t createDB site.yml   \n        \n-t 后跟tags，这样就可以指定要执行的tasks\n    \n\n##### Handlers: 在发生改变时执行的操作\n(当发生改动时）’notify’ actions 会在 playbook 的每一个 task 结束时被触发,而且即使有多个不同的 task 通知改动的发生, ‘notify’ actions 只会被触发一次.\n\n这里有一个例子,当一个文件的内容被改动时,重启两个 services:\n\n    - name: template configuration file\n      template: src=template.j2 dest=/etc/foo.conf\n      notify:\n         - restart memcached\n         - restart apache\n‘notify’ 下列出的即是 handlers.\n\nHandlers 是由通知者进行 notify, 如果没有被 notify,handlers 不会执行.\n\n这里是一个 handlers 的示例:\n\n    handlers:\n        - name: restart memcached\n          service:  name=memcached state=restarted\n        - name: restart apache\n          service: name=apache state=restarted\n**handlers 会按照声明的顺序执行**\n\n##### 提示与技巧\n如果想看到执行成功的 modules 的输出信息,使用 --verbose flag（否则只有执行失败的才会有输出信息）.\n\n在执行一个 playbook 之前,想看看这个 playbook 的执行会影响到哪些 hosts,你可以这样做:\n\n    ansible-playbook playbook.yml --list-hosts\n\n\n### Roles\n一个项目的结构如下:\n\n    site.yml\n    webservers.yml\n    fooservers.yml\n    roles/\n       common/\n         files/\n         templates/\n         tasks/\n         handlers/\n         vars/\n         defaults/\n         meta/\n       webservers/\n         files/\n         templates/\n         tasks/\n         handlers/\n         vars/\n         defaults/\n         meta/\n一个 playbook 如下:\n\n    ---\n    - hosts: webservers\n      roles:\n         - common\n         - webservers\n这个 playbook 为一个角色 ‘x’ 指定了如下的行为：\n\n- 如果 roles/x/tasks/main.yml 存在, 其中列出的 tasks 将被添加到 play 中\n- 如果 roles/x/handlers/main.yml 存在, 其中列出的 handlers 将被添加到 play 中\n-  如果 roles/x/vars/main.yml 存在, 其中列出的 variables 将被添加到 play 中\n-  如果 roles/x/meta/main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中 (1.3 and later)\n-  所有 copy tasks 可以引用 roles/x/files/ 中的文件，不需要指明文件的路径。\n-  所有 script tasks 可以引用 roles/x/files/ 中的脚本，不需要指明文件的路径。\n-  所有 template tasks 可以引用 roles/x/templates/ 中的文件，不需要指明文件的路径。\n-  所有 include tasks 可以引用 roles/x/tasks/ 中的文件，不需要指明文件的路径。    \n\n如果你希望定义一些 tasks，让它们在 roles 之前以及之后执行，你可以这样做:\n\n    ---\n    \n    - hosts: webservers\n    \n      pre_tasks:\n        - shell: echo 'hello'\n    \n      roles:\n        - { role: some_role }\n    \n      tasks:\n        - shell: echo 'still busy'\n    \n      post_tasks:\n        - shell: echo 'goodbye'\n**值得指出的是,handlers 会在 ‘pre_tasks’, ‘roles’, ‘tasks’, 和 ‘post_tasks’ 之间自动执行. 如果你想立即执行所有的 handler 命令.**\n\n    tasks:\n       - shell: some tasks go here\n       - meta: flush_handlers\n       - shell: some other tasks\n#### Ansible Galaxy\n[Ansible Galaxy](https://galaxy.ansible.com/home) 是一个自由网站，网站提供所有类型的由社区开发的 roles，这对于实现你的自动化项目是一个很好的参考。网站提供这些 roles 的排名、查找以及下载。\n\n### Variables(变量)\n\n#### 定义变量\n- 在Inventory中定义变量\n- 在playbook中定义变量\n- 在文件和role中定义变量\n#### 使用变量: 关于Jinja2\n变量替换最基本的形式:\n\n    template: src=foo.cfg.j2 dest={{ remote_install_path }}/foo.cfg\n#### YAML陷阱\nYAML语法要求如果值以{{ foo }}开头的话我们需要将整行用双引号包起来.这是为了确认你不是想声明一个YAML字典.\n\n这样是不行的:\n    \n    - hosts: app_servers\n      vars:\n          app_path: {{ base_path }}/22\n你应该这么做:\n    - hosts: app_servers\n      vars:\n           app_path: \"{{ base_path }}/22\"\n\n#### Facts\nFacts通过访问远程系统获取相应的信息. 一个例子就是远程主机的IP地址或者操作系统是什么. 使用以下命令可以查看哪些信息是可用的:\n\n    ansible hostname -m setup\n这会返回巨量的变量数据,默认是生成这些信息的，可以在playbook中这样引用远程系统的主机名\n\n    {{ ansible_nodename }}\n关闭Facts\n\n    - hosts: whatever\n      gather_facts: no\n#### Fact缓存\n因为缓存的存在，从一个服务器引用另一个服务器的变量是可行的.\n\n    {{ hostvars['asdf.example.com']['ansible_os_family'] }}\n\n#### 命令行中传递变量\n除了`vars_prompt`和`vars_files`也可以通过Ansible命令行发送变量.如果你想编写一个通用的发布playbook时则特别有用,你可以传递应用的版本以便部署:\n    \n    ---\n    - hosts: \"{{ target }}\"\n      gather_facts: false\n      remote_user: root\n      roles:\n      - common\n      - game\n      \n   \n    ansible-playbook -i test_hosts -e \"target=s1001\" -t createDB site.yml\n\n### 条件选择\n\n#### When 语句\n想忽略某一错误,通过执行成功与否来做决定,我们可以像这样:\n\n    tasks:\n      - command: /bin/false\n        register: result\n        ignore_errors: True\n      - command: /bin/something\n        when: result|failed\n      - command: /bin/something_else\n        when: result|success\n      - command: /bin/still/something_else\n        when: result|skipped\n如果想查看哪些事件在某个特定系统中时允许的,可以执行以下命令:\n\n    ansible hostname.example.com -m setup\n\n有些时候你得到一个返回参数的值是一个字符串,并且你还想使用数学操作来比较它,那么你可以执行一下操作:\n\n    tasks:\n      - shell: echo \"only on Red Hat 6, derivatives, and later\"\n        when: ansible_os_family == \"RedHat\" and ansible_lsb.major_release|int >= 6    \n\n#### 循环\n##### 标准循环\n为了保持简洁,重复的任务可以用以下简写的方式:\n\n    - name: add several users\n      user: name={{ item.name }} state=present groups={{ item.groups }}\n      with_items:\n        - { name: 'testuser1', groups: 'wheel' }\n        - { name: 'testuser2', groups: 'root' }\n  \n##### 嵌套循环\n\n    - name: give users access to multiple databases\n      mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL append_privs=yes password=foo\n      with_nested:\n        - [ 'alice', 'bob' ]\n        - [ 'clientdb', 'employeedb', 'providerdb' ]\n##### 对哈希表使用循环\n假如你有以下变量:\n    \n    ---\n    users:\n      alice:\n        name: Alice Appleworth\n        telephone: 123-456-7890\n      bob:\n        name: Bob Bananarama\n        telephone: 987-654-3210\n你想打印出每个用户的名称和电话号码.你可以使用 with_dict 来循环哈希表中的元素:\n\n    tasks:\n      - name: Print phone records\n        debug: msg=\"User {{ item.key }} is {{ item.value.name }} ({{ item.value.telephone }})\"\n        with_dict: \"{{users}}\"\n##### 对文件列表使用循环\n with_fileglob 可以以非递归的方式来模式匹配单个目录中的文件.如下面所示:\n \n    ---\n    - hosts: all\n    \n      tasks:\n    \n        # first ensure our target directory exists\n        - file: dest=/etc/fooapp state=directory\n    \n        # copy each file over that matches the given pattern\n        - copy: src={{ item }} dest=/etc/fooapp/ owner=root mode=600\n          with_fileglob:\n            - /playbooks/files/fooapp/*\n##### 对并行数据集使用循环 \n假设你通过某种方式加载了以下变量数据:\n\n     ---\n     alpha: [ 'a', 'b', 'c', 'd' ]\n     numbers:  [ 1, 2, 3, 4 ]   \n如果你想得到’(a, 1)’和’(b, 2)’之类的集合.可以使用’with_together’:\n\n    tasks:\n        - debug: msg=\"{{ item.0 }} and {{ item.1 }}\"\n          with_together:\n            - \"{{alpha}}\"\n            - \"{{numbers}}\"\n\n##### 对子元素使用循环\n\n假设你想对一组用户做一些动作,比如创建这些用户,并且允许它们使用一组SSH key来登录.\n\n如何实现那? 先假设你有按以下方式定义的数据,可以通过”vars_files”或”group_vars/all”文件加载:\n\n    ---\n    users:\n      - name: alice\n        authorized:\n          - /tmp/alice/onekey.pub\n          - /tmp/alice/twokey.pub\n        mysql:\n            password: mysql-password\n            hosts:\n              - \"%\"\n              - \"127.0.0.1\"\n              - \"::1\"\n              - \"localhost\"\n            privs:\n              - \"*.*:SELECT\"\n              - \"DB1.*:ALL\"\n      - name: bob\n        authorized:\n          - /tmp/bob/id_rsa.pub\n        mysql:\n            password: other-mysql-password\n            hosts:\n              - \"db1\"\n            privs:\n              - \"*.*:SELECT\"\n              - \"DB2.*:ALL\"\n那么可以这样实现:\n\n    - user: name={{ item.name }} state=present generate_ssh_key=yes\n      with_items: \"{{users}}\"\n    \n    - authorized_key: \"user={{ item.0.name }} key='{{ lookup('file', item.1) }}'\"\n      with_subelements:\n         - users\n         - authorized\n根据mysql hosts以及预先给定的privs subkey列表,我们也可以在嵌套的subkey中迭代列表:\n\n    - name: Setup MySQL users\n      mysql_user: name={{ item.0.user }} password={{ item.0.mysql.password }} host={{ item.1 }} priv={{ item.0.mysql.privs | join('/') }}\n      with_subelements:\n        - users\n        - mysql.hosts\n##### 对整数序列使用循环\n\nwith_sequence 可以以升序数字顺序生成一组序列.你可以指定起始值、终止值,以及一个可选的步长值.\n\n指定参数时也可以使用key=value这种键值对的方式.如果采用这种方式,’format’是一个可打印的字符串.\n\n数字值可以被指定为10进制,16进制(0x3f8)或者八进制(0600).负数则不受支持.请看以下示例:\n\n    ---\n    - hosts: all\n    \n      tasks:\n    \n        # create groups\n        - group: name=evens state=present\n        - group: name=odds state=present\n    \n        # create some test users\n        - user: name={{ item }} state=present groups=evens\n          with_sequence: start=0 end=32 format=testuser%02x\n    \n        # create a series of directories with even numbers for some reason\n        - file: dest=/var/stuff/{{ item }} state=directory\n          with_sequence: start=4 end=16 stride=2\n    \n        # a simpler way to use the sequence plugin\n        # create 4 groups\n        - group: name=group{{ item }} state=present\n          with_sequence: count=4\n##### 随机选择    \n‘random_choice’功能可以用来随机获取一些值.它并不是负载均衡器(已经有相关的模块了).它有时可以用作一个简化版的负载均衡器,比如作为条件判断:\n\n    - debug: msg={{ item }}\n      with_random_choice:\n         - \"go through the door\"\n         - \"drink from the goblet\"\n         - \"press the red button\"\n         - \"do nothing\"\n\n##### Do-Until循环\n有时你想重试一个任务直到达到某个条件.比如下面这个例子:  \n\n    - action: shell /usr/bin/foo\n      register: result\n      until: result.stdout.find(\"all systems go\") != -1\n      retries: 5\n      delay: 10\n##### 查找第一个匹配的文件         \n这其实不是一个循环,但和循环很相似.如果你想引用一个文件,而该文件是从一组文件中根据给定条件匹配出来的.这组文件中部分文件名由变量拼接而成.针对该场景你可以这样做:\n\n    - name: INTERFACES | Create Ansible header for /etc/network/interfaces\n      template: src={{ item }} dest=/etc/foo.conf\n      with_first_found:\n        - \"{{ansible_virtualization_type}}_foo.conf\"\n        - \"default_foo.conf\"\n该功能还有一个更完整的版本,可以配置搜索路径.请看以下示例:\n\n    - name: some configuration template\n      template: src={{ item }} dest=/etc/file.cfg mode=0444 owner=root group=root\n      with_first_found:\n        - files:\n           - \"{{inventory_hostname}}/etc/file.cfg\"\n          paths:\n           - ../../../templates.overwrites\n           - ../../../templates\n        - files:\n            - etc/file.cfg\n          paths:\n            - templates\n","source":"_posts/ansible应用.md","raw":"---\ntitle: ansible 应用\ntags:\n  - ansible\n  - 运维\ncategories:\n  - 后端\ncomments: false    // 是否开启评论\ndate: 2018-07-31 10:38:16\n---\n\n链接地址：[http://www.ansible.com.cn/docs/YAMLSyntax.html](http://www.ansible.com.cn/docs/YAMLSyntax.html)\n\n### 环境创建\n- 参考[Python-配置虚拟环境](./Python-配置虚拟环境.md),创建ansible的应用环境。\n- 安装：pip install ansible\n\n### 建立免密钥登陆\n为了避免Ansible下发指令时输入目标主机密码，通过证书签名达到SSH无密码是一个好的方案，推荐使用ssh-keygen与ssh-copy-id来实现快速证书的生成和公钥下发，其中ssh-keygen生成一对密钥，使用ssh-copy-id来下发生成的公钥。具体操作如下：\n生成管理主机得私钥和公钥\n    \n    ssh-keygen -t rsa -b 2048 -P '' -f /root/.ssh/id_rsa\n添加主机信息到主机清单中\n    \n    #host\n    192.168.77.129 ansible_ssh_pass=1234567\n    192.168.77.130 ansible_ssh_pass=123456   \n    \n ansible_ssh_pass密码如果一样的话，这里就不需要定义了。在运行ansible-playbook时 加上-k参数，就可以输入登陆密码\n\n配置palybook\n   \n    - hosts: testhosts\n     user: root\n     tasks:\n        - name: ssh-copy\n          authorized_key: user=root key=\"{{ lookup('file', '/Users/tpw-dev/.ssh/id_rsa.pub') }}\"\n          tags: sshkey\n\n运行playbook\n   \n    ansible-playbook -i hosts ssh-addkey.yml\n这样，管理节点的公钥就会添加到节点得authorized_keys文件中，再把主机清单里的ansible_ssh_pass去掉，执行ansible all -m ping 就不需要密码了。\n\n### Inventory(清单)文件\nAnsible 可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置. 默认的文件路径为 /etc/ansible/hosts，\n在执行ansible-book命令时，也可通过执行-i选项制定inventory 文件。\n\nInventory 参数的说明\n\n    ansible_ssh_host\n              将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\n        \n        ansible_ssh_port\n              ssh端口号.如果不是默认的端口号,通过此变量设置.\n        \n        ansible_ssh_user\n              默认的 ssh 用户名\n        \n        ansible_ssh_pass\n              ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)\n        \n        ansible_sudo_pass\n              sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\n        \n        ansible_sudo_exe (new in version 1.8)\n              sudo 命令路径(适用于1.8及以上版本)\n        \n        ansible_connection\n              与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 'smart','smart' 方式会根据是否支持 ControlPersist, 来判断'ssh' 方式是否可行.\n        \n        ansible_ssh_private_key_file\n              ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.\n        \n        ansible_shell_type\n              目标系统的shell类型.默认情况下,命令的执行使用 'sh' 语法,可设置为 'csh' 或 'fish'.\n        \n        ansible_python_interpreter\n              目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是\"/usr/bin/python\",比如  \\*BSD, 或者 /usr/bin/python\n              不是 2.X 版本的 Python.我们不使用 \"/usr/bin/env\" 机制,因为这要求远程用户的路径设置正确,且要求 \"python\" 可执行程序名不可为 python以外的名字(实际有可能名为python26).\n              与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....\n\n    \n### Playbooks 介绍\nplaybook 由一个或多个 ‘plays’ 组成.它的内容是一个以 ‘plays’ 为元素的列表.在 ansible 中,play 的内容,被称为 tasks,即任务.\n\n这里有一个 playbook,其中仅包含一个 play:\n\n    ---\n    - hosts: webservers\n      vars:\n        http_port: 80\n        max_clients: 200\n      remote_user: root\n      tasks:\n      - name: ensure apache is at the latest version\n        yum: pkg=httpd state=latest\n      - name: write the apache config file\n        template: src=/srv/httpd.j2 dest=/etc/httpd.conf\n        notify:\n        - restart apache\n#### playbook基础\n\n##### 主机与用户\n\n**hosts 行的内容是一个或多个组或主机的 patterns,以逗号为分隔符**\n\nremote_user 就是账户名:\n\n    ---\n    - hosts: webservers\n      remote_user: root\n      \n##### Tasks 列表\n\n每一个 play 包含了一个 task 列表（任务列表）.一个 task 在其所对应的所有主机上（通过 host pattern 匹配的所有主机）执行完毕之后,下一个 task 才会执行.\n每个 task 的目标在于执行一个 moudle,modules 具有”幂等”性,意思是如果你再一次地执行 moudle,moudle 只会执行必要的改动,只会改变需要改变的地方.所以重复多次执行 playbook 也很安全.\n下面是一种基本的 task 的定义,service moudle 使用 key=value 格式的参数,这也是大多数 module 使用的参数格式:\n\n    tasks:\n      - name: make sure apache is running\n        service: name=httpd state=running\n比较特别的两个 modudle 是 command 和 shell ,它们不使用 key=value 格式的参数,而是这样:\n\n    tasks:\n      - name: disable selinux\n        command: /sbin/setenforce 0\n        \n**tasks可添加biaoqian(tags),这样在执行命令时可制定tasks**\n如下：\n\n    - name: Create Base folder\n        file:\n          path: \"{{baseDeployPathPrefix}}{{serverId}}\"\n          state: directory\n        tags: system\n      - name: copy redis dir \n        synchronize:\n          src: redis-4.0.10\n          dest: \"{{baseDeployPathPrefix}}{{serverId}}\"\n        tags: redis\n     \n     ansible-playbook -i test_hosts -e \"target=s1001\" -t createDB site.yml   \n        \n-t 后跟tags，这样就可以指定要执行的tasks\n    \n\n##### Handlers: 在发生改变时执行的操作\n(当发生改动时）’notify’ actions 会在 playbook 的每一个 task 结束时被触发,而且即使有多个不同的 task 通知改动的发生, ‘notify’ actions 只会被触发一次.\n\n这里有一个例子,当一个文件的内容被改动时,重启两个 services:\n\n    - name: template configuration file\n      template: src=template.j2 dest=/etc/foo.conf\n      notify:\n         - restart memcached\n         - restart apache\n‘notify’ 下列出的即是 handlers.\n\nHandlers 是由通知者进行 notify, 如果没有被 notify,handlers 不会执行.\n\n这里是一个 handlers 的示例:\n\n    handlers:\n        - name: restart memcached\n          service:  name=memcached state=restarted\n        - name: restart apache\n          service: name=apache state=restarted\n**handlers 会按照声明的顺序执行**\n\n##### 提示与技巧\n如果想看到执行成功的 modules 的输出信息,使用 --verbose flag（否则只有执行失败的才会有输出信息）.\n\n在执行一个 playbook 之前,想看看这个 playbook 的执行会影响到哪些 hosts,你可以这样做:\n\n    ansible-playbook playbook.yml --list-hosts\n\n\n### Roles\n一个项目的结构如下:\n\n    site.yml\n    webservers.yml\n    fooservers.yml\n    roles/\n       common/\n         files/\n         templates/\n         tasks/\n         handlers/\n         vars/\n         defaults/\n         meta/\n       webservers/\n         files/\n         templates/\n         tasks/\n         handlers/\n         vars/\n         defaults/\n         meta/\n一个 playbook 如下:\n\n    ---\n    - hosts: webservers\n      roles:\n         - common\n         - webservers\n这个 playbook 为一个角色 ‘x’ 指定了如下的行为：\n\n- 如果 roles/x/tasks/main.yml 存在, 其中列出的 tasks 将被添加到 play 中\n- 如果 roles/x/handlers/main.yml 存在, 其中列出的 handlers 将被添加到 play 中\n-  如果 roles/x/vars/main.yml 存在, 其中列出的 variables 将被添加到 play 中\n-  如果 roles/x/meta/main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中 (1.3 and later)\n-  所有 copy tasks 可以引用 roles/x/files/ 中的文件，不需要指明文件的路径。\n-  所有 script tasks 可以引用 roles/x/files/ 中的脚本，不需要指明文件的路径。\n-  所有 template tasks 可以引用 roles/x/templates/ 中的文件，不需要指明文件的路径。\n-  所有 include tasks 可以引用 roles/x/tasks/ 中的文件，不需要指明文件的路径。    \n\n如果你希望定义一些 tasks，让它们在 roles 之前以及之后执行，你可以这样做:\n\n    ---\n    \n    - hosts: webservers\n    \n      pre_tasks:\n        - shell: echo 'hello'\n    \n      roles:\n        - { role: some_role }\n    \n      tasks:\n        - shell: echo 'still busy'\n    \n      post_tasks:\n        - shell: echo 'goodbye'\n**值得指出的是,handlers 会在 ‘pre_tasks’, ‘roles’, ‘tasks’, 和 ‘post_tasks’ 之间自动执行. 如果你想立即执行所有的 handler 命令.**\n\n    tasks:\n       - shell: some tasks go here\n       - meta: flush_handlers\n       - shell: some other tasks\n#### Ansible Galaxy\n[Ansible Galaxy](https://galaxy.ansible.com/home) 是一个自由网站，网站提供所有类型的由社区开发的 roles，这对于实现你的自动化项目是一个很好的参考。网站提供这些 roles 的排名、查找以及下载。\n\n### Variables(变量)\n\n#### 定义变量\n- 在Inventory中定义变量\n- 在playbook中定义变量\n- 在文件和role中定义变量\n#### 使用变量: 关于Jinja2\n变量替换最基本的形式:\n\n    template: src=foo.cfg.j2 dest={{ remote_install_path }}/foo.cfg\n#### YAML陷阱\nYAML语法要求如果值以{{ foo }}开头的话我们需要将整行用双引号包起来.这是为了确认你不是想声明一个YAML字典.\n\n这样是不行的:\n    \n    - hosts: app_servers\n      vars:\n          app_path: {{ base_path }}/22\n你应该这么做:\n    - hosts: app_servers\n      vars:\n           app_path: \"{{ base_path }}/22\"\n\n#### Facts\nFacts通过访问远程系统获取相应的信息. 一个例子就是远程主机的IP地址或者操作系统是什么. 使用以下命令可以查看哪些信息是可用的:\n\n    ansible hostname -m setup\n这会返回巨量的变量数据,默认是生成这些信息的，可以在playbook中这样引用远程系统的主机名\n\n    {{ ansible_nodename }}\n关闭Facts\n\n    - hosts: whatever\n      gather_facts: no\n#### Fact缓存\n因为缓存的存在，从一个服务器引用另一个服务器的变量是可行的.\n\n    {{ hostvars['asdf.example.com']['ansible_os_family'] }}\n\n#### 命令行中传递变量\n除了`vars_prompt`和`vars_files`也可以通过Ansible命令行发送变量.如果你想编写一个通用的发布playbook时则特别有用,你可以传递应用的版本以便部署:\n    \n    ---\n    - hosts: \"{{ target }}\"\n      gather_facts: false\n      remote_user: root\n      roles:\n      - common\n      - game\n      \n   \n    ansible-playbook -i test_hosts -e \"target=s1001\" -t createDB site.yml\n\n### 条件选择\n\n#### When 语句\n想忽略某一错误,通过执行成功与否来做决定,我们可以像这样:\n\n    tasks:\n      - command: /bin/false\n        register: result\n        ignore_errors: True\n      - command: /bin/something\n        when: result|failed\n      - command: /bin/something_else\n        when: result|success\n      - command: /bin/still/something_else\n        when: result|skipped\n如果想查看哪些事件在某个特定系统中时允许的,可以执行以下命令:\n\n    ansible hostname.example.com -m setup\n\n有些时候你得到一个返回参数的值是一个字符串,并且你还想使用数学操作来比较它,那么你可以执行一下操作:\n\n    tasks:\n      - shell: echo \"only on Red Hat 6, derivatives, and later\"\n        when: ansible_os_family == \"RedHat\" and ansible_lsb.major_release|int >= 6    \n\n#### 循环\n##### 标准循环\n为了保持简洁,重复的任务可以用以下简写的方式:\n\n    - name: add several users\n      user: name={{ item.name }} state=present groups={{ item.groups }}\n      with_items:\n        - { name: 'testuser1', groups: 'wheel' }\n        - { name: 'testuser2', groups: 'root' }\n  \n##### 嵌套循环\n\n    - name: give users access to multiple databases\n      mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL append_privs=yes password=foo\n      with_nested:\n        - [ 'alice', 'bob' ]\n        - [ 'clientdb', 'employeedb', 'providerdb' ]\n##### 对哈希表使用循环\n假如你有以下变量:\n    \n    ---\n    users:\n      alice:\n        name: Alice Appleworth\n        telephone: 123-456-7890\n      bob:\n        name: Bob Bananarama\n        telephone: 987-654-3210\n你想打印出每个用户的名称和电话号码.你可以使用 with_dict 来循环哈希表中的元素:\n\n    tasks:\n      - name: Print phone records\n        debug: msg=\"User {{ item.key }} is {{ item.value.name }} ({{ item.value.telephone }})\"\n        with_dict: \"{{users}}\"\n##### 对文件列表使用循环\n with_fileglob 可以以非递归的方式来模式匹配单个目录中的文件.如下面所示:\n \n    ---\n    - hosts: all\n    \n      tasks:\n    \n        # first ensure our target directory exists\n        - file: dest=/etc/fooapp state=directory\n    \n        # copy each file over that matches the given pattern\n        - copy: src={{ item }} dest=/etc/fooapp/ owner=root mode=600\n          with_fileglob:\n            - /playbooks/files/fooapp/*\n##### 对并行数据集使用循环 \n假设你通过某种方式加载了以下变量数据:\n\n     ---\n     alpha: [ 'a', 'b', 'c', 'd' ]\n     numbers:  [ 1, 2, 3, 4 ]   \n如果你想得到’(a, 1)’和’(b, 2)’之类的集合.可以使用’with_together’:\n\n    tasks:\n        - debug: msg=\"{{ item.0 }} and {{ item.1 }}\"\n          with_together:\n            - \"{{alpha}}\"\n            - \"{{numbers}}\"\n\n##### 对子元素使用循环\n\n假设你想对一组用户做一些动作,比如创建这些用户,并且允许它们使用一组SSH key来登录.\n\n如何实现那? 先假设你有按以下方式定义的数据,可以通过”vars_files”或”group_vars/all”文件加载:\n\n    ---\n    users:\n      - name: alice\n        authorized:\n          - /tmp/alice/onekey.pub\n          - /tmp/alice/twokey.pub\n        mysql:\n            password: mysql-password\n            hosts:\n              - \"%\"\n              - \"127.0.0.1\"\n              - \"::1\"\n              - \"localhost\"\n            privs:\n              - \"*.*:SELECT\"\n              - \"DB1.*:ALL\"\n      - name: bob\n        authorized:\n          - /tmp/bob/id_rsa.pub\n        mysql:\n            password: other-mysql-password\n            hosts:\n              - \"db1\"\n            privs:\n              - \"*.*:SELECT\"\n              - \"DB2.*:ALL\"\n那么可以这样实现:\n\n    - user: name={{ item.name }} state=present generate_ssh_key=yes\n      with_items: \"{{users}}\"\n    \n    - authorized_key: \"user={{ item.0.name }} key='{{ lookup('file', item.1) }}'\"\n      with_subelements:\n         - users\n         - authorized\n根据mysql hosts以及预先给定的privs subkey列表,我们也可以在嵌套的subkey中迭代列表:\n\n    - name: Setup MySQL users\n      mysql_user: name={{ item.0.user }} password={{ item.0.mysql.password }} host={{ item.1 }} priv={{ item.0.mysql.privs | join('/') }}\n      with_subelements:\n        - users\n        - mysql.hosts\n##### 对整数序列使用循环\n\nwith_sequence 可以以升序数字顺序生成一组序列.你可以指定起始值、终止值,以及一个可选的步长值.\n\n指定参数时也可以使用key=value这种键值对的方式.如果采用这种方式,’format’是一个可打印的字符串.\n\n数字值可以被指定为10进制,16进制(0x3f8)或者八进制(0600).负数则不受支持.请看以下示例:\n\n    ---\n    - hosts: all\n    \n      tasks:\n    \n        # create groups\n        - group: name=evens state=present\n        - group: name=odds state=present\n    \n        # create some test users\n        - user: name={{ item }} state=present groups=evens\n          with_sequence: start=0 end=32 format=testuser%02x\n    \n        # create a series of directories with even numbers for some reason\n        - file: dest=/var/stuff/{{ item }} state=directory\n          with_sequence: start=4 end=16 stride=2\n    \n        # a simpler way to use the sequence plugin\n        # create 4 groups\n        - group: name=group{{ item }} state=present\n          with_sequence: count=4\n##### 随机选择    \n‘random_choice’功能可以用来随机获取一些值.它并不是负载均衡器(已经有相关的模块了).它有时可以用作一个简化版的负载均衡器,比如作为条件判断:\n\n    - debug: msg={{ item }}\n      with_random_choice:\n         - \"go through the door\"\n         - \"drink from the goblet\"\n         - \"press the red button\"\n         - \"do nothing\"\n\n##### Do-Until循环\n有时你想重试一个任务直到达到某个条件.比如下面这个例子:  \n\n    - action: shell /usr/bin/foo\n      register: result\n      until: result.stdout.find(\"all systems go\") != -1\n      retries: 5\n      delay: 10\n##### 查找第一个匹配的文件         \n这其实不是一个循环,但和循环很相似.如果你想引用一个文件,而该文件是从一组文件中根据给定条件匹配出来的.这组文件中部分文件名由变量拼接而成.针对该场景你可以这样做:\n\n    - name: INTERFACES | Create Ansible header for /etc/network/interfaces\n      template: src={{ item }} dest=/etc/foo.conf\n      with_first_found:\n        - \"{{ansible_virtualization_type}}_foo.conf\"\n        - \"default_foo.conf\"\n该功能还有一个更完整的版本,可以配置搜索路径.请看以下示例:\n\n    - name: some configuration template\n      template: src={{ item }} dest=/etc/file.cfg mode=0444 owner=root group=root\n      with_first_found:\n        - files:\n           - \"{{inventory_hostname}}/etc/file.cfg\"\n          paths:\n           - ../../../templates.overwrites\n           - ../../../templates\n        - files:\n            - etc/file.cfg\n          paths:\n            - templates\n","slug":"ansible应用","published":1,"updated":"2019-01-09T09:50:41.368Z","layout":"post","photos":[],"link":"","_id":"cjqp0aijk003ey0w00pr388pi","content":"<p>链接地址：<a href=\"http://www.ansible.com.cn/docs/YAMLSyntax.html\" target=\"_blank\" rel=\"noopener\">http://www.ansible.com.cn/docs/YAMLSyntax.html</a></p>\n<h3 id=\"环境创建\"><a href=\"#环境创建\" class=\"headerlink\" title=\"环境创建\"></a>环境创建</h3><ul>\n<li>参考<a href=\"./Python-配置虚拟环境.md\">Python-配置虚拟环境</a>,创建ansible的应用环境。</li>\n<li>安装：pip install ansible</li>\n</ul>\n<h3 id=\"建立免密钥登陆\"><a href=\"#建立免密钥登陆\" class=\"headerlink\" title=\"建立免密钥登陆\"></a>建立免密钥登陆</h3><p>为了避免Ansible下发指令时输入目标主机密码，通过证书签名达到SSH无密码是一个好的方案，推荐使用ssh-keygen与ssh-copy-id来实现快速证书的生成和公钥下发，其中ssh-keygen生成一对密钥，使用ssh-copy-id来下发生成的公钥。具体操作如下：<br>生成管理主机得私钥和公钥</p>\n<pre><code>ssh-keygen -t rsa -b 2048 -P &apos;&apos; -f /root/.ssh/id_rsa\n</code></pre><p>添加主机信息到主机清单中</p>\n<pre><code>#host\n192.168.77.129 ansible_ssh_pass=1234567\n192.168.77.130 ansible_ssh_pass=123456   \n</code></pre><p> ansible_ssh_pass密码如果一样的话，这里就不需要定义了。在运行ansible-playbook时 加上-k参数，就可以输入登陆密码</p>\n<p>配置palybook</p>\n<pre><code>- hosts: testhosts\n user: root\n tasks:\n    - name: ssh-copy\n      authorized_key: user=root key=&quot;{{ lookup('file', '/Users/tpw-dev/.ssh/id_rsa.pub') }}&quot;\n      tags: sshkey\n</code></pre><p>运行playbook</p>\n<pre><code>ansible-playbook -i hosts ssh-addkey.yml\n</code></pre><p>这样，管理节点的公钥就会添加到节点得authorized_keys文件中，再把主机清单里的ansible_ssh_pass去掉，执行ansible all -m ping 就不需要密码了。</p>\n<h3 id=\"Inventory-清单-文件\"><a href=\"#Inventory-清单-文件\" class=\"headerlink\" title=\"Inventory(清单)文件\"></a>Inventory(清单)文件</h3><p>Ansible 可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置. 默认的文件路径为 /etc/ansible/hosts，<br>在执行ansible-book命令时，也可通过执行-i选项制定inventory 文件。</p>\n<p>Inventory 参数的说明</p>\n<pre><code>ansible_ssh_host\n          将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\n\n    ansible_ssh_port\n          ssh端口号.如果不是默认的端口号,通过此变量设置.\n\n    ansible_ssh_user\n          默认的 ssh 用户名\n\n    ansible_ssh_pass\n          ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)\n\n    ansible_sudo_pass\n          sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\n\n    ansible_sudo_exe (new in version 1.8)\n          sudo 命令路径(适用于1.8及以上版本)\n\n    ansible_connection\n          与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 &apos;smart&apos;,&apos;smart&apos; 方式会根据是否支持 ControlPersist, 来判断&apos;ssh&apos; 方式是否可行.\n\n    ansible_ssh_private_key_file\n          ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.\n\n    ansible_shell_type\n          目标系统的shell类型.默认情况下,命令的执行使用 &apos;sh&apos; 语法,可设置为 &apos;csh&apos; 或 &apos;fish&apos;.\n\n    ansible_python_interpreter\n          目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \\*BSD, 或者 /usr/bin/python\n          不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26).\n          与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....\n</code></pre><h3 id=\"Playbooks-介绍\"><a href=\"#Playbooks-介绍\" class=\"headerlink\" title=\"Playbooks 介绍\"></a>Playbooks 介绍</h3><p>playbook 由一个或多个 ‘plays’ 组成.它的内容是一个以 ‘plays’ 为元素的列表.在 ansible 中,play 的内容,被称为 tasks,即任务.</p>\n<p>这里有一个 playbook,其中仅包含一个 play:</p>\n<pre><code>---\n- hosts: webservers\n  vars:\n    http_port: 80\n    max_clients: 200\n  remote_user: root\n  tasks:\n  - name: ensure apache is at the latest version\n    yum: pkg=httpd state=latest\n  - name: write the apache config file\n    template: src=/srv/httpd.j2 dest=/etc/httpd.conf\n    notify:\n    - restart apache\n</code></pre><h4 id=\"playbook基础\"><a href=\"#playbook基础\" class=\"headerlink\" title=\"playbook基础\"></a>playbook基础</h4><h5 id=\"主机与用户\"><a href=\"#主机与用户\" class=\"headerlink\" title=\"主机与用户\"></a>主机与用户</h5><p><strong>hosts 行的内容是一个或多个组或主机的 patterns,以逗号为分隔符</strong></p>\n<p>remote_user 就是账户名:</p>\n<pre><code>---\n- hosts: webservers\n  remote_user: root\n</code></pre><h5 id=\"Tasks-列表\"><a href=\"#Tasks-列表\" class=\"headerlink\" title=\"Tasks 列表\"></a>Tasks 列表</h5><p>每一个 play 包含了一个 task 列表（任务列表）.一个 task 在其所对应的所有主机上（通过 host pattern 匹配的所有主机）执行完毕之后,下一个 task 才会执行.<br>每个 task 的目标在于执行一个 moudle,modules 具有”幂等”性,意思是如果你再一次地执行 moudle,moudle 只会执行必要的改动,只会改变需要改变的地方.所以重复多次执行 playbook 也很安全.<br>下面是一种基本的 task 的定义,service moudle 使用 key=value 格式的参数,这也是大多数 module 使用的参数格式:</p>\n<pre><code>tasks:\n  - name: make sure apache is running\n    service: name=httpd state=running\n</code></pre><p>比较特别的两个 modudle 是 command 和 shell ,它们不使用 key=value 格式的参数,而是这样:</p>\n<pre><code>tasks:\n  - name: disable selinux\n    command: /sbin/setenforce 0\n</code></pre><p><strong>tasks可添加biaoqian(tags),这样在执行命令时可制定tasks</strong><br>如下：</p>\n<pre><code>- name: Create Base folder\n    file:\n      path: &quot;{{baseDeployPathPrefix}}{{serverId}}&quot;\n      state: directory\n    tags: system\n  - name: copy redis dir \n    synchronize:\n      src: redis-4.0.10\n      dest: &quot;{{baseDeployPathPrefix}}{{serverId}}&quot;\n    tags: redis\n\n ansible-playbook -i test_hosts -e &quot;target=s1001&quot; -t createDB site.yml   \n</code></pre><p>-t 后跟tags，这样就可以指定要执行的tasks</p>\n<h5 id=\"Handlers-在发生改变时执行的操作\"><a href=\"#Handlers-在发生改变时执行的操作\" class=\"headerlink\" title=\"Handlers: 在发生改变时执行的操作\"></a>Handlers: 在发生改变时执行的操作</h5><p>(当发生改动时）’notify’ actions 会在 playbook 的每一个 task 结束时被触发,而且即使有多个不同的 task 通知改动的发生, ‘notify’ actions 只会被触发一次.</p>\n<p>这里有一个例子,当一个文件的内容被改动时,重启两个 services:</p>\n<pre><code>- name: template configuration file\n  template: src=template.j2 dest=/etc/foo.conf\n  notify:\n     - restart memcached\n     - restart apache\n</code></pre><p>‘notify’ 下列出的即是 handlers.</p>\n<p>Handlers 是由通知者进行 notify, 如果没有被 notify,handlers 不会执行.</p>\n<p>这里是一个 handlers 的示例:</p>\n<pre><code>handlers:\n    - name: restart memcached\n      service:  name=memcached state=restarted\n    - name: restart apache\n      service: name=apache state=restarted\n</code></pre><p><strong>handlers 会按照声明的顺序执行</strong></p>\n<h5 id=\"提示与技巧\"><a href=\"#提示与技巧\" class=\"headerlink\" title=\"提示与技巧\"></a>提示与技巧</h5><p>如果想看到执行成功的 modules 的输出信息,使用 –verbose flag（否则只有执行失败的才会有输出信息）.</p>\n<p>在执行一个 playbook 之前,想看看这个 playbook 的执行会影响到哪些 hosts,你可以这样做:</p>\n<pre><code>ansible-playbook playbook.yml --list-hosts\n</code></pre><h3 id=\"Roles\"><a href=\"#Roles\" class=\"headerlink\" title=\"Roles\"></a>Roles</h3><p>一个项目的结构如下:</p>\n<pre><code>site.yml\nwebservers.yml\nfooservers.yml\nroles/\n   common/\n     files/\n     templates/\n     tasks/\n     handlers/\n     vars/\n     defaults/\n     meta/\n   webservers/\n     files/\n     templates/\n     tasks/\n     handlers/\n     vars/\n     defaults/\n     meta/\n</code></pre><p>一个 playbook 如下:</p>\n<pre><code>---\n- hosts: webservers\n  roles:\n     - common\n     - webservers\n</code></pre><p>这个 playbook 为一个角色 ‘x’ 指定了如下的行为：</p>\n<ul>\n<li>如果 roles/x/tasks/main.yml 存在, 其中列出的 tasks 将被添加到 play 中</li>\n<li>如果 roles/x/handlers/main.yml 存在, 其中列出的 handlers 将被添加到 play 中</li>\n<li>如果 roles/x/vars/main.yml 存在, 其中列出的 variables 将被添加到 play 中</li>\n<li>如果 roles/x/meta/main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中 (1.3 and later)</li>\n<li>所有 copy tasks 可以引用 roles/x/files/ 中的文件，不需要指明文件的路径。</li>\n<li>所有 script tasks 可以引用 roles/x/files/ 中的脚本，不需要指明文件的路径。</li>\n<li>所有 template tasks 可以引用 roles/x/templates/ 中的文件，不需要指明文件的路径。</li>\n<li>所有 include tasks 可以引用 roles/x/tasks/ 中的文件，不需要指明文件的路径。    </li>\n</ul>\n<p>如果你希望定义一些 tasks，让它们在 roles 之前以及之后执行，你可以这样做:</p>\n<pre><code>---\n\n- hosts: webservers\n\n  pre_tasks:\n    - shell: echo &apos;hello&apos;\n\n  roles:\n    - { role: some_role }\n\n  tasks:\n    - shell: echo &apos;still busy&apos;\n\n  post_tasks:\n    - shell: echo &apos;goodbye&apos;\n</code></pre><p><strong>值得指出的是,handlers 会在 ‘pre_tasks’, ‘roles’, ‘tasks’, 和 ‘post_tasks’ 之间自动执行. 如果你想立即执行所有的 handler 命令.</strong></p>\n<pre><code>tasks:\n   - shell: some tasks go here\n   - meta: flush_handlers\n   - shell: some other tasks\n</code></pre><h4 id=\"Ansible-Galaxy\"><a href=\"#Ansible-Galaxy\" class=\"headerlink\" title=\"Ansible Galaxy\"></a>Ansible Galaxy</h4><p><a href=\"https://galaxy.ansible.com/home\" target=\"_blank\" rel=\"noopener\">Ansible Galaxy</a> 是一个自由网站，网站提供所有类型的由社区开发的 roles，这对于实现你的自动化项目是一个很好的参考。网站提供这些 roles 的排名、查找以及下载。</p>\n<h3 id=\"Variables-变量\"><a href=\"#Variables-变量\" class=\"headerlink\" title=\"Variables(变量)\"></a>Variables(变量)</h3><h4 id=\"定义变量\"><a href=\"#定义变量\" class=\"headerlink\" title=\"定义变量\"></a>定义变量</h4><ul>\n<li>在Inventory中定义变量</li>\n<li>在playbook中定义变量</li>\n<li><p>在文件和role中定义变量</p>\n<h4 id=\"使用变量-关于Jinja2\"><a href=\"#使用变量-关于Jinja2\" class=\"headerlink\" title=\"使用变量: 关于Jinja2\"></a>使用变量: 关于Jinja2</h4><p>变量替换最基本的形式:</p>\n<p>  template: src=foo.cfg.j2 dest=/foo.cfg</p>\n<h4 id=\"YAML陷阱\"><a href=\"#YAML陷阱\" class=\"headerlink\" title=\"YAML陷阱\"></a>YAML陷阱</h4><p>YAML语法要求如果值以开头的话我们需要将整行用双引号包起来.这是为了确认你不是想声明一个YAML字典.</p>\n</li>\n</ul>\n<p>这样是不行的:</p>\n<pre><code>- hosts: app_servers\n  vars:\n      app_path: {{ base_path }}/22\n</code></pre><p>你应该这么做:</p>\n<pre><code>- hosts: app_servers\n  vars:\n       app_path: &quot;{{ base_path }}/22&quot;\n</code></pre><h4 id=\"Facts\"><a href=\"#Facts\" class=\"headerlink\" title=\"Facts\"></a>Facts</h4><p>Facts通过访问远程系统获取相应的信息. 一个例子就是远程主机的IP地址或者操作系统是什么. 使用以下命令可以查看哪些信息是可用的:</p>\n<pre><code>ansible hostname -m setup\n</code></pre><p>这会返回巨量的变量数据,默认是生成这些信息的，可以在playbook中这样引用远程系统的主机名</p>\n<pre><code>{{ ansible_nodename }}\n</code></pre><p>关闭Facts</p>\n<pre><code>- hosts: whatever\n  gather_facts: no\n</code></pre><h4 id=\"Fact缓存\"><a href=\"#Fact缓存\" class=\"headerlink\" title=\"Fact缓存\"></a>Fact缓存</h4><p>因为缓存的存在，从一个服务器引用另一个服务器的变量是可行的.</p>\n<pre><code>{{ hostvars['asdf.example.com']['ansible_os_family'] }}\n</code></pre><h4 id=\"命令行中传递变量\"><a href=\"#命令行中传递变量\" class=\"headerlink\" title=\"命令行中传递变量\"></a>命令行中传递变量</h4><p>除了<code>vars_prompt</code>和<code>vars_files</code>也可以通过Ansible命令行发送变量.如果你想编写一个通用的发布playbook时则特别有用,你可以传递应用的版本以便部署:</p>\n<pre><code>---\n- hosts: &quot;{{ target }}&quot;\n  gather_facts: false\n  remote_user: root\n  roles:\n  - common\n  - game\n\n\nansible-playbook -i test_hosts -e &quot;target=s1001&quot; -t createDB site.yml\n</code></pre><h3 id=\"条件选择\"><a href=\"#条件选择\" class=\"headerlink\" title=\"条件选择\"></a>条件选择</h3><h4 id=\"When-语句\"><a href=\"#When-语句\" class=\"headerlink\" title=\"When 语句\"></a>When 语句</h4><p>想忽略某一错误,通过执行成功与否来做决定,我们可以像这样:</p>\n<pre><code>tasks:\n  - command: /bin/false\n    register: result\n    ignore_errors: True\n  - command: /bin/something\n    when: result|failed\n  - command: /bin/something_else\n    when: result|success\n  - command: /bin/still/something_else\n    when: result|skipped\n</code></pre><p>如果想查看哪些事件在某个特定系统中时允许的,可以执行以下命令:</p>\n<pre><code>ansible hostname.example.com -m setup\n</code></pre><p>有些时候你得到一个返回参数的值是一个字符串,并且你还想使用数学操作来比较它,那么你可以执行一下操作:</p>\n<pre><code>tasks:\n  - shell: echo &quot;only on Red Hat 6, derivatives, and later&quot;\n    when: ansible_os_family == &quot;RedHat&quot; and ansible_lsb.major_release|int &gt;= 6    \n</code></pre><h4 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h4><h5 id=\"标准循环\"><a href=\"#标准循环\" class=\"headerlink\" title=\"标准循环\"></a>标准循环</h5><p>为了保持简洁,重复的任务可以用以下简写的方式:</p>\n<pre><code>- name: add several users\n  user: name={{ item.name }} state=present groups={{ item.groups }}\n  with_items:\n    - { name: &apos;testuser1&apos;, groups: &apos;wheel&apos; }\n    - { name: &apos;testuser2&apos;, groups: &apos;root&apos; }\n</code></pre><h5 id=\"嵌套循环\"><a href=\"#嵌套循环\" class=\"headerlink\" title=\"嵌套循环\"></a>嵌套循环</h5><pre><code>- name: give users access to multiple databases\n  mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL append_privs=yes password=foo\n  with_nested:\n    - [ &apos;alice&apos;, &apos;bob&apos; ]\n    - [ &apos;clientdb&apos;, &apos;employeedb&apos;, &apos;providerdb&apos; ]\n</code></pre><h5 id=\"对哈希表使用循环\"><a href=\"#对哈希表使用循环\" class=\"headerlink\" title=\"对哈希表使用循环\"></a>对哈希表使用循环</h5><p>假如你有以下变量:</p>\n<pre><code>---\nusers:\n  alice:\n    name: Alice Appleworth\n    telephone: 123-456-7890\n  bob:\n    name: Bob Bananarama\n    telephone: 987-654-3210\n</code></pre><p>你想打印出每个用户的名称和电话号码.你可以使用 with_dict 来循环哈希表中的元素:</p>\n<pre><code>tasks:\n  - name: Print phone records\n    debug: msg=&quot;User {{ item.key }} is {{ item.value.name }} ({{ item.value.telephone }})&quot;\n    with_dict: &quot;{{users}}&quot;\n</code></pre><h5 id=\"对文件列表使用循环\"><a href=\"#对文件列表使用循环\" class=\"headerlink\" title=\"对文件列表使用循环\"></a>对文件列表使用循环</h5><p> with_fileglob 可以以非递归的方式来模式匹配单个目录中的文件.如下面所示:</p>\n<pre><code>---\n- hosts: all\n\n  tasks:\n\n    # first ensure our target directory exists\n    - file: dest=/etc/fooapp state=directory\n\n    # copy each file over that matches the given pattern\n    - copy: src={{ item }} dest=/etc/fooapp/ owner=root mode=600\n      with_fileglob:\n        - /playbooks/files/fooapp/*\n</code></pre><h5 id=\"对并行数据集使用循环\"><a href=\"#对并行数据集使用循环\" class=\"headerlink\" title=\"对并行数据集使用循环\"></a>对并行数据集使用循环</h5><p>假设你通过某种方式加载了以下变量数据:</p>\n<pre><code>---\nalpha: [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]\nnumbers:  [ 1, 2, 3, 4 ]   \n</code></pre><p>如果你想得到’(a, 1)’和’(b, 2)’之类的集合.可以使用’with_together’:</p>\n<pre><code>tasks:\n    - debug: msg=&quot;{{ item.0 }} and {{ item.1 }}&quot;\n      with_together:\n        - &quot;{{alpha}}&quot;\n        - &quot;{{numbers}}&quot;\n</code></pre><h5 id=\"对子元素使用循环\"><a href=\"#对子元素使用循环\" class=\"headerlink\" title=\"对子元素使用循环\"></a>对子元素使用循环</h5><p>假设你想对一组用户做一些动作,比如创建这些用户,并且允许它们使用一组SSH key来登录.</p>\n<p>如何实现那? 先假设你有按以下方式定义的数据,可以通过”vars_files”或”group_vars/all”文件加载:</p>\n<pre><code>---\nusers:\n  - name: alice\n    authorized:\n      - /tmp/alice/onekey.pub\n      - /tmp/alice/twokey.pub\n    mysql:\n        password: mysql-password\n        hosts:\n          - &quot;%&quot;\n          - &quot;127.0.0.1&quot;\n          - &quot;::1&quot;\n          - &quot;localhost&quot;\n        privs:\n          - &quot;*.*:SELECT&quot;\n          - &quot;DB1.*:ALL&quot;\n  - name: bob\n    authorized:\n      - /tmp/bob/id_rsa.pub\n    mysql:\n        password: other-mysql-password\n        hosts:\n          - &quot;db1&quot;\n        privs:\n          - &quot;*.*:SELECT&quot;\n          - &quot;DB2.*:ALL&quot;\n</code></pre><p>那么可以这样实现:</p>\n<pre><code>- user: name={{ item.name }} state=present generate_ssh_key=yes\n  with_items: &quot;{{users}}&quot;\n\n- authorized_key: &quot;user={{ item.0.name }} key=&apos;{{ lookup('file', item.1) }}&apos;&quot;\n  with_subelements:\n     - users\n     - authorized\n</code></pre><p>根据mysql hosts以及预先给定的privs subkey列表,我们也可以在嵌套的subkey中迭代列表:</p>\n<pre><code>- name: Setup MySQL users\n  mysql_user: name={{ item.0.user }} password={{ item.0.mysql.password }} host={{ item.1 }} priv={{ item.0.mysql.privs | join('/') }}\n  with_subelements:\n    - users\n    - mysql.hosts\n</code></pre><h5 id=\"对整数序列使用循环\"><a href=\"#对整数序列使用循环\" class=\"headerlink\" title=\"对整数序列使用循环\"></a>对整数序列使用循环</h5><p>with_sequence 可以以升序数字顺序生成一组序列.你可以指定起始值、终止值,以及一个可选的步长值.</p>\n<p>指定参数时也可以使用key=value这种键值对的方式.如果采用这种方式,’format’是一个可打印的字符串.</p>\n<p>数字值可以被指定为10进制,16进制(0x3f8)或者八进制(0600).负数则不受支持.请看以下示例:</p>\n<pre><code>---\n- hosts: all\n\n  tasks:\n\n    # create groups\n    - group: name=evens state=present\n    - group: name=odds state=present\n\n    # create some test users\n    - user: name={{ item }} state=present groups=evens\n      with_sequence: start=0 end=32 format=testuser%02x\n\n    # create a series of directories with even numbers for some reason\n    - file: dest=/var/stuff/{{ item }} state=directory\n      with_sequence: start=4 end=16 stride=2\n\n    # a simpler way to use the sequence plugin\n    # create 4 groups\n    - group: name=group{{ item }} state=present\n      with_sequence: count=4\n</code></pre><h5 id=\"随机选择\"><a href=\"#随机选择\" class=\"headerlink\" title=\"随机选择\"></a>随机选择</h5><p>‘random_choice’功能可以用来随机获取一些值.它并不是负载均衡器(已经有相关的模块了).它有时可以用作一个简化版的负载均衡器,比如作为条件判断:</p>\n<pre><code>- debug: msg={{ item }}\n  with_random_choice:\n     - &quot;go through the door&quot;\n     - &quot;drink from the goblet&quot;\n     - &quot;press the red button&quot;\n     - &quot;do nothing&quot;\n</code></pre><h5 id=\"Do-Until循环\"><a href=\"#Do-Until循环\" class=\"headerlink\" title=\"Do-Until循环\"></a>Do-Until循环</h5><p>有时你想重试一个任务直到达到某个条件.比如下面这个例子:  </p>\n<pre><code>- action: shell /usr/bin/foo\n  register: result\n  until: result.stdout.find(&quot;all systems go&quot;) != -1\n  retries: 5\n  delay: 10\n</code></pre><h5 id=\"查找第一个匹配的文件\"><a href=\"#查找第一个匹配的文件\" class=\"headerlink\" title=\"查找第一个匹配的文件\"></a>查找第一个匹配的文件</h5><p>这其实不是一个循环,但和循环很相似.如果你想引用一个文件,而该文件是从一组文件中根据给定条件匹配出来的.这组文件中部分文件名由变量拼接而成.针对该场景你可以这样做:</p>\n<pre><code>- name: INTERFACES | Create Ansible header for /etc/network/interfaces\n  template: src={{ item }} dest=/etc/foo.conf\n  with_first_found:\n    - &quot;{{ansible_virtualization_type}}_foo.conf&quot;\n    - &quot;default_foo.conf&quot;\n</code></pre><p>该功能还有一个更完整的版本,可以配置搜索路径.请看以下示例:</p>\n<pre><code>- name: some configuration template\n  template: src={{ item }} dest=/etc/file.cfg mode=0444 owner=root group=root\n  with_first_found:\n    - files:\n       - &quot;{{inventory_hostname}}/etc/file.cfg&quot;\n      paths:\n       - ../../../templates.overwrites\n       - ../../../templates\n    - files:\n        - etc/file.cfg\n      paths:\n        - templates\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>链接地址：<a href=\"http://www.ansible.com.cn/docs/YAMLSyntax.html\" target=\"_blank\" rel=\"noopener\">http://www.ansible.com.cn/docs/YAMLSyntax.html</a></p>\n<h3 id=\"环境创建\"><a href=\"#环境创建\" class=\"headerlink\" title=\"环境创建\"></a>环境创建</h3><ul>\n<li>参考<a href=\"./Python-配置虚拟环境.md\">Python-配置虚拟环境</a>,创建ansible的应用环境。</li>\n<li>安装：pip install ansible</li>\n</ul>\n<h3 id=\"建立免密钥登陆\"><a href=\"#建立免密钥登陆\" class=\"headerlink\" title=\"建立免密钥登陆\"></a>建立免密钥登陆</h3><p>为了避免Ansible下发指令时输入目标主机密码，通过证书签名达到SSH无密码是一个好的方案，推荐使用ssh-keygen与ssh-copy-id来实现快速证书的生成和公钥下发，其中ssh-keygen生成一对密钥，使用ssh-copy-id来下发生成的公钥。具体操作如下：<br>生成管理主机得私钥和公钥</p>\n<pre><code>ssh-keygen -t rsa -b 2048 -P &apos;&apos; -f /root/.ssh/id_rsa\n</code></pre><p>添加主机信息到主机清单中</p>\n<pre><code>#host\n192.168.77.129 ansible_ssh_pass=1234567\n192.168.77.130 ansible_ssh_pass=123456   \n</code></pre><p> ansible_ssh_pass密码如果一样的话，这里就不需要定义了。在运行ansible-playbook时 加上-k参数，就可以输入登陆密码</p>\n<p>配置palybook</p>\n<pre><code>- hosts: testhosts\n user: root\n tasks:\n    - name: ssh-copy\n      authorized_key: user=root key=&quot;{{ lookup('file', '/Users/tpw-dev/.ssh/id_rsa.pub') }}&quot;\n      tags: sshkey\n</code></pre><p>运行playbook</p>\n<pre><code>ansible-playbook -i hosts ssh-addkey.yml\n</code></pre><p>这样，管理节点的公钥就会添加到节点得authorized_keys文件中，再把主机清单里的ansible_ssh_pass去掉，执行ansible all -m ping 就不需要密码了。</p>\n<h3 id=\"Inventory-清单-文件\"><a href=\"#Inventory-清单-文件\" class=\"headerlink\" title=\"Inventory(清单)文件\"></a>Inventory(清单)文件</h3><p>Ansible 可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置. 默认的文件路径为 /etc/ansible/hosts，<br>在执行ansible-book命令时，也可通过执行-i选项制定inventory 文件。</p>\n<p>Inventory 参数的说明</p>\n<pre><code>ansible_ssh_host\n          将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.\n\n    ansible_ssh_port\n          ssh端口号.如果不是默认的端口号,通过此变量设置.\n\n    ansible_ssh_user\n          默认的 ssh 用户名\n\n    ansible_ssh_pass\n          ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)\n\n    ansible_sudo_pass\n          sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)\n\n    ansible_sudo_exe (new in version 1.8)\n          sudo 命令路径(适用于1.8及以上版本)\n\n    ansible_connection\n          与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 &apos;smart&apos;,&apos;smart&apos; 方式会根据是否支持 ControlPersist, 来判断&apos;ssh&apos; 方式是否可行.\n\n    ansible_ssh_private_key_file\n          ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.\n\n    ansible_shell_type\n          目标系统的shell类型.默认情况下,命令的执行使用 &apos;sh&apos; 语法,可设置为 &apos;csh&apos; 或 &apos;fish&apos;.\n\n    ansible_python_interpreter\n          目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \\*BSD, 或者 /usr/bin/python\n          不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26).\n          与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....\n</code></pre><h3 id=\"Playbooks-介绍\"><a href=\"#Playbooks-介绍\" class=\"headerlink\" title=\"Playbooks 介绍\"></a>Playbooks 介绍</h3><p>playbook 由一个或多个 ‘plays’ 组成.它的内容是一个以 ‘plays’ 为元素的列表.在 ansible 中,play 的内容,被称为 tasks,即任务.</p>\n<p>这里有一个 playbook,其中仅包含一个 play:</p>\n<pre><code>---\n- hosts: webservers\n  vars:\n    http_port: 80\n    max_clients: 200\n  remote_user: root\n  tasks:\n  - name: ensure apache is at the latest version\n    yum: pkg=httpd state=latest\n  - name: write the apache config file\n    template: src=/srv/httpd.j2 dest=/etc/httpd.conf\n    notify:\n    - restart apache\n</code></pre><h4 id=\"playbook基础\"><a href=\"#playbook基础\" class=\"headerlink\" title=\"playbook基础\"></a>playbook基础</h4><h5 id=\"主机与用户\"><a href=\"#主机与用户\" class=\"headerlink\" title=\"主机与用户\"></a>主机与用户</h5><p><strong>hosts 行的内容是一个或多个组或主机的 patterns,以逗号为分隔符</strong></p>\n<p>remote_user 就是账户名:</p>\n<pre><code>---\n- hosts: webservers\n  remote_user: root\n</code></pre><h5 id=\"Tasks-列表\"><a href=\"#Tasks-列表\" class=\"headerlink\" title=\"Tasks 列表\"></a>Tasks 列表</h5><p>每一个 play 包含了一个 task 列表（任务列表）.一个 task 在其所对应的所有主机上（通过 host pattern 匹配的所有主机）执行完毕之后,下一个 task 才会执行.<br>每个 task 的目标在于执行一个 moudle,modules 具有”幂等”性,意思是如果你再一次地执行 moudle,moudle 只会执行必要的改动,只会改变需要改变的地方.所以重复多次执行 playbook 也很安全.<br>下面是一种基本的 task 的定义,service moudle 使用 key=value 格式的参数,这也是大多数 module 使用的参数格式:</p>\n<pre><code>tasks:\n  - name: make sure apache is running\n    service: name=httpd state=running\n</code></pre><p>比较特别的两个 modudle 是 command 和 shell ,它们不使用 key=value 格式的参数,而是这样:</p>\n<pre><code>tasks:\n  - name: disable selinux\n    command: /sbin/setenforce 0\n</code></pre><p><strong>tasks可添加biaoqian(tags),这样在执行命令时可制定tasks</strong><br>如下：</p>\n<pre><code>- name: Create Base folder\n    file:\n      path: &quot;{{baseDeployPathPrefix}}{{serverId}}&quot;\n      state: directory\n    tags: system\n  - name: copy redis dir \n    synchronize:\n      src: redis-4.0.10\n      dest: &quot;{{baseDeployPathPrefix}}{{serverId}}&quot;\n    tags: redis\n\n ansible-playbook -i test_hosts -e &quot;target=s1001&quot; -t createDB site.yml   \n</code></pre><p>-t 后跟tags，这样就可以指定要执行的tasks</p>\n<h5 id=\"Handlers-在发生改变时执行的操作\"><a href=\"#Handlers-在发生改变时执行的操作\" class=\"headerlink\" title=\"Handlers: 在发生改变时执行的操作\"></a>Handlers: 在发生改变时执行的操作</h5><p>(当发生改动时）’notify’ actions 会在 playbook 的每一个 task 结束时被触发,而且即使有多个不同的 task 通知改动的发生, ‘notify’ actions 只会被触发一次.</p>\n<p>这里有一个例子,当一个文件的内容被改动时,重启两个 services:</p>\n<pre><code>- name: template configuration file\n  template: src=template.j2 dest=/etc/foo.conf\n  notify:\n     - restart memcached\n     - restart apache\n</code></pre><p>‘notify’ 下列出的即是 handlers.</p>\n<p>Handlers 是由通知者进行 notify, 如果没有被 notify,handlers 不会执行.</p>\n<p>这里是一个 handlers 的示例:</p>\n<pre><code>handlers:\n    - name: restart memcached\n      service:  name=memcached state=restarted\n    - name: restart apache\n      service: name=apache state=restarted\n</code></pre><p><strong>handlers 会按照声明的顺序执行</strong></p>\n<h5 id=\"提示与技巧\"><a href=\"#提示与技巧\" class=\"headerlink\" title=\"提示与技巧\"></a>提示与技巧</h5><p>如果想看到执行成功的 modules 的输出信息,使用 –verbose flag（否则只有执行失败的才会有输出信息）.</p>\n<p>在执行一个 playbook 之前,想看看这个 playbook 的执行会影响到哪些 hosts,你可以这样做:</p>\n<pre><code>ansible-playbook playbook.yml --list-hosts\n</code></pre><h3 id=\"Roles\"><a href=\"#Roles\" class=\"headerlink\" title=\"Roles\"></a>Roles</h3><p>一个项目的结构如下:</p>\n<pre><code>site.yml\nwebservers.yml\nfooservers.yml\nroles/\n   common/\n     files/\n     templates/\n     tasks/\n     handlers/\n     vars/\n     defaults/\n     meta/\n   webservers/\n     files/\n     templates/\n     tasks/\n     handlers/\n     vars/\n     defaults/\n     meta/\n</code></pre><p>一个 playbook 如下:</p>\n<pre><code>---\n- hosts: webservers\n  roles:\n     - common\n     - webservers\n</code></pre><p>这个 playbook 为一个角色 ‘x’ 指定了如下的行为：</p>\n<ul>\n<li>如果 roles/x/tasks/main.yml 存在, 其中列出的 tasks 将被添加到 play 中</li>\n<li>如果 roles/x/handlers/main.yml 存在, 其中列出的 handlers 将被添加到 play 中</li>\n<li>如果 roles/x/vars/main.yml 存在, 其中列出的 variables 将被添加到 play 中</li>\n<li>如果 roles/x/meta/main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中 (1.3 and later)</li>\n<li>所有 copy tasks 可以引用 roles/x/files/ 中的文件，不需要指明文件的路径。</li>\n<li>所有 script tasks 可以引用 roles/x/files/ 中的脚本，不需要指明文件的路径。</li>\n<li>所有 template tasks 可以引用 roles/x/templates/ 中的文件，不需要指明文件的路径。</li>\n<li>所有 include tasks 可以引用 roles/x/tasks/ 中的文件，不需要指明文件的路径。    </li>\n</ul>\n<p>如果你希望定义一些 tasks，让它们在 roles 之前以及之后执行，你可以这样做:</p>\n<pre><code>---\n\n- hosts: webservers\n\n  pre_tasks:\n    - shell: echo &apos;hello&apos;\n\n  roles:\n    - { role: some_role }\n\n  tasks:\n    - shell: echo &apos;still busy&apos;\n\n  post_tasks:\n    - shell: echo &apos;goodbye&apos;\n</code></pre><p><strong>值得指出的是,handlers 会在 ‘pre_tasks’, ‘roles’, ‘tasks’, 和 ‘post_tasks’ 之间自动执行. 如果你想立即执行所有的 handler 命令.</strong></p>\n<pre><code>tasks:\n   - shell: some tasks go here\n   - meta: flush_handlers\n   - shell: some other tasks\n</code></pre><h4 id=\"Ansible-Galaxy\"><a href=\"#Ansible-Galaxy\" class=\"headerlink\" title=\"Ansible Galaxy\"></a>Ansible Galaxy</h4><p><a href=\"https://galaxy.ansible.com/home\" target=\"_blank\" rel=\"noopener\">Ansible Galaxy</a> 是一个自由网站，网站提供所有类型的由社区开发的 roles，这对于实现你的自动化项目是一个很好的参考。网站提供这些 roles 的排名、查找以及下载。</p>\n<h3 id=\"Variables-变量\"><a href=\"#Variables-变量\" class=\"headerlink\" title=\"Variables(变量)\"></a>Variables(变量)</h3><h4 id=\"定义变量\"><a href=\"#定义变量\" class=\"headerlink\" title=\"定义变量\"></a>定义变量</h4><ul>\n<li>在Inventory中定义变量</li>\n<li>在playbook中定义变量</li>\n<li><p>在文件和role中定义变量</p>\n<h4 id=\"使用变量-关于Jinja2\"><a href=\"#使用变量-关于Jinja2\" class=\"headerlink\" title=\"使用变量: 关于Jinja2\"></a>使用变量: 关于Jinja2</h4><p>变量替换最基本的形式:</p>\n<p>  template: src=foo.cfg.j2 dest=/foo.cfg</p>\n<h4 id=\"YAML陷阱\"><a href=\"#YAML陷阱\" class=\"headerlink\" title=\"YAML陷阱\"></a>YAML陷阱</h4><p>YAML语法要求如果值以开头的话我们需要将整行用双引号包起来.这是为了确认你不是想声明一个YAML字典.</p>\n</li>\n</ul>\n<p>这样是不行的:</p>\n<pre><code>- hosts: app_servers\n  vars:\n      app_path: {{ base_path }}/22\n</code></pre><p>你应该这么做:</p>\n<pre><code>- hosts: app_servers\n  vars:\n       app_path: &quot;{{ base_path }}/22&quot;\n</code></pre><h4 id=\"Facts\"><a href=\"#Facts\" class=\"headerlink\" title=\"Facts\"></a>Facts</h4><p>Facts通过访问远程系统获取相应的信息. 一个例子就是远程主机的IP地址或者操作系统是什么. 使用以下命令可以查看哪些信息是可用的:</p>\n<pre><code>ansible hostname -m setup\n</code></pre><p>这会返回巨量的变量数据,默认是生成这些信息的，可以在playbook中这样引用远程系统的主机名</p>\n<pre><code>{{ ansible_nodename }}\n</code></pre><p>关闭Facts</p>\n<pre><code>- hosts: whatever\n  gather_facts: no\n</code></pre><h4 id=\"Fact缓存\"><a href=\"#Fact缓存\" class=\"headerlink\" title=\"Fact缓存\"></a>Fact缓存</h4><p>因为缓存的存在，从一个服务器引用另一个服务器的变量是可行的.</p>\n<pre><code>{{ hostvars['asdf.example.com']['ansible_os_family'] }}\n</code></pre><h4 id=\"命令行中传递变量\"><a href=\"#命令行中传递变量\" class=\"headerlink\" title=\"命令行中传递变量\"></a>命令行中传递变量</h4><p>除了<code>vars_prompt</code>和<code>vars_files</code>也可以通过Ansible命令行发送变量.如果你想编写一个通用的发布playbook时则特别有用,你可以传递应用的版本以便部署:</p>\n<pre><code>---\n- hosts: &quot;{{ target }}&quot;\n  gather_facts: false\n  remote_user: root\n  roles:\n  - common\n  - game\n\n\nansible-playbook -i test_hosts -e &quot;target=s1001&quot; -t createDB site.yml\n</code></pre><h3 id=\"条件选择\"><a href=\"#条件选择\" class=\"headerlink\" title=\"条件选择\"></a>条件选择</h3><h4 id=\"When-语句\"><a href=\"#When-语句\" class=\"headerlink\" title=\"When 语句\"></a>When 语句</h4><p>想忽略某一错误,通过执行成功与否来做决定,我们可以像这样:</p>\n<pre><code>tasks:\n  - command: /bin/false\n    register: result\n    ignore_errors: True\n  - command: /bin/something\n    when: result|failed\n  - command: /bin/something_else\n    when: result|success\n  - command: /bin/still/something_else\n    when: result|skipped\n</code></pre><p>如果想查看哪些事件在某个特定系统中时允许的,可以执行以下命令:</p>\n<pre><code>ansible hostname.example.com -m setup\n</code></pre><p>有些时候你得到一个返回参数的值是一个字符串,并且你还想使用数学操作来比较它,那么你可以执行一下操作:</p>\n<pre><code>tasks:\n  - shell: echo &quot;only on Red Hat 6, derivatives, and later&quot;\n    when: ansible_os_family == &quot;RedHat&quot; and ansible_lsb.major_release|int &gt;= 6    \n</code></pre><h4 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h4><h5 id=\"标准循环\"><a href=\"#标准循环\" class=\"headerlink\" title=\"标准循环\"></a>标准循环</h5><p>为了保持简洁,重复的任务可以用以下简写的方式:</p>\n<pre><code>- name: add several users\n  user: name={{ item.name }} state=present groups={{ item.groups }}\n  with_items:\n    - { name: &apos;testuser1&apos;, groups: &apos;wheel&apos; }\n    - { name: &apos;testuser2&apos;, groups: &apos;root&apos; }\n</code></pre><h5 id=\"嵌套循环\"><a href=\"#嵌套循环\" class=\"headerlink\" title=\"嵌套循环\"></a>嵌套循环</h5><pre><code>- name: give users access to multiple databases\n  mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL append_privs=yes password=foo\n  with_nested:\n    - [ &apos;alice&apos;, &apos;bob&apos; ]\n    - [ &apos;clientdb&apos;, &apos;employeedb&apos;, &apos;providerdb&apos; ]\n</code></pre><h5 id=\"对哈希表使用循环\"><a href=\"#对哈希表使用循环\" class=\"headerlink\" title=\"对哈希表使用循环\"></a>对哈希表使用循环</h5><p>假如你有以下变量:</p>\n<pre><code>---\nusers:\n  alice:\n    name: Alice Appleworth\n    telephone: 123-456-7890\n  bob:\n    name: Bob Bananarama\n    telephone: 987-654-3210\n</code></pre><p>你想打印出每个用户的名称和电话号码.你可以使用 with_dict 来循环哈希表中的元素:</p>\n<pre><code>tasks:\n  - name: Print phone records\n    debug: msg=&quot;User {{ item.key }} is {{ item.value.name }} ({{ item.value.telephone }})&quot;\n    with_dict: &quot;{{users}}&quot;\n</code></pre><h5 id=\"对文件列表使用循环\"><a href=\"#对文件列表使用循环\" class=\"headerlink\" title=\"对文件列表使用循环\"></a>对文件列表使用循环</h5><p> with_fileglob 可以以非递归的方式来模式匹配单个目录中的文件.如下面所示:</p>\n<pre><code>---\n- hosts: all\n\n  tasks:\n\n    # first ensure our target directory exists\n    - file: dest=/etc/fooapp state=directory\n\n    # copy each file over that matches the given pattern\n    - copy: src={{ item }} dest=/etc/fooapp/ owner=root mode=600\n      with_fileglob:\n        - /playbooks/files/fooapp/*\n</code></pre><h5 id=\"对并行数据集使用循环\"><a href=\"#对并行数据集使用循环\" class=\"headerlink\" title=\"对并行数据集使用循环\"></a>对并行数据集使用循环</h5><p>假设你通过某种方式加载了以下变量数据:</p>\n<pre><code>---\nalpha: [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]\nnumbers:  [ 1, 2, 3, 4 ]   \n</code></pre><p>如果你想得到’(a, 1)’和’(b, 2)’之类的集合.可以使用’with_together’:</p>\n<pre><code>tasks:\n    - debug: msg=&quot;{{ item.0 }} and {{ item.1 }}&quot;\n      with_together:\n        - &quot;{{alpha}}&quot;\n        - &quot;{{numbers}}&quot;\n</code></pre><h5 id=\"对子元素使用循环\"><a href=\"#对子元素使用循环\" class=\"headerlink\" title=\"对子元素使用循环\"></a>对子元素使用循环</h5><p>假设你想对一组用户做一些动作,比如创建这些用户,并且允许它们使用一组SSH key来登录.</p>\n<p>如何实现那? 先假设你有按以下方式定义的数据,可以通过”vars_files”或”group_vars/all”文件加载:</p>\n<pre><code>---\nusers:\n  - name: alice\n    authorized:\n      - /tmp/alice/onekey.pub\n      - /tmp/alice/twokey.pub\n    mysql:\n        password: mysql-password\n        hosts:\n          - &quot;%&quot;\n          - &quot;127.0.0.1&quot;\n          - &quot;::1&quot;\n          - &quot;localhost&quot;\n        privs:\n          - &quot;*.*:SELECT&quot;\n          - &quot;DB1.*:ALL&quot;\n  - name: bob\n    authorized:\n      - /tmp/bob/id_rsa.pub\n    mysql:\n        password: other-mysql-password\n        hosts:\n          - &quot;db1&quot;\n        privs:\n          - &quot;*.*:SELECT&quot;\n          - &quot;DB2.*:ALL&quot;\n</code></pre><p>那么可以这样实现:</p>\n<pre><code>- user: name={{ item.name }} state=present generate_ssh_key=yes\n  with_items: &quot;{{users}}&quot;\n\n- authorized_key: &quot;user={{ item.0.name }} key=&apos;{{ lookup('file', item.1) }}&apos;&quot;\n  with_subelements:\n     - users\n     - authorized\n</code></pre><p>根据mysql hosts以及预先给定的privs subkey列表,我们也可以在嵌套的subkey中迭代列表:</p>\n<pre><code>- name: Setup MySQL users\n  mysql_user: name={{ item.0.user }} password={{ item.0.mysql.password }} host={{ item.1 }} priv={{ item.0.mysql.privs | join('/') }}\n  with_subelements:\n    - users\n    - mysql.hosts\n</code></pre><h5 id=\"对整数序列使用循环\"><a href=\"#对整数序列使用循环\" class=\"headerlink\" title=\"对整数序列使用循环\"></a>对整数序列使用循环</h5><p>with_sequence 可以以升序数字顺序生成一组序列.你可以指定起始值、终止值,以及一个可选的步长值.</p>\n<p>指定参数时也可以使用key=value这种键值对的方式.如果采用这种方式,’format’是一个可打印的字符串.</p>\n<p>数字值可以被指定为10进制,16进制(0x3f8)或者八进制(0600).负数则不受支持.请看以下示例:</p>\n<pre><code>---\n- hosts: all\n\n  tasks:\n\n    # create groups\n    - group: name=evens state=present\n    - group: name=odds state=present\n\n    # create some test users\n    - user: name={{ item }} state=present groups=evens\n      with_sequence: start=0 end=32 format=testuser%02x\n\n    # create a series of directories with even numbers for some reason\n    - file: dest=/var/stuff/{{ item }} state=directory\n      with_sequence: start=4 end=16 stride=2\n\n    # a simpler way to use the sequence plugin\n    # create 4 groups\n    - group: name=group{{ item }} state=present\n      with_sequence: count=4\n</code></pre><h5 id=\"随机选择\"><a href=\"#随机选择\" class=\"headerlink\" title=\"随机选择\"></a>随机选择</h5><p>‘random_choice’功能可以用来随机获取一些值.它并不是负载均衡器(已经有相关的模块了).它有时可以用作一个简化版的负载均衡器,比如作为条件判断:</p>\n<pre><code>- debug: msg={{ item }}\n  with_random_choice:\n     - &quot;go through the door&quot;\n     - &quot;drink from the goblet&quot;\n     - &quot;press the red button&quot;\n     - &quot;do nothing&quot;\n</code></pre><h5 id=\"Do-Until循环\"><a href=\"#Do-Until循环\" class=\"headerlink\" title=\"Do-Until循环\"></a>Do-Until循环</h5><p>有时你想重试一个任务直到达到某个条件.比如下面这个例子:  </p>\n<pre><code>- action: shell /usr/bin/foo\n  register: result\n  until: result.stdout.find(&quot;all systems go&quot;) != -1\n  retries: 5\n  delay: 10\n</code></pre><h5 id=\"查找第一个匹配的文件\"><a href=\"#查找第一个匹配的文件\" class=\"headerlink\" title=\"查找第一个匹配的文件\"></a>查找第一个匹配的文件</h5><p>这其实不是一个循环,但和循环很相似.如果你想引用一个文件,而该文件是从一组文件中根据给定条件匹配出来的.这组文件中部分文件名由变量拼接而成.针对该场景你可以这样做:</p>\n<pre><code>- name: INTERFACES | Create Ansible header for /etc/network/interfaces\n  template: src={{ item }} dest=/etc/foo.conf\n  with_first_found:\n    - &quot;{{ansible_virtualization_type}}_foo.conf&quot;\n    - &quot;default_foo.conf&quot;\n</code></pre><p>该功能还有一个更完整的版本,可以配置搜索路径.请看以下示例:</p>\n<pre><code>- name: some configuration template\n  template: src={{ item }} dest=/etc/file.cfg mode=0444 owner=root group=root\n  with_first_found:\n    - files:\n       - &quot;{{inventory_hostname}}/etc/file.cfg&quot;\n      paths:\n       - ../../../templates.overwrites\n       - ../../../templates\n    - files:\n        - etc/file.cfg\n      paths:\n        - templates\n</code></pre>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjqp0aihx0000y0w0fpqkdaqh","category_id":"cjqp0aii80002y0w0ob1gzb6x","_id":"cjqp0aiie000by0w0pqt91rlp"},{"post_id":"cjqp0aii60001y0w01l8lx81z","category_id":"cjqp0aiic0007y0w0z2jps1tb","_id":"cjqp0aiij000jy0w0d9p0e57j"},{"post_id":"cjqp0aiia0004y0w0c6amnm80","category_id":"cjqp0aiic0007y0w0z2jps1tb","_id":"cjqp0aiin000oy0w0gbd2xozq"},{"post_id":"cjqp0aiib0005y0w0wof7ma8m","category_id":"cjqp0aiii000iy0w0puv7rvhb","_id":"cjqp0aiip000uy0w0tz43oew4"},{"post_id":"cjqp0aiil000ny0w0eh2idzr3","category_id":"cjqp0aii80002y0w0ob1gzb6x","_id":"cjqp0aiir000xy0w00vc87eoo"},{"post_id":"cjqp0aiio000ry0w0udq5slsv","category_id":"cjqp0aii80002y0w0ob1gzb6x","_id":"cjqp0aiis0011y0w0v2q1dgao"},{"post_id":"cjqp0aiib0006y0w0ify05je1","category_id":"cjqp0aiii000iy0w0puv7rvhb","_id":"cjqp0aiit0015y0w0fc533nb0"},{"post_id":"cjqp0aiio000sy0w0vd1o8ws0","category_id":"cjqp0aiic0007y0w0z2jps1tb","_id":"cjqp0aiiu0018y0w0ge81spzl"},{"post_id":"cjqp0aiiq000vy0w05g0bh89x","category_id":"cjqp0aiii000iy0w0puv7rvhb","_id":"cjqp0aiiv001by0w0vor3fcb6"},{"post_id":"cjqp0aiid0009y0w04jue7zlq","category_id":"cjqp0aiii000iy0w0puv7rvhb","_id":"cjqp0aiiw001fy0w0t4tl3s33"},{"post_id":"cjqp0aiis0013y0w0wgvqx8mi","category_id":"cjqp0aii80002y0w0ob1gzb6x","_id":"cjqp0aiix001iy0w057eono3i"},{"post_id":"cjqp0aiie000ay0w0qp6rqrd1","category_id":"cjqp0aiis0010y0w09mkegiel","_id":"cjqp0aiiz001my0w08vc20mn6"},{"post_id":"cjqp0aiit0016y0w0r2qji70l","category_id":"cjqp0aiii000iy0w0puv7rvhb","_id":"cjqp0aij0001py0w03lyt0i1w"},{"post_id":"cjqp0aiiw001ey0w09a9urb37","category_id":"cjqp0aiii000iy0w0puv7rvhb","_id":"cjqp0aij0001ry0w0922hxc4k"},{"post_id":"cjqp0aiih000gy0w04z69t2x8","category_id":"cjqp0aiiu0019y0w0auccpey0","_id":"cjqp0aij1001sy0w0u6l6bc4w"},{"post_id":"cjqp0aiix001gy0w0qng99d1b","category_id":"cjqp0aii80002y0w0ob1gzb6x","_id":"cjqp0aij1001uy0w0jt4wfyty"},{"post_id":"cjqp0aiiy001ky0w0ay3rtppr","category_id":"cjqp0aiic0007y0w0z2jps1tb","_id":"cjqp0aij1001wy0w048vpeiqj"},{"post_id":"cjqp0aiij000ly0w0bhoztahl","category_id":"cjqp0aiiu0019y0w0auccpey0","_id":"cjqp0aij2001zy0w0go3cbbnk"},{"post_id":"cjqp0aiiu001ay0w0jhq2267w","category_id":"cjqp0aiiu0019y0w0auccpey0","_id":"cjqp0aij20021y0w0ovgzb9ce"},{"post_id":"cjqp0aijc0039y0w0iza0s8hf","category_id":"cjqp0aii80002y0w0ob1gzb6x","_id":"cjqp0aijd003by0w078res4dc"},{"post_id":"cjqp0aijk003ey0w00pr388pi","category_id":"cjqp0aii80002y0w0ob1gzb6x","_id":"cjqp0aijm003gy0w0rqn8xsem"}],"PostTag":[{"post_id":"cjqp0aihx0000y0w0fpqkdaqh","tag_id":"cjqp0aii90003y0w0o5oh2360","_id":"cjqp0aiih000fy0w0qe7vi3bw"},{"post_id":"cjqp0aihx0000y0w0fpqkdaqh","tag_id":"cjqp0aiic0008y0w0uy0kcjqi","_id":"cjqp0aiii000hy0w0uex3azl3"},{"post_id":"cjqp0aii60001y0w01l8lx81z","tag_id":"cjqp0aiif000dy0w0rk3gfmqx","_id":"cjqp0aiil000my0w0mmmiclsa"},{"post_id":"cjqp0aiia0004y0w0c6amnm80","tag_id":"cjqp0aiij000ky0w0501xy2cy","_id":"cjqp0aiir000yy0w0hrgv26dk"},{"post_id":"cjqp0aiia0004y0w0c6amnm80","tag_id":"cjqp0aiin000qy0w0qfcmymmj","_id":"cjqp0aiis0012y0w09bqg8mn3"},{"post_id":"cjqp0aiib0005y0w0wof7ma8m","tag_id":"cjqp0aiiq000wy0w04ul6djsm","_id":"cjqp0aiiu0017y0w0f01srgvi"},{"post_id":"cjqp0aiit0016y0w0r2qji70l","tag_id":"cjqp0aiiq000wy0w04ul6djsm","_id":"cjqp0aiiv001dy0w03kqvc697"},{"post_id":"cjqp0aiib0006y0w0ify05je1","tag_id":"cjqp0aiit0014y0w0clv7xoq2","_id":"cjqp0aiiz001ly0w0tlkavz3i"},{"post_id":"cjqp0aiib0006y0w0ify05je1","tag_id":"cjqp0aiiq000wy0w04ul6djsm","_id":"cjqp0aij0001oy0w01nxcdmol"},{"post_id":"cjqp0aiid0009y0w04jue7zlq","tag_id":"cjqp0aiiy001jy0w0huknh0c7","_id":"cjqp0aij1001vy0w03guatynk"},{"post_id":"cjqp0aiid0009y0w04jue7zlq","tag_id":"cjqp0aij0001qy0w0o9ah04rc","_id":"cjqp0aij1001xy0w0tds5ogjh"},{"post_id":"cjqp0aiie000ay0w0qp6rqrd1","tag_id":"cjqp0aij1001ty0w0diukicjk","_id":"cjqp0aij20020y0w0zq22lgyn"},{"post_id":"cjqp0aiig000ey0w0vyunenj0","tag_id":"cjqp0aiiq000wy0w04ul6djsm","_id":"cjqp0aij30024y0w0k1kodahf"},{"post_id":"cjqp0aiig000ey0w0vyunenj0","tag_id":"cjqp0aij20022y0w0w74x2amz","_id":"cjqp0aij30025y0w07f9cvvjn"},{"post_id":"cjqp0aiih000gy0w04z69t2x8","tag_id":"cjqp0aij20023y0w0iuqkgwys","_id":"cjqp0aij30027y0w0egpvfldl"},{"post_id":"cjqp0aiij000ly0w0bhoztahl","tag_id":"cjqp0aij20023y0w0iuqkgwys","_id":"cjqp0aij4002ay0w06ez6j61y"},{"post_id":"cjqp0aiij000ly0w0bhoztahl","tag_id":"cjqp0aiiq000wy0w04ul6djsm","_id":"cjqp0aij4002by0w05705860v"},{"post_id":"cjqp0aiil000ny0w0eh2idzr3","tag_id":"cjqp0aii90003y0w0o5oh2360","_id":"cjqp0aij4002dy0w094x2y7y5"},{"post_id":"cjqp0aiil000ny0w0eh2idzr3","tag_id":"cjqp0aij40029y0w0dgktsudt","_id":"cjqp0aij4002ey0w0spbld3gi"},{"post_id":"cjqp0aiio000ry0w0udq5slsv","tag_id":"cjqp0aii90003y0w0o5oh2360","_id":"cjqp0aij5002iy0w0kjqdc7nw"},{"post_id":"cjqp0aiio000ry0w0udq5slsv","tag_id":"cjqp0aij40029y0w0dgktsudt","_id":"cjqp0aij5002jy0w092t82pvd"},{"post_id":"cjqp0aiio000ry0w0udq5slsv","tag_id":"cjqp0aij5002fy0w06t3rty9k","_id":"cjqp0aij6002ly0w0vccxc1xt"},{"post_id":"cjqp0aiio000ry0w0udq5slsv","tag_id":"cjqp0aij5002gy0w00ay9wea0","_id":"cjqp0aij6002my0w0wuz41yp8"},{"post_id":"cjqp0aiio000sy0w0vd1o8ws0","tag_id":"cjqp0aij5002hy0w05nrqu34z","_id":"cjqp0aij6002oy0w06z0cn44f"},{"post_id":"cjqp0aiio000sy0w0vd1o8ws0","tag_id":"cjqp0aij5002ky0w0ocxmxxn2","_id":"cjqp0aij6002py0w0ujpof5a4"},{"post_id":"cjqp0aiiq000vy0w05g0bh89x","tag_id":"cjqp0aij20023y0w0iuqkgwys","_id":"cjqp0aij7002sy0w0zubap0tb"},{"post_id":"cjqp0aiiq000vy0w05g0bh89x","tag_id":"cjqp0aij6002qy0w01djq5kzt","_id":"cjqp0aij7002ty0w0obbvxa9e"},{"post_id":"cjqp0aiis0013y0w0wgvqx8mi","tag_id":"cjqp0aij40029y0w0dgktsudt","_id":"cjqp0aij7002vy0w0fhwdkq0y"},{"post_id":"cjqp0aiiu001ay0w0jhq2267w","tag_id":"cjqp0aij20023y0w0iuqkgwys","_id":"cjqp0aij8002xy0w0q2jv0968"},{"post_id":"cjqp0aiiw001ey0w09a9urb37","tag_id":"cjqp0aij8002wy0w0979psf1q","_id":"cjqp0aij80030y0w0a7ep17j8"},{"post_id":"cjqp0aiiw001ey0w09a9urb37","tag_id":"cjqp0aij8002yy0w0ntwx7kw1","_id":"cjqp0aij80031y0w0ijh4swcq"},{"post_id":"cjqp0aiix001gy0w0qng99d1b","tag_id":"cjqp0aij8002zy0w0p1imcng8","_id":"cjqp0aij90034y0w0cjpjr69f"},{"post_id":"cjqp0aiix001gy0w0qng99d1b","tag_id":"cjqp0aij80032y0w0ozk3hn3g","_id":"cjqp0aij90035y0w044080wt1"},{"post_id":"cjqp0aiiy001ky0w0ay3rtppr","tag_id":"cjqp0aij90033y0w0eled0iwd","_id":"cjqp0aija0037y0w0z9t4nvsw"},{"post_id":"cjqp0aiiy001ky0w0ay3rtppr","tag_id":"cjqp0aij8002zy0w0p1imcng8","_id":"cjqp0aija0038y0w0u8vzs6p9"},{"post_id":"cjqp0aijc0039y0w0iza0s8hf","tag_id":"cjqp0aij40029y0w0dgktsudt","_id":"cjqp0aije003cy0w0e7d2yp2v"},{"post_id":"cjqp0aijc0039y0w0iza0s8hf","tag_id":"cjqp0aijd003ay0w0seriacdk","_id":"cjqp0aije003dy0w0v80k7mr4"},{"post_id":"cjqp0aijk003ey0w00pr388pi","tag_id":"cjqp0aijl003fy0w0h5nqaol4","_id":"cjqp0aijm003iy0w0kdr6zgsg"},{"post_id":"cjqp0aijk003ey0w00pr388pi","tag_id":"cjqp0aijm003hy0w0sij4oyme","_id":"cjqp0aijm003jy0w019fu8yax"}],"Tag":[{"name":"centos","_id":"cjqp0aii90003y0w0o5oh2360"},{"name":"shadowsocks-libev","_id":"cjqp0aiic0008y0w0uy0kcjqi"},{"name":"Alfred","_id":"cjqp0aiif000dy0w0rk3gfmqx"},{"name":"Dash","_id":"cjqp0aiij000ky0w0501xy2cy"},{"name":"Mac","_id":"cjqp0aiin000qy0w0qfcmymmj"},{"name":"前端","_id":"cjqp0aiiq000wy0w04ul6djsm"},{"name":"Hexo","_id":"cjqp0aiit0014y0w0clv7xoq2"},{"name":"IOS","_id":"cjqp0aiiy001jy0w0huknh0c7"},{"name":"审核","_id":"cjqp0aij0001qy0w0o9ah04rc"},{"name":"Git","_id":"cjqp0aij1001ty0w0diukicjk"},{"name":"工具","_id":"cjqp0aij20022y0w0w74x2amz"},{"name":"Python","_id":"cjqp0aij20023y0w0iuqkgwys"},{"name":"linux","_id":"cjqp0aij40029y0w0dgktsudt"},{"name":"443","_id":"cjqp0aij5002fy0w06t3rty9k"},{"name":"后端","_id":"cjqp0aij5002gy0w00ay9wea0"},{"name":"charles","_id":"cjqp0aij5002hy0w05nrqu34z"},{"name":"android","_id":"cjqp0aij5002ky0w0ocxmxxn2"},{"name":"django","_id":"cjqp0aij6002qy0w01djq5kzt"},{"name":"windows10","_id":"cjqp0aij8002wy0w0979psf1q"},{"name":"windows defender","_id":"cjqp0aij8002yy0w0ntwx7kw1"},{"name":"翻墙","_id":"cjqp0aij8002zy0w0p1imcng8"},{"name":"securecrt","_id":"cjqp0aij80032y0w0ozk3hn3g"},{"name":"Chrome","_id":"cjqp0aij90033y0w0eled0iwd"},{"name":"命令","_id":"cjqp0aijd003ay0w0seriacdk"},{"name":"ansible","_id":"cjqp0aijl003fy0w0h5nqaol4"},{"name":"运维","_id":"cjqp0aijm003hy0w0sij4oyme"}]}}